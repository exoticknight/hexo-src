<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="中文, English, 日本语">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="IT, frontend">
<meta property="og:type" content="website">
<meta property="og:title" content="exoticknight&#39;s blog">
<meta property="og:url" content="https://www.e10t.net/index.html">
<meta property="og:site_name" content="exoticknight&#39;s blog">
<meta property="og:locale" content="中文, English, 日本语">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="exoticknight&#39;s blog">



  <link rel="alternate" href="/atom.xml" title="exoticknight's blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://www.e10t.net/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>exoticknight's blog – 年寿有时而尽，荣乐止乎其身，二者必至之常期，未若文章之无穷</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="中文, English, 日本语">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">exoticknight's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">年寿有时而尽，荣乐止乎其身，二者必至之常期，未若文章之无穷</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/exoticknight" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2017/08/06/mocha-chai-istanbul-in-es2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/06/mocha-chai-istanbul-in-es2015/" class="post-title-link" itemprop="url">Mocha + Chai + istanbul in ES2015</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-08-06 15:20:41 / Modified: 15:45:21" itemprop="dateCreated datePublished" datetime="2017-08-06T15:20:41+08:00">2017-08-06</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2017/08/06/mocha-chai-istanbul-in-es2015/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/08/06/mocha-chai-istanbul-in-es2015/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用 JavaScript 写代码的时候，无论是使用 TDD 方法还是为了保证代码的质量和可维护性，都应该考虑加上单元测试。在博文 <a href="https://blog.e10t.net/mocha-chai-travis-ci-codecov-workflow/" target="_blank" rel="noopener">mocha + chai + Travis CI + Codecov 使用流程</a> 中有简单地介绍了如何使用流行的 JavsScript 库来对代码进行自动测试，检查代码覆盖率。</p>
<p>在那篇文章中，使用的是 Mocha／Chai／istanbul 和在线的 Codecov，以及和 Github 关系密切的 Travis CI，而且测试的 JavaScript 代码是 es5。现在 es2015 已经标准化了，那么教程也需要更新一下了。另外如果项目是私有项目，那么还是使用完备的离线测试环境比较好。接下来就是一个快速可行的教程。</p>
<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>测试框架无需变更，还是 Mocha + Chai 的组合，但是 istanbul 需要稍微变动一下。</p>
<blockquote>
<p>如果你不需要 istanbul 做覆盖率测试，那么需要使用 <code>npm install --save-dev babel-register</code> 和 <code>mocha --require babel-register</code> 使 mocha 能识别 es2015 的代码</p>
</blockquote>
<p>使用新套件，直接安装 <code>npm i -S mocha chai cross-env nyc babel-plugin-istanbul babel-register babel-preset-env</code>。</p>
<p>mocha 和 chai 不用解释了，<code>nyc</code> 可以理解是 istanbul 的命令行工具；<code>babel-plugin-istanbul</code> 是在 babel 中插入 istanbul，<code>babel-register</code> 是 istanbul 使用的 babel 接口，这样两个库就打通了；最后 <code>babel-preset-env</code> 是 babel 的运行配置。</p>
<p>先来配置 <code>babel-plugin-istanbul</code>，新建 <code>.babelrc</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;plugins&quot;: [ &quot;istanbul&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>presets</code> 配置告诉 babel 使用 <code>babel-preset-env</code>。当然也可以用 ‘es2015’ + ‘stage-0’ 的组合，具体可以自行斟酌。</p>
<p><code>env.test.plugins</code> 告诉 babel 在 <code>NODE_ENV=test</code> 的情况下使用插件 <code>babel-plugin-istanbul</code>。</p>
<p>接下来配置 <code>babel-register</code>，新建 <code>.nycrc</code>：</p>
<blockquote>
<p><code>.nycrc</code> 是 nyc 的配置文件，和 <code>.babelrc</code> 类似，当然配置也是可以直接写进 <code>package.json</code> 的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: [</span><br><span class="line">    &quot;babel-register&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;reporter&quot;: [</span><br><span class="line">    &quot;lcov&quot;,</span><br><span class="line">    &quot;text-summary&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;sourceMap&quot;: false,</span><br><span class="line">  &quot;instrument&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的配置直接用了官方的配置。<code>require</code> 字段告诉 nyc 使用 <code>babel-register</code>，<code>reporter</code> 字段的 ‘lcov’ 会让 nyc 生成 <code>lcov.info</code> 文件和对应的 HTML 报告，如果使用 <code>lcovonly</code> 则只生成 ‘lcov.info’。’text-summary’ 则是会在控制台输出覆盖率等信息。</p>
<blockquote>
<p>文件会默认生成在 <code>/coverage</code> 下，可以使用 <code>report-dir</code> 字段指定。</p>
</blockquote>
<p>最后，在 <code>package.json</code> 中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;cross-env NODE_ENV=test nyc mocha test/**/*.spec.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="测试编写事例"><a href="#测试编写事例" class="headerlink" title="测试编写事例"></a>测试编写事例</h2><p>比如有 <code>index.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class Test &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.data = &apos;a&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么可以写 <code>test/index.spec.js</code>，可以直接上 ES2015 的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; expect &#125; from &apos;chai&apos;</span><br><span class="line">import &#123; Test &#125; from &apos;../index&apos;</span><br><span class="line"></span><br><span class="line">describe(&apos;index test&apos;, function() &#123;</span><br><span class="line">  it(&apos;should be a string&apos;, function() &#123;</span><br><span class="line">    let test = new Test</span><br><span class="line">    expect(test.data).to.be.a(&apos;string&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用 <code>npm test</code> 运行测试，得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  index test</span><br><span class="line">    ✓ should be a string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (8ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================== Coverage summary ===============================</span><br><span class="line">Statements   : 100% ( 1/1 )</span><br><span class="line">Branches     : 100% ( 0/0 )</span><br><span class="line">Functions    : 100% ( 1/1 )</span><br><span class="line">Lines        : 100% ( 1/1 )</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure>
<h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>在测试中经常需要测试 promise 等异步操作，虽然 Mocha 库是可以使用回调来完成测试的，但是我们当然要用 async／await 啦。</p>
<p>比如，需要测试 <code>index.js</code> 中的 <code>requestAsync</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export class Test &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.data = &apos;a&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestAsync () &#123;</span><br><span class="line">    return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">      res(this.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么需要先 <code>npm i -S babel-polyfill babel-plugin-transform-async-to-generator</code>。</p>
<p>然后配置 <code>.nycrc</code>，加上 ‘babel-polyfill’ 支持 generator 运行时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: [</span><br><span class="line">    &quot;babel-polyfill&quot;,</span><br><span class="line">    &quot;babel-register&quot;</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置 <code>.babelrc</code>，加上 ‘transform-async-to-generator’，将 async 模式转换为 generator 模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;plugins&quot;: [ &quot;istanbul&quot;, &quot;transform-async-to-generator&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着这样测试异步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; expect &#125; from &apos;chai&apos;</span><br><span class="line">import &#123; Test &#125; from &apos;../index&apos;</span><br><span class="line"></span><br><span class="line">describe(&apos;test#requestAsync&apos;, function() &#123;</span><br><span class="line">  it(&apos;should get a string&apos;, async function() &#123;</span><br><span class="line">    const test = new Test</span><br><span class="line">    const ret = await test.requestAsync()</span><br><span class="line">    expect(ret).to.be.a(&apos;string&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在测试项 <code>it</code> 的第二个函数前加 ‘async’ 标志异步，然后在返回 promise 的调用前加上 ‘await’，OK。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  test#requestAsync</span><br><span class="line">    ✓ should get a string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (14ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================== Coverage summary ===============================</span><br><span class="line">Statements   : 100% ( 3/3 )</span><br><span class="line">Branches     : 100% ( 0/0 )</span><br><span class="line">Functions    : 100% ( 3/3 )</span><br><span class="line">Lines        : 100% ( 3/3 )</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2016/12/13/talk-about-a-question-in-nowcoder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/12/13/talk-about-a-question-in-nowcoder/" class="post-title-link" itemprop="url">说说牛客上的一道 JavaScript 题目</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-12-13 20:48:11" itemprop="dateCreated datePublished" datetime="2016-12-13T20:48:11+08:00">2016-12-13</time>
            

            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2016/12/13/talk-about-a-question-in-nowcoder/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/13/talk-about-a-question-in-nowcoder/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>牛客上有这么一道 JavaScript 的<a href="https://www.nowcoder.com/questionTerminal/9c76e58c2ce94eb9b8168b43adef4f50" target="_blank" rel="noopener">题目</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//填写内容让下面代码支持a.name = “name1”; b.name = “name2”;</span><br><span class="line">function obj(name)&#123;</span><br><span class="line">    【1】</span><br><span class="line">&#125;</span><br><span class="line">obj.【2】 = &quot;name2&quot;;</span><br><span class="line">var a = obj(&quot;name1&quot;);</span><br><span class="line">var b = new obj;</span><br></pre></td></tr></table></figure>
<p>【1】和【2】是填写的内容，【2】的答案是 <code>prototype.name</code>，没争议。</p>
<p>问题是【1】，参考答案居然是 <code>if(name){ this.name = name;}return this;</code>，这么随便地玩弄 <code>this</code> 不就是明摆着污染全局变量吗？暴力赋值不可取。</p>
<p>下面的一些高票讨论还说了一大堆解释的废话，连他自己都说自己好罗嗦。对，你不但罗嗦，而且还没有改错。注释里都说了给 window 的属性赋值，还不自知出问题，真是误人子弟。</p>
<p>先来分析一下题目，a 和 b 都从 obj 来，为什么同名的属性值不一样？可以看出，是对 obj 这个函数的调用方式不一样，a 是 obj 函数的调用结果，而 b 则是 obj 作为<em>构造函数</em>调用的结果。所以这题的重点应该是如何区分<em>函数调用</em>和<em>构造函数调用</em>。</p>
<p>一个关键字 <code>new</code> 决定了不同。<code>new</code> 的作用是什么呢？<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN</a> 上说了，面试也会考你的，简单来说是三步，<code>new foo</code>：</p>
<ol>
<li>生成一个继承于 foo.prototype 的对象</li>
<li>foo 会被调用，其中的 <code>this</code> 值会被绑定为 1 中的对象</li>
<li>如果 foo 没有返回一个对象（注意是对象！），则返回 1 的对象</li>
</ol>
<p>从 2 就可以看出 <code>this</code> 值会被 <code>new</code> 绑定为一个确定的对象，而不是像普通函数调用中那样自己不可预料，要看上下文的进程。</p>
<p>于是就可以在这里做文章。先来判断 <code>this</code> 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (this instanceof obj) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code> 会检查 <code>this</code> 的原型链上是否存在 <code>foo.prototype</code>。也就是说能判断是否满足第 1 条，确保了对象能从 <code>prototype</code> 中读取到 <code>name</code> 属性。（毕竟代码中并没有给 b 的赋值中传入）</p>
<blockquote>
<p><code>instanceof</code> 并不是完美的判断方法，但是在这里足够了，后面会谈到这个问题。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (this instanceof obj) &#123;</span><br><span class="line">    // new 调用</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非 new 调用</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非 new 调用的情况下，直接返回一个新对象就 OK 了。</p>
<p>而在 new 调用的情况下，可以看到 <code>function obj(name)</code> 定义的时候是有参数的，调用的时候却没参数，这就要小心了，为了安全起见，还是判断一下为妙。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (this instanceof obj) &#123;</span><br><span class="line">    // new 调用</span><br><span class="line">    if (name !== undefined) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非 new 调用</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，判断会写成 <code>if (name)</code>，但是碰到 <code>null</code>、<code>0</code>、<code>false</code> 就 GG 了，所以还是谨慎点吧。</p>
<p>问题到这里就可以比较完美地解答了。</p>
<p>##bonus: instanceof 的问题<br>『<code>instanceof</code> 会检查 <code>this</code> 的原型链上是否存在 <code>foo.prototype</code>』，为什么说得这么拗口，是因为需要表达出 <code>instanceof</code> 本来就不是真的用来检测是否调用 <code>new</code> 的方法。</p>
<p>在题目里面，要求的是 a 需要从原型链上读取到特定的属性值，所以 <code>instanceof</code> 的作用刚好在这里能符合要求而已。</p>
<p>函数调用除了题目中的方法还有第三种方法，那就是 <code>foo.call</code>、<code>foo.apply</code>，而且也能为函数指定 <code>this</code> 的值（所以还有 <code>bind</code>）。因此是存在方法调戏 <code>instanceof</code> 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo.prototype.name = &apos;foo&apos;</span><br><span class="line">var midman = new foo(&apos;fake foo&apos;)</span><br><span class="line">var a = foo.call(midman)</span><br><span class="line">var b = foo.call(midman, &apos;b&apos;)</span><br><span class="line">a  // undefined, WTF?!</span><br><span class="line">b  // undefined, WTF?!</span><br></pre></td></tr></table></figure>
<p>这里的 <code>foo</code> 调用的方式是作为函数来调用，但是为 <code>this</code> 绑定的值是从 <code>foo</code> 上 <code>new</code> 出来的，换句话说，其原型链上存在 <code>foo.prototype</code>，于是就骗过了 <code>instanceof</code>。</p>
<p>于是 ES2015 来搭救你了，新增了一个 <code>new.target</code>。于是修改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (new.target !== undefined) &#123;</span><br><span class="line">    // new 调用</span><br><span class="line">    if (name !== undefined) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非 new 调用</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2016/05/12/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/05/12/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/" class="post-title-link" itemprop="url">FictionInjection-始动：Angular 依赖注入分析和源码抽取改造（上）</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-05-12 13:56:53" itemprop="dateCreated datePublished" datetime="2016-05-12T13:56:53+08:00">2016-05-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2016-11-08 15:58:22" itemprop="dateModified" datetime="2016-11-08T15:58:22+08:00">2016-11-08</time>
              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2016/05/12/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/12/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>几年前有一个项目构思，由于技术水平低，当时并没有思考得很清楚，所以一直没怎么着手开始。近来前端很多优秀的库出现了，也让我对那个项目有了新的想法。在写了几个 JavaScript 的项目后我觉得可以尝试开始了。尝试并成功写出一些代码之后，就开（挖）始（坑）了这个系列的博文。</p>
<p>项目是写一个 JavaScript 框架，干什么的在此并不是重点，但是首先需要一个可扩展的模块系统。最简单就是直接用 jQuery 扩展的写法，直接将函数等的挂载在一个对象下，不过如此一来模块之间依赖非常多的话，管理起来会十分困难。也可以使用 AMD / CMD 的模块化的方法，不过考虑到 ES2015 已经加入了 import / export 的语法，最好就直接使用。然而使用了 ES2015 的语法之后，仍然使用 AMD 等的语法就显得很别扭，但是又想要依赖注入功能怎么办？</p>
<p>解决方法是模（fu）仿（zhi）著名的 AngularJS 中关于依赖注入的源代码。</p>
<p>Angular 有两个版本，1.x 和 2.x，但是 2.x 中，淡化了模块的概念，直接采用 component 和 ES2015 的 import / export 的机制，所以依赖注入已经不太算是亮点了。而且 Angular2 采用 TypeScript 编写，从语法编写上也不适合作为参考。最后选定 1.4.5 版本。</p>
<blockquote>
<p>Angular 项目下还有一个不怎么有人知道的 <code>di.js</code> 项目，是从 Angular 中独立出来的依赖注入库，但是从文档来看，也是需要 TypeScript 来使用。</p>
</blockquote>
<p>文章较长，给个目录</p>
<p><a name="catalogue"></a></p>
<ul>
<li><a href="#di">实现依赖注入</a></li>
<li><a href="#api">从 API 入手</a></li>
<li><a href="#analyze">开始分析</a></li>
<li><a href="#wrapup">统一包装</a></li>
<li><a href="#brief">小结</a></li>
<li><a href="#injector">注入器的奥秘</a></li>
<li><a href="#unexpected">读源码的意外发现</a></li>
</ul>
<p><a name="di"></a></p>
<p>##实现依赖注入<a href="#catalogue">↑</a><br>JavaScript 如何实现依赖注入呢？AngularJS 给出了三个解决方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 直接在参数里面声明</span><br><span class="line">module.service( function ( $http ) &#123;&#125; )</span><br><span class="line"></span><br><span class="line">// 使用显示注释</span><br><span class="line">function a () &#123;&#125;</span><br><span class="line">a.$inject = [&apos;$http&apos;]</span><br><span class="line">module.service( a )</span><br><span class="line"></span><br><span class="line">// 数组内联</span><br><span class="line">module.service( [&apos;$http&apos;, function ( http ) &#123;&#125;] )</span><br></pre></td></tr></table></figure>
<p>实际上三个方式都是一样的，只是使用方式不一样，最后都是使用了 JavaScript 的闭包来实现依赖的注入，原理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function method ( $http ) &#123;</span><br><span class="line">    return function ( args ) &#123;</span><br><span class="line">        // $http.get( args )</span><br><span class="line">        // .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将依赖作为参数传入 <code>menthod</code> 得到的返回值就是是一个可以调用 <code>$http</code> 服务的函数了。</p>
<p>像这样 <code>[&#39;$http&#39;, function ( http ) {}]</code> 最后一个元素是函数的结构可以称为一个<strong>‘可注入结构’</strong>。</p>
<p><a name="api"></a></p>
<p>##从 API 入手<a href="#catalogue">↑</a><br>Angular 库的源代码文件非常大，一般基本不会从头开始看。而 API 作为库对外的窗口，从 API 的使用顺藤摸瓜地查找代码是比较好的做法。Angular 模块的使用一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// declare module</span><br><span class="line">const a = angular.module( &apos;a&apos;, [] );</span><br><span class="line">const b = angular.module( &apos;b&apos;, [] );</span><br><span class="line">const c = angular.module( &apos;c&apos;, [&apos;a&apos;] );</span><br><span class="line"></span><br><span class="line">// use the module</span><br><span class="line">a</span><br><span class="line">.value( &apos;a&apos;, 123 )</span><br><span class="line">.factory( &apos;a&apos;, function() &#123; return 123; &#125; )</span><br><span class="line">.service( &apos;serviceName&apos;, ... )</span><br><span class="line">.directive( &apos;directiveName&apos;, ... )</span><br><span class="line">.filter( &apos;filterName&apos;, ... );</span><br></pre></td></tr></table></figure>
<p>先创建一个模块，用数组说明它的依赖模块，然后模块就可以调用 <code>value</code>、<code>service</code>、<code>directive</code> 等 API，API 的第一个参数是名字，第二个参数则是值或者函数或者数组，了解 AngularJS 的读者应该知道其实是值或者返回值的构造函数或者包含依赖和构造函数的数组。</p>
<p>打开 Angular.js ，查找出 <code>module(name, requires, configFn)</code> 函数的定义，位于一个更大的函数 <code>setupModuleLoader</code> 内。<code>setupModuleLoader</code> 为 <code>module</code> 函数编写了一些检测函数和变量。最重要的是 <code>modules</code> 变量，用来保存所有的模块信息。</p>
<p>下面来分析 <code>module</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (requires &amp;&amp; modules.hasOwnProperty(name)) &#123;</span><br><span class="line">  modules[name] = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出如果模块重复创建是会覆盖之前的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** @type &#123;angular.Module&#125; */</span><br><span class="line">var moduleInstance = &#123;</span><br></pre></td></tr></table></figure>
<p><code>moduleInstance</code> 就是将会返回出去的模块对象，可以看到里面有 <code>name</code> 和 <code>requires</code> 等属性和 <code>provider</code> 和 <code>factory</code> 等函数。</p>
<p>里面所有的方法，都是通过调用 <code>invokeLater</code> 和 <code>invokeLaterAndSetModuleName</code> 生成的新函数。新函数的上下文中带有 <code>provider</code> 和 <code>method</code> 信息。比如 <code>service</code> 函数：provider=’$provide’，method=’service’，暂时还看不出来信息有什么用，可以先跳过。新函数在调用的时候会将信息连同调用的参数一起 push 进模块的 <code>_invokeQueue</code> 属性中。</p>
<p>绕了一大圈，就是知道了：在调用 <code>value</code>、<code>service</code>、<code>provider</code> 这些基本的模块功能函数的时候，其实只是将构造函数和相关信息先保存了下来，根本就没有做初始化模块等工作。</p>
<p>但是作为一个库必定需要跟 <code>window</code> 或者 <code>document</code> 产生点关系不然无法操作 DOM，根据编写过不少库的经验来看，通常将这样的代码放在最后。于是拉到最后一看，gotcha。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jqLite(document).ready(function() &#123;</span><br><span class="line">  angularInit(document, bootstrap);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>明显意思就是在文档准备完毕的时候调用 <code>angularInit</code>，转到 <code>angularInit</code> 的定义发现调用了 <code>bootstrap(appElement, module ? [module] : [], config);</code>，再转到 <code>bootstrap</code> 的定义，在函数内部又会调用 <code>doBootstrap</code> 函数，一系列的检查之后，调用了 <code>createInjector</code> 函数就结束了，转到 <code>createInjector</code> 的定义一看，有 <code>$provide</code> <code>factory</code> 等字样，说明找对地方了。</p>
<p><a name="analyze"></a></p>
<p>##开始分析<a href="#catalogue">↑</a></p>
<p>重点来分析 <code>createInjector</code> 函数。</p>
<p>函数体大概可以分成四段。</p>
<p>第一段是定义了 <code>providerCache</code>、<code>instanceCache</code>、<code>providerInjector</code> 和 <code>instanceInjector</code>。最后返回 <code>instanceInjector</code> 对象。<code>providerInjector</code> 和 <code>instanceInjector</code> 各为将 <code>providerCache</code> 和 <code>instanceCache</code> 传入 <code>createInternalInjector</code> 函数的返回值。</p>
<p>第二段是 provider 函数的定义，用以供初始化时候的调用。</p>
<p>第三段是 <code>loadModules</code> 函数的定义，作用是，显然，初始化模块。</p>
<p>第四段是 <code>createInternalInjector</code> 函数的定义，函数返回的是真正的注入器。</p>
<p>从第一段的代码来看，真正的工作是在 <code>loadModules</code> 函数中，因为 <code>createInternalInjector</code> 函数只返回一个对象，没有 ‘side effect’ 的代码。</p>
<p><code>loadModules</code> 函数上来就是一个对模块数组的遍历，然后在遍历内取模块的属性 <code>_invokeQueue</code> 来调用 <code>runInvokeQueue</code> 函数对已经缓存下来的对象或方法的构造函数进行处理。</p>
<p>值得注意的是在做调用 <code>runInvokeQueue</code> 前，有一个递归的调用 <code>loadModules(moduleFn.requires)</code>，表明了在初始化本模块之前，会先初始化依赖的模块。</p>
<p>到目前为止，可以判明模块初始化的分两个阶段，第一个是：声明模块及其依赖模块 -&gt; 缓存模块变量的构造函数；第二个是：选取一个根模块（对应 AngularJS 中的 ‘app’ 模块） -&gt; 找出其依赖的模块，对于每一个依赖，递归地先初始化其依赖的模块，再初始化自身 -&gt; 处理模块中缓存的变量的构造函数。</p>
<p>如此采取先缓存所有模块再通过依赖树来初始化的做法虽然看起来繁琐，但是得到一个重要的特性就是声明模块的时候不用关注依赖的顺序，只需要表明依赖就可以了。如果声明的时候就立刻初始化，则必须小心检查所依赖的模块初始化是否已经完成了，然而如此一来就退化成了普通的模块化方法了。<strong>延迟初始化是实现依赖注入的重要过程</strong>。</p>
<p>模块依赖已经明了，现在来看看作为处理函数的 <code>runInvokeQueue</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function runInvokeQueue(queue) &#123;</span><br><span class="line">  var i, ii;</span><br><span class="line">  for (i = 0, ii = queue.length; i &lt; ii; i++) &#123;</span><br><span class="line">    var invokeArgs = queue[i],</span><br><span class="line">        provider = providerInjector.get(invokeArgs[0]);</span><br><span class="line"></span><br><span class="line">    provider[invokeArgs[1]].apply(provider, invokeArgs[2]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重要的代码只有两行，<code>provider = providerInjector.get(invokeArgs[0]);</code> 和 <code>provider[invokeArgs[1]].apply(provider, invokeArgs[2]);</code>。</p>
<p>往上看一下，调用 <code>providerInjector.get</code> 相当于是调用 <code>getService</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function getService(serviceName, caller) &#123;</span><br><span class="line">  if (cache.hasOwnProperty(serviceName)) &#123;</span><br><span class="line">    if (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">      throw $injectorMinErr(&apos;cdep&apos;, &apos;Circular dependency found: &#123;0&#125;&apos;,</span><br><span class="line">                serviceName + &apos; &lt;- &apos; + path.join(&apos; &lt;- &apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[serviceName];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      path.unshift(serviceName);</span><br><span class="line">      cache[serviceName] = INSTANTIATING;</span><br><span class="line">      return cache[serviceName] = factory(serviceName, caller);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      if (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">        delete cache[serviceName];</span><br><span class="line">      &#125;</span><br><span class="line">      throw err;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      path.shift();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码虽多，但基本就是干一件事，返回 <code>cache</code> 中的对象，如果没有，就用 <code>factory</code> 创建一个再返回。而调用的对象 <code>providerInjector</code> 的定义来看，<code>cache</code> 就等于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">providerCache = &#123;</span><br><span class="line">  $provide: &#123;</span><br><span class="line">      provider: supportObject(provider),</span><br><span class="line">      factory: supportObject(factory),</span><br><span class="line">      service: supportObject(service),</span><br><span class="line">      value: supportObject(value),</span><br><span class="line">      constant: supportObject(constant),</span><br><span class="line">      decorator: decorator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>OK，现在可以知道了那些被延迟初始化的模块元素会在这里被处理了。</p>
<p>从上文可以知道，<code>invokeArgs[0]</code> 的值为 <code>$provider</code>，<code>invokeArgs[1]</code> 的值为 service / factory 等，<code>invokeArgs[2]</code> 则为参数数组。</p>
<p>看看以下的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 如此使用</span><br><span class="line">m.service( &apos;b&apos;, [&apos;a&apos;, function ( a ) &#123; this.a = a &#125;] );</span><br><span class="line"></span><br><span class="line">// 初始化的时候实际上调用</span><br><span class="line">$provider.service( &apos;b&apos;, [&apos;a&apos;, function ( a ) &#123; this.a = a &#125;] );</span><br></pre></td></tr></table></figure>
<p><a name="wrapup"></a></p>
<p>##统一包装<a href="#catalogue">↑</a></p>
<p>接下来就是分析模块元素（对外表现为 API）的代码了。</p>
<p>函数有点多，但是还是能看得出来。<code>supportObject</code> 不用管，只是负责转换一下参数，基本的函数是 <code>provider</code>，<code>factory</code> 会调用它，然后 <code>value</code> 和 <code>service</code> 会调用 <code>factory</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function provider(name, provider_) &#123;</span><br><span class="line">  assertNotHasOwnProperty(name, &apos;service&apos;);</span><br><span class="line">  if (isFunction(provider_) || isArray(provider_)) &#123;</span><br><span class="line">    provider_ = providerInjector.instantiate(provider_);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!provider_.$get) &#123;</span><br><span class="line">    throw $injectorMinErr(&apos;pget&apos;, &quot;Provider &apos;&#123;0&#125;&apos; must define $get factory method.&quot;, name);</span><br><span class="line">  &#125;</span><br><span class="line">  return providerCache[name + providerSuffix] = provider_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个判断和第二个判断在 <code>factory</code> 调用的时候是无效的，因为 <code>factory</code> 调用 <code>provider</code> 的时候第二个参数是 Object，而且带有 <code>$get</code> 属性。实际上在本阶段做的是，就是将调用 API 传入的第二个参数（第一个参数是名字）再包装一层对象，再<strong>存储在 <code>providerCache</code> 中</strong>，对象统一拥有 <code>$get</code> 属性，或者说，接口。</p>
<p>其中，<code>$get</code> 属性是一个可供调用的函数，功能是即使模块元素混杂存储，也能被统一的接口成功调用。</p>
<p>对于 <code>value</code>，调用 API 的时候传入的是值，因此需要包装成返回这个值的函数才赋值给 <code>$get</code>。</p>
<p>对于 <code>constant</code>，值是不变的，所以可以看到就直接存储了。</p>
<p>对于 <code>decorator</code>，同样会定义 <code>$get</code> 属性。</p>
<p>对于 <code>service</code>，设计上应该生成一个单例并存储下来。不过在这里，仍然是继续包装起来。</p>
<p>源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function enforceReturnValue(name, factory) &#123;</span><br><span class="line">  return function enforcedReturnValue() &#123;</span><br><span class="line">    var result = instanceInjector.invoke(factory, this);</span><br><span class="line">    if (isUndefined(result)) &#123;</span><br><span class="line">      throw $injectorMinErr(&apos;undef&apos;, &quot;Provider &apos;&#123;0&#125;&apos; must return a value from $get factory method.&quot;, name);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function factory(name, factoryFn, enforce) &#123;</span><br><span class="line">  return provider(name, &#123;</span><br><span class="line">    $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function service(name, constructor) &#123;</span><br><span class="line">  return factory(name, [&apos;$injector&apos;, function($injector) &#123;</span><br><span class="line">    return $injector.instantiate(constructor);</span><br><span class="line">  &#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际干了如下的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function (name) &#123;</span><br><span class="line">  return provider(name, &#123;  // 跟其他 API 一样调用 provider 函数</span><br><span class="line">    $get: function () &#123;</span><br><span class="line">      return instanceInjector.invoke(</span><br><span class="line">          [&apos;$injector&apos;, function($injector) &#123;</span><br><span class="line">              return $injector.instantiate(constructor);  // 注意 constructor 是用户自定义的‘可注入结构’</span><br><span class="line">          &#125;]  // 这又是一个‘可注入结构’，注入的是 &apos;$injector&apos;，实际上就等于 instanceInjector</span><br><span class="line">          , this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)( &apos;serviceName&apos; )</span><br></pre></td></tr></table></figure>
<p>最后依然将包装好的函数存入 <code>$provider</code>。</p>
<p>只是为什么还是存储在 <code>$provider</code>，而不是直接调用函数进行初始化？比如 <code>service</code>，为什么还要再包装上一层‘可注入结构’？</p>
<p><a name="brief"></a></p>
<p>##小结<a href="#catalogue">↑</a></p>
<p>前文提到，使用延迟初始化实现了模块的依赖注入，使依赖的模块不需要提前定义。</p>
<p>实际上模块内的元素（factory / service 等）也是可以使用依赖注入的。使用过 AngularJS 的肯定知道定义某一个 controller 的时候可以注入某个 service，然而 controller 和 service 的定义顺序应该不能对代码运行造成影响。</p>
<p>因此，在此时，模块元素的“构造函数”（注意是用户自定义的那个函数而并非供<br> new 调用的那个函数）还并不具备运行的条件，因为还是需要等依赖的元素初始化。</p>
<p>于是某种意义上，模块元素就需要<strong>第二重注入</strong>。把‘可注入结构’缓存在 <code>$provider</code> 中实际上就是对应了前文叙述的‘把模块先全部缓存’，包装上一个函数再统一放在 <code>$get</code> 属性下明显是方便供下一阶段的调用。</p>
<p>万事俱备，只欠注入了。</p>
<blockquote>
<p>分析到现阶段，大家应该对平常使用频繁的 <code>service</code>、<code>factory</code> 等函数有了更深的认识了。</p>
</blockquote>
<p><a name="injector"></a></p>
<p>##注入器的奥秘<a href="#catalogue">↑</a><br>现在把精力放在 <code>createInternalInjector</code> 函数。</p>
<p>此函数在<a href="#analyze">开始分析</a>一节中已经提到了，作用只是返回一个对象。这个对象就是真正的注入器。</p>
<p>此函数被调用了两次，分别是得到 <code>providerInjector</code> 和 <code>instanceInjector</code>。</p>
<p>注入器中重要的函数有三个，分别是 <code>getService</code>、<code>invoke</code> 和 <code>instantiate</code>。</p>
<p>在<a href="#analyze">开始分析</a>中已经大致介绍了，<code>getService</code> 函数干一件事，返回 <code>cache</code> 中的对象，如果没有，就用 <code>factory</code> 创建一个再返回。</p>
<p>对于 <code>providerInjector</code>，<code>factory</code> 函数是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function(serviceName, caller) &#123;</span><br><span class="line">  if (angular.isString(caller)) &#123;</span><br><span class="line">    path.push(caller);</span><br><span class="line">  &#125;</span><br><span class="line">  throw $injectorMinErr(&apos;unpr&apos;, &quot;Unknown provider: &#123;0&#125;&quot;, path.join(&apos; &lt;- &apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难理解，因为在调用 provider 的时候，<code>providerCache</code> 中的函数应该已经在上一个初始化模块阶段中被定义好，如果没找到，那么肯定是调用了未定义的 provider。</p>
<p>对于 <code>instanceInjector</code>，<code>factory</code> 函数是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function(serviceName, caller) &#123;</span><br><span class="line">  var provider = providerInjector.get(serviceName + providerSuffix, caller);</span><br><span class="line">  return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>instanceCache</code> 本身就是空的，因此在找不到的时候，就去 <code>providerInjector</code> 里找 provider，然后得到其调用的结果，就是真正需要的实例（instance）了。<code>$get</code> 在这里就凸显出统一调用的用处了。</p>
<p><code>invoke</code> 函数则是处理<strong>‘可注入结构’</strong>和调用函数。从源码中也可以看到组装参数和调用函数，其中也会调用 <code>getService</code> 去得到实参的值来实现注入。从这里的 <code>getService</code> 出发，又有可能调用 <code>factory</code> 继而继续调用 <code>invoke</code> 来得到所依赖的实例，直到没有任何依赖需要实例化，从而完美的实现了自洽。</p>
<p><code>instantiate</code> 函数是用来处理 ‘service’ 的，是用来模拟 <code>new</code> 的，从代码来看也是如此：复制一个函数的 prototype，绑定为函数的 <code>this</code>，然后调用函数。因此调用 <code>service</code> API 的时候，可以完全使用构造函数的写法，同时也能得到注入特性。</p>
<p><a name="unexpected"></a></p>
<p>##读源码的意外发现<a href="#catalogue">↑</a><br>读源码一般都会有一定的收获，或是技巧上的，或是思想上的。</p>
<p>当读完了 Angular 的依赖注入的代码后，才发现 Angular 虽然表明支持模块化，但是实际上所谓的模块化只是徒有其名，模块的定义只是方便框架自己做延迟初始化的工作，没有模块之实。模块只是依赖树上的节点，最终生成出来的命名空间跟模块没有一丁点的关系，所有模块里的东西，不论是 ‘value’、’service’ 和 ‘provider’ 等，都是平铺在 <code>instanceCache</code> 里面的。这样的做法明显的一个结果就是命名冲突，两个不同模块里面的同名对象，后实例化的会覆盖掉先实例化的。这一点非常的不好，因为完全不符合模块化的预期结果。</p>
<p>在下一篇编（fu）写（zhi）注入功能的时候，我会修改这部分使其能满足模块化的实际预期。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2016/01/05/watch-sherlock-the-abominable-bride/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/01/05/watch-sherlock-the-abominable-bride/" class="post-title-link" itemprop="url">看《Sherlock: The Abominable Bride》</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-01-05 19:48:23 / Modified: 19:49:41" itemprop="dateCreated datePublished" datetime="2016-01-05T19:48:23+08:00">2016-01-05</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2016/01/05/watch-sherlock-the-abominable-bride/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/01/05/watch-sherlock-the-abominable-bride/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看完新出的夏洛克，想必大家都会很茫然。刚好今晚也看了，就说说我看了电影和影评后的总结吧。</p>
<p>PS:有剧透才能更好地看电影。</p>
<p>PS:如果你是想看好莱坞大片，还像和我同一片场的人那样带着爆米花和泡椒凤爪来看的，可以退票了。</p>
<p>简单来说，整部电影的剧情几乎都是在嗑了药的夏洛克进入多层梦境中发生的。他要解决上一季结尾中莫里亚蒂的“回归”的问题，于是在脑内——或者说是思维迷宫内——解决一百年前的另外一个“死而复活的新娘”的问题。而解决这个问题的方法，就是将自己带入到那个维多利亚时代中，思考自己会如何行动，剧情如何发展。这也就是为什么差不多通篇都是维多利亚时代风格的由来。案情重组，简而言之。不过，有一个问题，就是实际上根据设定，电影中福尔摩斯并不是十九世纪的人物，如此一来就对原来的案情进行了干涉，出现矛盾，这个后面再谈。</p>
<p>令来看福华CP的，卖腐的，相爱相杀的女性，啊不，观众大失所望，恐怕是悬疑色彩的浓重，剧情的多段跳跃和突然切换，以及似乎毫无卖腐的情节。然而我等从第一季就只对其具备推理性质和现代化改编产生强烈爱好的人却是大欢喜：这才是正剧的风格，第三季给某些群体派太多显而易见的糖了。</p>
<p>然而电影中的推理很好吗？电影没有派糖吗？非也。</p>
<p>先说推理。电影中的诡计归结成一句话就是：死了的新娘为何能复活并杀死其丈夫？答案是一开始就没死，是在姐妹们的帮助下演戏，之后再当街杀丈夫并给大众一种复活的假象再高明地自杀，不留下破绽，并且还继续利用这种牺牲换来了死而复生继而复活的恐怖现象来帮助姐妹完成对姐妹的丈夫的复仇。卧槽竟然吞枪自杀只是演戏？乍一看似乎有点敷衍，但是和朋友讨论后认为，如果考虑到十九世纪科技水平的低下和侦查手段的匮乏，加上法医的暗中帮助，实际上完全是可能发生的。所以说推理虽然并不出彩或者惊世骇俗，然而还是有意思的。只是编剧没有给解答过程一个酷炫的表现，所以观众就有不爽、硬了不射的憋屈。那为什么不表现得很光很亮很油还很duang呢？同样后面再谈。</p>
<p>再说派糖，电影中最明显的就是瀑布旁莫里亚蒂说的“你们不如私奔吧”的吧？原著可是福尔摩斯和教授一起掉下瀑布失踪的，电影里面华生来救福尔摩斯了啊。麦考夫在飞机里面对夏洛克嗑药的担心和毫不掩饰的be there for you你们无视了吗？午夜夏洛克和华生的深入交谈你们没触动吗？只能说糖派得有点晦涩了，伪粉抖一抖就掉了，真粉还是会粘着。</p>
<p>另外纵观整个案件，诡计的实施涉及到已经患绝症的新娘，女仆，为了证明自己和男性一样能胜任工作而不得不女扮男装的女法医（电影此处对man的翻译应该有问题）以及一众的女性秘密组织，换句话说，这其实标志着女性的反抗。电影中已有多处暗示：玛丽说她希望跟华生一样能做事，并且参加女性选举权的争取；麦考夫说有一个眼皮底下的enemy，undetected, and unstoppable，还说we will lose，because they are right we are wrong；玛丽从十九世纪的被晾在一边到二十世纪终于能和丈夫一起参与事情；华生家庭的情况；通通都是编剧支持女性争取权利的暗示。这也是跟随了近年电影频繁地使用女性作为主角，将女性塑造出不同形象的大流（我是从冰雪奇缘开始察觉近来电影有这样的趋势的）。这才是给女性派的最好的糖不是吗？</p>
<p>最后来说说电影对夏洛克这个人物的思考，顺便也把前面两个“后面再谈”解决了。原著中福尔摩斯基本上被塑造成理性思考和推理的机器，然而比较tricky的一点是根据设定，小说是道尔笔下的华生写的，小说中福尔摩斯的形象是道尔笔下的华生给大众塑造的，真实(?)的夏洛克到底是怎样的人无从得知。电影中也有反复地强调华生将夏洛克的案件写成文章发表。在午夜华生反复质问夏洛克关于感情和过去的问题，夏洛克没有说出来。这是编剧对夏洛克这个人物感情的探讨，没什么清晰的结论。之后没能保护受害人，夏洛克把自己关在房间里又磕药。然后莫里亚蒂就出现了在房间又吞枪了一次，没死，夏洛克觉得想不通怎么死不了的时候飞机着陆了把他震醒了。醒过来的二十一世纪是现实。一番交流后他又睡了，在梦里十九世纪醒来，开始了找玛丽和到在教堂里面解谜。最后指认凶手的时候他突然想到，凶手为什么要找他来破案呢？因为历史上新娘案就没被侦破，他作为侦探加入进案件了就产生了干涉，造成了奇怪的悖论。接着莫里亚蒂又出来了，场景就又切换到二十一世纪了，但是是更深一层梦里的二十一世纪，因为最后死尸活过来了，在现实里是不可能的。紧接着场景转到了著名的瀑布，这个估计就是夏洛克心里近乎最深层的地方了。可以看到，每当梦里有不寻常的事情发生，莫里亚蒂就会出来，试图让夏洛克偏离方向，只是第一次被飞机降落打断了。于是也就解释了为何解谜过程不酷炫，第一解谜发生在夏洛克脑内，显然不需要“炫”给自己看；第二，解谜会引出悖论从而引出教授，太酷炫会让观众大脑当机无法思考莫里亚蒂出现的原因。看到这你是不是忘记了这一段说的是夏洛克人物的探讨了？前面说了一大段剧情其实就是论证了在这个系列中，编剧认为莫里亚蒂就是夏洛克的心结和过去，或者说他脑中的魔鬼，会让夏洛克的思考出现问题。这是编剧对夏洛克过去的探讨。在原著中两人双双跌下瀑布，电影中是华生出来救场，并且表现得完全不像非梦境的华生。这“夏洛克被心魔莫里亚蒂殴打，华生赶来将教授一脚踹下”的场景表明夏洛克不再纠结莫里亚蒂“复活”了，而明白是他“回来”了。</p>
<p>于是正如新娘最终还是死了，莫里亚蒂大约的确已经死了。正如复仇是秘密组织干的，无责任猜测一下下一季的剧情大概就是教授的同伙来复仇了。</p>
<p>最后来看看编剧在电影里融合了什么呢？电视剧中的人物的重新运用，合格的推理，女性主义，对夏洛克的人物心理探讨，还有两季之间的承前启后。或许把这么多的东西融于一炉是有点用力过猛了，我刚看完的时候也是有点懵了，但是走回家的路上却越想越有意思。</p>
<p>我给这电影三个评价：</p>
<ul>
<li>女性主义的胜利</li>
<li>原著党的胜利</li>
<li>伪粉的处刑</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2015/12/25/single-bell-2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/12/25/single-bell-2015/" class="post-title-link" itemprop="url">クリスマス？なにそれ？美味しいの？</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2015-12-25 17:02:32" itemprop="dateCreated datePublished" datetime="2015-12-25T17:02:32+08:00">2015-12-25</time>
            

            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2015/12/25/single-bell-2015/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/single-bell-2015/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个妹子给我推荐了这个刷算法题换装的游戏。</p>
<p>然而随着一道又一道的题目的通过，悲伤感越来越重却是怎么回事。</p>
<p>在平安夜和圣诞节一个人对着电脑敲代码来给虚拟妹子解锁装扮也是够自虐的。<br><img src="https://ooo.0o0.ooo/2015/12/25/567d017589cbe.png" alt="tu"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2015/11/27/write-a-game-of-life-using-es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/11/27/write-a-game-of-life-using-es6/" class="post-title-link" itemprop="url">使用ES6编写一个生命游戏</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2015-11-27 00:38:57 / Modified: 12:31:33" itemprop="dateCreated datePublished" datetime="2015-11-27T00:38:57+08:00">2015-11-27</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2015/11/27/write-a-game-of-life-using-es6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/11/27/write-a-game-of-life-using-es6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://github.com/exoticknight/gol.js" target="_blank" rel="noopener">GitHub 地址</a></p>
</blockquote>
<p><img src="https://i.imgur.com/fLKUaVL.gif" alt="gif"></p>
<p>##缘起</p>
<p>前段时间看了《Understanding ECMAScript 6》，因为有 JavaScript 的基础，很快就上手了，还写了<a href="http://blog.e10t.net/understanding-ecmascript6-note/" target="_blank" rel="noopener">笔记</a>。然而编程只看书是不够的，还需要让身体熟悉起来。刚好最近在看「全部成为F」这部新番，看到 ED 采用了「生命游戏」的表现形式，于是便有了用 ES6 来写一个的主意。</p>
<p>##「生命游戏」</p>
<p>「生命游戏」的英文原文是「Game of Life」，是细胞自动机的一种形式，每个细胞的未来状态只取决于以其为中心周围八格细胞的当前状态。更详细的信息请看<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">wiki条目</a>，给出一个有意思的动画图。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="gif动画图"></p>
<p>而状态判断只有四条：</p>
<ol>
<li>当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少）</li>
<li>当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。</li>
<li>当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</li>
<li>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）</li>
</ol>
<p>###算法思考</p>
<p>假设有一个棋盘，每一个格子代表一个细胞。在每一次生成下一代细胞，先遍历每一个细胞，查询它周围八格细胞的状态，设置本细胞下一代的状态。</p>
<p>显然这样的算法基本毫无意义，因为显然棋盘是不定大小的，细胞也不是每一代都一定会变化的，遍历整个棋盘也是浪费时间的。</p>
<p>实际上，发生变化或者有可能发生变化的细胞，基本是聚集在活细胞周围的。如果一个死细胞附近没有活细胞，那么这个细胞就不会发生变化。所以，可以换个思路，每一个曾经活过或者在活细胞周围的细胞都维持一个它的邻居细胞的数目记录。每当一个细胞活过来了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录增加 1；相反每当一个细胞死了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录减少 1。显然在更新完之后，周围八格的细胞不论生死都清楚自己周围的活细胞数，也就是能够得到自己的未来状态了。同时，在通知周围八个邻居的时候，也可以统计出对于本细胞来说的活邻居数，于是本细胞的未来状态也能够得到了。</p>
<p>于是算法能描述如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1)在某一次生成本次状态中，有将改变状态的细胞集合 S</span><br><span class="line">2)遍历集合 S，对于细胞 i：</span><br><span class="line">    改变细胞 i 的状态</span><br><span class="line">    细胞 i 的活邻居数置零</span><br><span class="line">    遍历 8 个邻居细胞，对于邻居细胞 j：</span><br><span class="line">        如果细胞 i 改变后的状态 == 存活，细胞 j 的活邻居数增加 1</span><br><span class="line">        如果细胞 i 改变后的状态 == 死亡，细胞 j 的活邻居数减少 1</span><br><span class="line">        计算细胞 j 的未来状态并记录在将改变状态的细胞集合 S&apos; 中</span><br><span class="line">        如果细胞 j 是活细胞：</span><br><span class="line">            细胞 i 的活邻居数增加 1</span><br><span class="line">    计算细胞 i 的未来状态并记录在将改变状态的细胞集合 S&apos; 中</span><br><span class="line">3)S = S&apos;，重复 1)、2)</span><br></pre></td></tr></table></figure>
<p>##ES6 写起来</p>
<p>ES6 中有 class 的概念，虽然实现方式其实就是 function 和原型，但是在写的时候就不用像以前用「模拟」的手段来编写啦。</p>
<p>###基本对象</p>
<p>基本来说，分三个主要对象：提供算法的 class Life，提供单元格绘制的 class Grid，提供 DOM 动画控制的 class Game。Game 从算法中得到需要重绘的单元格，通过 Grid 来绘制单元格。</p>
<p>###class Life</p>
<p>已经有算法描述了，写起来并不复杂。新建一个 <code>life.js</code> 文件，导出 <code>Life</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default class Life &#123;</span><br><span class="line">  constructor ( row, col ) &#123;</span><br><span class="line">    this.row = row;</span><br><span class="line">    this.column = col;</span><br><span class="line"></span><br><span class="line">    this.generation = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * this.world = &#123;</span><br><span class="line">     *   &apos;0,0&apos;:  // &apos;x,y&apos;</span><br><span class="line">     *   [</span><br><span class="line">     *     1,  // alive 1, dead 0</span><br><span class="line">     *     0,  // count of neighbour</span><br><span class="line">     *   ]</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line">    this.world = &#123;&#125;;</span><br><span class="line">    /*</span><br><span class="line">     * &apos;0,0&apos;:  // &apos;x,y&apos;</span><br><span class="line">     * 1  // to be alive 1, to be dead -1, 0 not change</span><br><span class="line">     */</span><br><span class="line">    this.changedState = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数只需要得到世界（棋盘）的长宽就行了，<code>this.world</code> 记录世界中受关注细胞的状态，<code>this.changedState</code> 记录将要改变状态的细胞。</p>
<p>算法本体代码，相当于描述 2) 中循环中的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">_processLife ( x, y, state ) &#123;</span><br><span class="line">  let currentCellHash = x + &apos;,&apos; + y;</span><br><span class="line">  if ( this.world[currentCellHash] ) &#123;</span><br><span class="line">    // 根据 state 改变状态</span><br><span class="line">    this.world[currentCellHash][0] = state ? 1 : 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果世界中不存在记录，则肯定是新的活细胞</span><br><span class="line">    this.world[currentCellHash] = [1, 0];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新邻居细胞并统计活邻居数</span><br><span class="line">  let aliveNeighBours = 0;</span><br><span class="line">  let neighbours = [</span><br><span class="line">    // 左边的邻居</span><br><span class="line">    [x - 1, y - 1],</span><br><span class="line">    [x - 1, y],</span><br><span class="line">    [x - 1, y + 1],</span><br><span class="line">    // 上下邻居</span><br><span class="line">    [x, y - 1],</span><br><span class="line">    [x, y + 1],</span><br><span class="line">    // 右边的邻居</span><br><span class="line">    [x + 1, y - 1],</span><br><span class="line">    [x + 1, y],</span><br><span class="line">    [x + 1, y + 1],</span><br><span class="line">  ];</span><br><span class="line">  let counter = state ? +1 : -1;</span><br><span class="line"></span><br><span class="line">  // 循环 8 个邻居</span><br><span class="line">  for ( let i = 0; i &lt; 8; i++ ) &#123;</span><br><span class="line">    let [nx, ny] = neighbours[i];</span><br><span class="line"></span><br><span class="line">    // 一些世界中的约束</span><br><span class="line">    if ( 0 &lt;= nx &amp;&amp; nx &lt; this.column &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; this.row ) &#123;</span><br><span class="line">      let hash = nx + &apos;,&apos; + ny;</span><br><span class="line">      let oldState = this.world[hash];</span><br><span class="line"></span><br><span class="line">      // oldState[0] alive or dead, oldState[1] count of neighbour</span><br><span class="line">      if ( oldState ) &#123;  // 邻居已经存在于世界中了</span><br><span class="line">        oldState[1] += counter;  // 更新邻居的邻居数</span><br><span class="line"></span><br><span class="line">        // 顺便统计活邻居数</span><br><span class="line">        if ( oldState[0] ) &#123;</span><br><span class="line">          aliveNeighBours++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;  // 边缘开拓新的细胞，肯定是死细胞</span><br><span class="line">        oldState = this.world[hash] = [0, 1];</span><br><span class="line">      &#125;</span><br><span class="line">      // 计算邻居细胞的未来状态</span><br><span class="line">      switch ( oldState[1] ) &#123;</span><br><span class="line">        case 8:</span><br><span class="line">        case 7:</span><br><span class="line">        case 6:</span><br><span class="line">        case 5:</span><br><span class="line">        case 4:</span><br><span class="line">        case 1:</span><br><span class="line">        case 0:</span><br><span class="line">          this.changedState[hash] = -1;  // if alive, then to be dead</span><br><span class="line">          break;</span><br><span class="line">        case 3:</span><br><span class="line">          this.changedState[hash] = 1;  // if dead, then to be alive</span><br><span class="line">          break;</span><br><span class="line">        case 2:</span><br><span class="line">          this.changedState[hash] = 0;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 计算当前细胞的未来状态</span><br><span class="line">  this.world[currentCellHash][1] = aliveNeighBours;</span><br><span class="line">  switch ( aliveNeighBours ) &#123;</span><br><span class="line">    case 8:</span><br><span class="line">    case 7:</span><br><span class="line">    case 6:</span><br><span class="line">    case 5:</span><br><span class="line">    case 4:</span><br><span class="line">    case 1:</span><br><span class="line">    case 0:</span><br><span class="line">      this.changedState[currentCellHash] = -1;  // if alive, then to be dead</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      this.changedState[currentCellHash] = 1;  // if dead, then to be alive</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      this.changedState[currentCellHash] = 0;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2) 的循环其实就是得到下一代的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nextGeneration () &#123;</span><br><span class="line">  let state = Object.assign( &#123;&#125;, this.changedState );  // 复制将要改变的状态集以便清空</span><br><span class="line">  let changedCells = &#123; 0: [], 1:[] &#125;;</span><br><span class="line"></span><br><span class="line">  // reset next state</span><br><span class="line">  this.changedState = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 2) 的循环</span><br><span class="line">  for ( let key in state ) &#123;</span><br><span class="line">    let [x, y] = key.split( &apos;,&apos; ).map( x =&gt; parseInt( x ) );</span><br><span class="line"></span><br><span class="line">    if ( state[key] === 1 &amp;&amp; ( !this.world[key] || this.world[key][0] === 0 ) ) &#123;</span><br><span class="line">      this.aliveAt( x, y );  // 会调用 _processLife( x, y, true )</span><br><span class="line">      changedCells[1].push( [x, y] );  // 记录重绘的细胞</span><br><span class="line">    &#125; if ( state[key] === -1 &amp;&amp; this.world[key][0] === 1 ) &#123;</span><br><span class="line">      this.killAt( x, y );  // 会调用 _processLife( x, y, false )</span><br><span class="line">      changedCells[0].push( [x, y] );  // 记录重绘的细胞</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return changedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他函数可以在 GiiHub 查看。</p>
<p>###class Grid</p>
<p>确定使用 <code>HTML5</code> 中的 <code>Canvas</code> 元素来绘制整个世界（棋盘），<code>Canvas</code> 元素的操作使用另一个类 <code>C</code>，后面再写。</p>
<p>新建 <code>grid.js</code> 文件，导出 <code>Grid</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default class Grid &#123;</span><br><span class="line">  constructor ( canvas, row, col, displayScheme, colorScheme ) &#123;</span><br><span class="line">    this.view = canvas;</span><br><span class="line">    this.canvas = new C( canvas );</span><br><span class="line"></span><br><span class="line">    this.displayScheme = displayScheme;</span><br><span class="line">    this.colorScheme = colorScheme;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数要传入 canvas DOM 元素，棋盘的长宽，显示的选项和颜色选项。</p>
<p>绘制单元格的主要函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drawCells( redrawCells ) &#123;</span><br><span class="line">  // draw alive cells</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.aliveColor );</span><br><span class="line">  for ( let x, y, i = 0, len = redrawCells[1].length; i &lt; len; i++ ) &#123;</span><br><span class="line">    [x, y] = redrawCells[1][i];</span><br><span class="line">    this.drawCellAt( x, y );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // draw dead cells</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.deadColor );</span><br><span class="line">  for ( let x, y, i = 0, len = redrawCells[0].length; i &lt; len; i++ ) &#123;</span><br><span class="line">    [x, y] = redrawCells[0][i];</span><br><span class="line">    this.drawCellAt( x, y );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawCellAt ( x, y ) &#123;</span><br><span class="line">  this.canvas.drawRect(</span><br><span class="line">    x * ( this.displayScheme.borderWidth + this.displayScheme.cellWidth ),</span><br><span class="line">    y * ( this.displayScheme.borderWidth + this.displayScheme.cellWidth ),</span><br><span class="line">    this.displayScheme.cellWidth,</span><br><span class="line">    this.displayScheme.cellWidth );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawCells</code> 函数是用来批量画细胞的函数，同样颜色的细胞放在一起画，就不需要频繁改变画笔的颜色。</p>
<p><code>drawCellAt</code> 函数就是找到单元格的左上角距离 <code>Canvas</code> 元素左上角的距离，距离左边是第 x 个细胞宽度加细胞边框宽度，距离上边也是同样道理。</p>
<p>其中调用的 <code>setPenColor</code> 和 <code>drawRect</code> 还没有，于是就新增一个 <code>c.js</code> 文件，导出 <code>C</code> 类。其实就是 <code>Canvas</code> 元素的操作的封装而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default class C &#123;</span><br><span class="line">  constructor ( ele ) &#123;</span><br><span class="line">    this.cxt = ele.getContext( &apos;2d&apos; );</span><br><span class="line">    this.fillStyle = &apos;#000000&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPenColor ( hex ) &#123;</span><br><span class="line">    this.cxt.fillStyle = this.fillStyle = &apos;#&apos; + hex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  drawRect ( ox, oy, width, height ) &#123;</span><br><span class="line">    this.cxt.fillRect( ox, oy, width, height );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear () &#123;</span><br><span class="line">    this.cxt.clearRect( 0, 0, this.cxt.canvas.width, this.cxt.canvas.height );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###class Game</p>
<p>不复杂，直接看代码吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import Life from &apos;./life.js&apos;;</span><br><span class="line">import Grid from &apos;./grid.js&apos;;</span><br><span class="line"></span><br><span class="line">export default class Game &#123;</span><br><span class="line">  constructor ( canvas, row, col, displayScheme, colorScheme, gps ) &#123;</span><br><span class="line">    this.grid = new Grid( canvas, row, col, displayScheme, colorScheme );</span><br><span class="line">    this.life = new Life( row, col );</span><br><span class="line"></span><br><span class="line">    this.speed = 1000 / gps;</span><br><span class="line"></span><br><span class="line">    this.enable = false;</span><br><span class="line">    this.running = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init ( x ) &#123;</span><br><span class="line">    this.stop();</span><br><span class="line">    this.life.init( x );</span><br><span class="line">    this.grid.init();</span><br><span class="line">    this.enable = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop () &#123;</span><br><span class="line">    this.running = false;</span><br><span class="line">    this.enable = false;</span><br><span class="line">    this.life.reset();</span><br><span class="line">    this.grid.claer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pause () &#123;</span><br><span class="line">    if ( this.enable ) &#123;</span><br><span class="line">      this.running = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resume () &#123;</span><br><span class="line">    if ( this.enable ) &#123;</span><br><span class="line">      this.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step () &#123;</span><br><span class="line">    if ( this.enable ) &#123;</span><br><span class="line">      // run algorithm</span><br><span class="line">      let redrawCells = this.life.nextGeneration();</span><br><span class="line">      // redraw cells</span><br><span class="line">      this.grid.drawCells( redrawCells );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    if ( this.enable &amp;&amp; !this.running ) &#123;</span><br><span class="line">      this.running = true;</span><br><span class="line"></span><br><span class="line">      let _run = () =&gt; &#123;</span><br><span class="line">        if ( this.running ) &#123;</span><br><span class="line">          this.step();</span><br><span class="line">          setTimeout( _run, this.speed );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      setTimeout( _run, 0 );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一些简单的动画控制方法，跟普通 JavaScript 写起来没什么不同。需要注意的是 <code>enable</code> 状态和 <code>running</code> 状态是不一样的，前者是指整个游戏的响应，后者是指动画的响应。</p>
<p><code>step</code> 方法是迭代一步，<code>run</code> 方法就是用 <code>setTimeout</code> 来循环调用 <code>step</code> 了。在 <code>run</code> 方法中使用了箭头函数来隐含设定了 <code>this</code> 的值，ES6 的优势就体现出来了。</p>
<p>###gol.js</p>
<p>整个程序的主体是 Game 的实例，然而还是需要有人去创造一个实例出来，也就是说需要一个工厂函数。于是，新建 <code>gol.js</code> 文件，导出 <code>GOL</code> 类。里面写一个静态方法，用作创建 Game 实例的工厂方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Game from &apos;./game.js&apos;;</span><br><span class="line"></span><br><span class="line">export default class GOL &#123;</span><br><span class="line">  static createGame ( canvas, row, col, options ) &#123;</span><br><span class="line">    let param = Object.assign( &#123;</span><br><span class="line">      displayScheme: &#123;</span><br><span class="line">        borderWidth: 1,</span><br><span class="line">        cellWidth: 10</span><br><span class="line">      &#125;,</span><br><span class="line">      colorScheme: &#123;</span><br><span class="line">        aliveColor: &apos;000000&apos;,</span><br><span class="line">        deadColor: &apos;FFFFFF&apos;,</span><br><span class="line">        worldColor: &apos;FFFFFF&apos;,</span><br><span class="line">        borderColor: &apos;FFFFFF&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      gps: 15</span><br><span class="line">    &#125;, options );</span><br><span class="line"></span><br><span class="line">    return new Game( canvas, row, col, param.displayScheme, param.colorScheme, param.gps );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在 <code>createGame</code> 方法上就不要用 ES6 的语法了，因为方法是要在页面上调用的，目前还没有哪个浏览器完全支持 ES6。但是在方法里面用是没问题的，因为编译器会帮我们转换好。于是可以看到方法里面直接用 <code>Object.assign( des, src )</code> 的函数来合并参数，类似 jQuery 的 <code>extends</code> 函数。</p>
<p>###boot.js</p>
<p>到此还没完，回忆一下在写普通 JavaScript 库的时候，我们通常会直接包裹上一层适应各种环境的模块注册代码，本人最喜欢就是直接使用 <a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a> 了。</p>
<p>新建 <code>boot.js</code> 文件，执行非 ES6 形式的导出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import GOL from &apos;./gol.js&apos;;</span><br><span class="line"></span><br><span class="line">(function ( root, name, definition ) &#123;</span><br><span class="line">  if ( typeof define === &apos;function&apos; &amp;&amp; define.amd ) &#123;</span><br><span class="line">    define( [], function () &#123;</span><br><span class="line">        return ( root[name] = definition( root ) );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else if ( typeof module === &apos;object&apos; &amp;&amp; module.exports ) &#123;</span><br><span class="line">    module.exports = definition( root );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root[name] = definition( root );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)( window, &apos;GOL&apos;, function ( root ) &#123;</span><br><span class="line">  return GOL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>##代码打包</p>
<p>OK，到此代码基本写好了，然而到在浏览器上执行还是有一段距离，主要是基本没有浏览器默认支持 ES6，我们还是需要将 ES6 的代码编译一下以便能放到浏览器上运行。比较有名的编译器就是 <a href="https://github.com/babel/babel" target="_blank" rel="noopener">Babel</a> 和 Google 的 <a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a> 了。在编译的同时，还需要将所有文件打包成 bundle。</p>
<p>在进行了各种尝试之后（包括主流的 npm / browserify / jspm 等），最后发现使用 <code>webpack</code> 和 <code>Babel</code> 的结合是比较理想的。</p>
<p>###配置</p>
<p>先来把需要的东西都装上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev webpack babel babel-core babel-loader babel-preset-es2015</span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人其实非常讨厌安装到本地，明明都是可以全局安装的插件和工具。<br>而且每次开一个新的项目就要安装几十 MB 的重复东西实在无聊，npm 本身的树状依赖也是容易造成目录过深的情况。（据说新版 npm 有改善，但是不稳定）<br>个人的解决方法是固定一个开发目录，代码随便迁移。</p>
</blockquote>
<p>###webpack.config.js</p>
<p><code>webpack</code> 我就不详细解释了。直接上 <code>webpack.config.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/boot.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: &apos;./dist/bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                loader: &apos;babel&apos;,</span><br><span class="line">                query: &#123;</span><br><span class="line">                    cacheDirectory: true,</span><br><span class="line">                    presets: [&apos;es2015&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目前来说，这样写就能让 <code>Babel</code> 编译 ES6 的代码的同时，也运用 <code>webpack</code> 自己的打包功能<strong>根据 ES6 的模块语法</strong>将文件都打包成一个 bundle。</p>
<p>打包出来的代码有点大，压缩一下，再写一个 <code>webpack.config.min.js</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.min.js</span><br><span class="line">var webpack = require(&quot;webpack&quot;);</span><br><span class="line">module.exports = exports = Object.create(require(&quot;./webpack.config.js&quot;));</span><br><span class="line">exports.plugins = [new webpack.optimize.UglifyJsPlugin()];</span><br><span class="line">exports.output = Object.create(exports.output);</span><br><span class="line">exports.output.filename = exports.output.filename.replace(/\.js$/, &quot;.min.js&quot;);</span><br></pre></td></tr></table></figure>
<p>就能用 <code>webpack</code> 自带的压缩插件压缩代码了。</p>
<p>##添加功能</p>
<p>算法、绘图和动画控制都写好了，但是还不够，缺少了交互，还应该允许方便的自定义世界中的活细胞。比较好的交互方式就是允许通过在世界（棋盘）点击来放置活细胞或者死细胞。</p>
<p>于是考虑监听 <code>Canvas</code> 元素的 <code>mousedown</code>、<code>mousemove</code> 和 <code>mouseup</code> 事件，做出类似画图那样的效果（每个细胞可以看成是一个像素点）。</p>
<p>###grid.js</p>
<p>先改造负责绘制的模块。</p>
<p>在 <code>Grid</code> 类中新增 <code>drawAliveCellAt</code>、<code>drawDeadCellAt</code> 函数，负责独立绘制细胞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drawAliveCellAt( x, y ) &#123;</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.aliveColor );</span><br><span class="line">  this.drawCellAt( x, y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawDeadCellAt( x, y ) &#123;</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.deadColor );</span><br><span class="line">  this.drawCellAt( x, y );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增 <code>on</code>、<code>off</code> 函数，负责绑定监听方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">on ( event, handler ) &#123;</span><br><span class="line">  this.view.addEventListener( event, handler, false );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off ( event, handler ) &#123;</span><br><span class="line">  this.view.removeEventListener( event, handler );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增 <code>getXFromPixel</code>、<code>getYFromPixel</code> 函数，负责将像素点转换为单元格位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getXFromPixel ( pixel ) &#123;</span><br><span class="line">  let d = this.displayScheme.borderWidth + this.displayScheme.cellWidth;</span><br><span class="line">  let x = ~~( ( pixel - this.canvas.left ) / d );</span><br><span class="line">  return x % d &lt;= this.displayScheme.cellWidth ? x : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getYFromPixel ( pixel ) &#123;</span><br><span class="line">  let d = this.displayScheme.borderWidth + this.displayScheme.cellWidth;</span><br><span class="line">  let y = ~~( ( pixel - this.canvas.top ) / d );</span><br><span class="line">  return y % d &lt;= this.displayScheme.cellWidth ? y : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>~~</code> 是快速取整数。<code>this.canvas.left</code> 和 <code>this.canvas.top</code> 来自于类 <code>C</code> 的实例，因为鼠标点击事件取得的坐标点并非一定是相对于 <code>Canvas</code> 元素的左上角，还要减去 <code>Canvas</code> 元素的边框等。在 <code>c.js</code> 中将构造函数修改一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor ( ele ) &#123;</span><br><span class="line">  this.cxt = ele.getContext( &apos;2d&apos; );</span><br><span class="line">  this.fillStyle = &apos;#000000&apos;;</span><br><span class="line">  this.left = ele.getBoundingClientRect().left;</span><br><span class="line">  this.top = ele.getBoundingClientRect().top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###game.js</p>
<p>类 <code>Game</code> 的修改有点复杂。先在类的构造函数中增加一个属性，负责记录鼠标状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this._mouseState = &#123;</span><br><span class="line">  press: false,</span><br><span class="line">  lastX: -1,</span><br><span class="line">  lastY: -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再增加三个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_onMouseDown ( e ) &#123;</span><br><span class="line">  this._mouseState.press = true;</span><br><span class="line">  this._toggleCell( e.clientX, e.clientY );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_onMouseMove ( e ) &#123;</span><br><span class="line">  if ( this._mouseState.press ) &#123;</span><br><span class="line">    this._toggleCell( e.clientX, e.clientY );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_onMouseUp ( e ) &#123;</span><br><span class="line">  this._mouseState.press = false;</span><br><span class="line">  this._mouseState.lastX = this._mouseState.lastY = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标按下，就在鼠标按下的位置改变细胞的状态，并记录鼠标状态为按下。接着如果鼠标弹起，那么就重置鼠标状态；如果鼠标移动并且状态是按下，那么就一直改变路过的细胞的状态。</p>
<p><code>_toggleCell</code> 方法这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_toggleCell ( px, py ) &#123;</span><br><span class="line">  let x = this.grid.getXFromPixel( px );</span><br><span class="line">  let y = this.grid.getYFromPixel( py );</span><br><span class="line"></span><br><span class="line">  if ( x !== -1 &amp;&amp; y !== -1  &amp;&amp; ( this._mouseState.lastX !== x || this._mouseState.lastY !== y ) ) &#123;</span><br><span class="line">    this._mouseState.lastX = x;</span><br><span class="line">    this._mouseState.lastY = y;</span><br><span class="line">    if ( this.life.isAlive( x, y ) ) &#123;</span><br><span class="line">      this.life.killAt( x, y );</span><br><span class="line">      this.grid.drawDeadCellAt( x, y );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.life.aliveAt( x, y );</span><br><span class="line">      this.grid.drawAliveCellAt( x, y );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概意思就是先将鼠标的位置转化为单元格位置，再反置此单元格细胞的状态。记录下 <code>lastX</code> 和 <code>lastY</code> 是为了不会循环反置，一定要有坐标变化才反置。</p>
<p>接下来就是将那三个函数绑定在事件上。新增 <code>_setupLinsteners</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_setupLinsteners () &#123;</span><br><span class="line">  this.grid.on( &apos;mousedown&apos;, e =&gt; this._onMouseDown( e );</span><br><span class="line">  this.grid.on( &apos;mousemove&apos;, e =&gt; this._onMouseMove( e );</span><br><span class="line">  this.grid.on( &apos;mouseup&apos;, e =&gt; this._onMouseUp( e );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然使用了箭头函数优雅地绑定了 <code>this</code> 的值，但是这样写并不好，因为没办法解绑了，容易造成内存泄漏。改一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_setupLinsteners () &#123;</span><br><span class="line">  this._boundMethod[&apos;_onMouseDown&apos;] = e =&gt; this._onMouseDown( e );</span><br><span class="line">  this._boundMethod[&apos;_onMouseMove&apos;] = e =&gt; this._onMouseMove( e );</span><br><span class="line">  this._boundMethod[&apos;_onMouseUp&apos;] = e =&gt; this._onMouseUp( e );</span><br><span class="line"></span><br><span class="line">  this.grid.on( &apos;mousedown&apos;, this._boundMethod[&apos;_onMouseDown&apos;] );</span><br><span class="line">  this.grid.on( &apos;mousemove&apos;, this._boundMethod[&apos;_onMouseMove&apos;] );</span><br><span class="line">  this.grid.on( &apos;mouseup&apos;, this._boundMethod[&apos;_onMouseUp&apos;] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_teardownLinsteners () &#123;</span><br><span class="line">  this.grid.off( &apos;mousedown&apos;, this._boundMethod[&apos;_onMouseDown&apos;] );</span><br><span class="line">  this.grid.off( &apos;mousemove&apos;, this._boundMethod[&apos;_onMouseMove&apos;] );</span><br><span class="line">  this.grid.off( &apos;mouseup&apos;, this._boundMethod[&apos;_onMouseUp&apos;] );</span><br><span class="line"></span><br><span class="line">  this._boundMethod = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将匿名函数的引用保存起来就能解绑了。</p>
<p>最后给个 demo 吧。或者玩玩<a href="https://exoticknight.github.io/gol.js/" target="_blank" rel="noopener">在线 demo</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Game of Life&lt;/title&gt;</span><br><span class="line">  &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas id=&quot;grid&quot; width=&quot;1000&quot; height=&quot;500&quot; style=&quot;border:1px solid&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;button onclick=&quot;test()&quot;&gt;init&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.step()&quot;&gt;setp&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.run()&quot;&gt;run&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.stop()&quot;&gt;stop&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.pause()&quot;&gt;pause&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.resume()&quot;&gt;resume&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">var options = &#123;</span><br><span class="line">  displayScheme: &#123;</span><br><span class="line">    borderWidth: 1,</span><br><span class="line">    cellWidth: 4</span><br><span class="line">  &#125;,</span><br><span class="line">  colorScheme: &#123;</span><br><span class="line">    aliveColor: &apos;000000&apos;,</span><br><span class="line">    deadColor: &apos;efefef&apos;,</span><br><span class="line">    worldColor: &apos;ffffff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var g=GOL.createGame(document.getElementById(&apos;grid&apos;), 100, 200, options);</span><br><span class="line">function test()&#123;</span><br><span class="line">  g.init([[10,10],[11,10],[10,11],[13,12],[12,13],[13,13]]);</span><br><span class="line">  g.step();</span><br><span class="line">&#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2015/10/21/understanding-ecmascript6-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/10/21/understanding-ecmascript6-note/" class="post-title-link" itemprop="url">《Understanding ECMAScript 6》笔记</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2015-10-21 22:17:05" itemprop="dateCreated datePublished" datetime="2015-10-21T22:17:05+08:00">2015-10-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2015-11-06 14:44:52" itemprop="dateModified" datetime="2015-11-06T14:44:52+08:00">2015-11-06</time>
              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2015/10/21/understanding-ecmascript6-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/21/understanding-ecmascript6-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在线免费阅读：<a href="https://leanpub.com/understandinges6/read/" target="_blank" rel="noopener">https://leanpub.com/understandinges6/read/</a></p>
</blockquote>
<blockquote>
<p>部分代码使用原书，代码版权归原书所有</p>
</blockquote>
<p><a name="catalogue"></a></p>
<ol>
<li><a href="#block-bindings">块级绑定（Block Bindings）</a></li>
<li><a href="#string">字符串</a></li>
<li><a href="#regex">正则</a></li>
<li><a href="#template-strings">字符串模板（template strings）</a></li>
<li><a href="#tagged-templates">标签模板（tagged templates）</a></li>
<li><a href="#function">函数</a></li>
<li><a href="#object">对象</a></li>
<li><a href="#destructuring">解构（Destructuring）</a></li>
<li><a href="#symbols">Symbols</a></li>
<li><a href="#generators">生成器（Generators）</a></li>
<li><a href="#iterators">迭代器（Iterators）</a></li>
<li><a href="#class">类</a></li>
<li><a href="#promises">Promises</a></li>
<li><a href="#modules">模块（Modules）</a></li>
<li><a href="#miscellaneous">杂七杂八</a></li>
</ol>
<p><a name="block-bindings"></a></p>
<p>##块级绑定（Block Bindings）<a href="#catalogue">↑</a></p>
<p>###let</p>
<p>块级{}中有效</p>
<p>同块级不可重复声明</p>
<p>没有变量提升</p>
<blockquote>
<p>块级会形成暂时性死区（TDZ，Temporal Dead Zone）</p>
</blockquote>
<p>###const</p>
<p>基本和 <code>let</code> 相同，值不可修改</p>
<blockquote>
<p><code>let</code> 和 <code>const</code> 最好不要在全局下使用</p>
</blockquote>
<p><a name="string"></a></p>
<p>##字符串<a href="#catalogue">↑</a></p>
<p>###unicode 支持更好</p>
<p>###新增部分函数，支持双字节</p>
<p><code>codePointAt</code>，双字节版的 <code>charCodeAt</code>，得到字符 unicode</p>
<p><code>fromCodePoint</code>，双字节版的 <code>fromCharCode</code>，从 unicode 得出字符</p>
<p><code>includes</code>，包含某字符串</p>
<p><code>startsWith</code>，以某字符串开始</p>
<p><code>endsWith</code>，以某字符串结束</p>
<p><code>repeat</code>，重复字符串</p>
<p><code>normalize</code>，unicode 正规化，举个例子：两个 unicode 字符合成一个</p>
<p><a name="regex"></a></p>
<p>##正则<a href="#catalogue">↑</a></p>
<p>###新增标志 <code>u</code></p>
<p>正则识别 unicode 字符</p>
<p>###新增标志 <code>y</code></p>
<p>sticky，部分浏览器早就实现了</p>
<p><a name="template-strings"></a></p>
<p>##字符串模板（template strings）<a href="#catalogue">↑</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line">let s = `$&#123;a&#125; $&#123;a + b&#125;`  // &apos;1 3&apos;</span><br></pre></td></tr></table></figure>
<p><a name="tagged-templates"></a></p>
<p>##标签模板（tagged templates）<a href="#catalogue">↑</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">function tag ( strings, ...values ) &#123;</span><br><span class="line">  console.log( strings )</span><br><span class="line">  console.log( values )</span><br><span class="line">  return values[0]</span><br><span class="line">&#125;</span><br><span class="line">let s = tag`a $&#123;a&#125;`  // &apos;a 1&apos;</span><br><span class="line">// [&quot;a &quot;, &quot;&quot;, raw: Array[2]]</span><br><span class="line">// [1]</span><br></pre></td></tr></table></figure>
<p><a name="function"></a></p>
<p>##函数<a href="#catalogue">↑</a></p>
<p>###默认参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo ( bar = 1 ) &#123;</span><br><span class="line">  console.log( bar )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###剩余参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo ( bar, ...rest ) &#123;  // ✓</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo ( bar, ...rest, last ) &#123;  // ×</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###函数属性 name</p>
<p>各种例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">console.log( doSomething.name );          // &quot;doSomething&quot;</span><br><span class="line"></span><br><span class="line">var doAnotherThing = function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line">console.log( doAnotherThing.name );       // &quot;doAnotherThing&quot;</span><br><span class="line"></span><br><span class="line">var doSomethingAgain = function doSomethingElse () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line">console.log( doSomethingAgain.name );      // &quot;doSomethingElse&quot;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    get firstName () &#123;</span><br><span class="line">        return &quot;Nicholas&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        console.log( this.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log( person.sayName.name );   // &quot;sayName&quot;</span><br><span class="line">console.log( person.firstName.name ); // &quot;get firstName&quot;</span><br><span class="line"></span><br><span class="line">console.log( doSomething.bind().name );   // &quot;bound doSomething&quot;</span><br><span class="line"></span><br><span class="line">console.log( ( new Function() ).name );     // &quot;anonymous&quot;</span><br></pre></td></tr></table></figure>
<p>###new.target</p>
<p>避免了很多使用 <code>new</code> 的坑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Foo () &#123;</span><br><span class="line">  if ( typeof new.target !== &quot;undefined&quot; ) &#123;</span><br><span class="line">    console.log( &apos;good&apos; );  // using new</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error( &apos;You must use new with Person.&apos; )  // not using new</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = new Foo();  // good</span><br><span class="line">foo = Foo.call( foo );  // error!</span><br></pre></td></tr></table></figure>
<p>###块级函数</p>
<p>块级中可定义函数</p>
<p>###箭头函数</p>
<p><code>this</code>, <code>super</code>, <code>arguments</code> 和 <code>new.target</code> 的值都在定义函数时绑定而非运行时绑定</p>
<p>不可 <code>new</code></p>
<p>不可改变 <code>this</code> 的值</p>
<p>没有 <code>arguments</code></p>
<blockquote>
<p>跟普通函数一样拥有 name 属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo = value =&gt; value;  // input value, output value</span><br><span class="line">var foo = () =&gt; &#123;&#125;;</span><br><span class="line">var foo = ( x, y ) =&gt; x + y;</span><br><span class="line">var foo = id =&gt; (&#123; x: &apos;x&apos; &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// this 的绑定</span><br><span class="line">var foo = &#123;</span><br><span class="line">  init: function () &#123;</span><br><span class="line">    document.addEventListener( &apos;click&apos;, (function ( e ) &#123;</span><br><span class="line">      console.log( e.type );</span><br><span class="line">    &#125;).bind( this ), false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ------------------------</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  init: function () &#123;</span><br><span class="line">    document.addEventListener( &apos;click&apos;, e =&gt; &#123;console.log( e.type )&#125;, false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###立即调用函数表达式（Immediately-Invoked Function Expressions (IIFEs)）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let foo = function ( s ) &#123;</span><br><span class="line">  console.log( s );</span><br><span class="line">&#125;( &apos;text&apos; )  // text</span><br><span class="line"></span><br><span class="line">// -------------------------</span><br><span class="line"></span><br><span class="line">let foo = ( s =&gt; &#123;</span><br><span class="line">  console.log( s );</span><br><span class="line">&#125;)( &apos;text&apos; )  // text</span><br></pre></td></tr></table></figure>
<p>###新增尾递归优化</p>
<p><a name="object"></a></p>
<p>##对象<a href="#catalogue">↑</a></p>
<p>###对象字面属性值简写（Property Initializer Shorthand）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo ( text ) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name  // name: name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###对象方法简写（Method Initializer Shorthand）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###计算属性名语法</p>
<p>对象的属性可以使用中括号 <code>[]</code> 表示需要「被计算」，结果转换为字符串作为属性名使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = function () &#123;&#125;</span><br><span class="line">let foo = &#123;</span><br><span class="line">  a: &apos;text a&apos;,</span><br><span class="line">  [a]: &apos;function a&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log( foo[&apos;a&apos;] )  // text a</span><br><span class="line">console.log( foo[a] )  // function a</span><br></pre></td></tr></table></figure>
<p>###Object.is()</p>
<p>和经典的 <code>===</code> 几乎一样，区别在于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log( +0 === -0);             // true</span><br><span class="line">console.log( Object.is( +0, -0 ) );     // false</span><br><span class="line"></span><br><span class="line">console.log( NaN === NaN );           // false</span><br><span class="line">console.log( Object.is( NaN, NaN ) );   // true</span><br></pre></td></tr></table></figure>
<p>###Object.assign()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign( target, ...source )</span><br></pre></td></tr></table></figure>
<p>读取源对象可列举的、自身的属性，将其赋值到目标对象上，覆盖旧属性，并非通常意义的复制。</p>
<p>###复制存取器属性</p>
<blockquote>
<p>此小节查询 MDN 后补充上</p>
</blockquote>
<p>使用 <code>Object.getOwnPropertyDescriptor(source, key)</code> 读取，使用 <code>Object.defineProperties</code> 定义。</p>
<p>###属性允许重复定义</p>
<p>属性以最后一个定义的值为准</p>
<p>###修改原型</p>
<p><code>Object.getPrototypeOf</code>，得到原型</p>
<p><code>Object.setPrototypeOf</code>，设置原型</p>
<p>###super</p>
<p>用以访问对象的 prototype</p>
<p><a name="destructuring"></a></p>
<p>##解构（Destructuring）<a href="#catalogue">↑</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var &#123;a, b: &#123; c, d &#125;&#125; = c</span><br><span class="line">( &#123;a, b: &#123; c, d &#125;&#125; = c )</span><br><span class="line"></span><br><span class="line">var [a, [b, c]] = d</span><br><span class="line">var [a, , [b, c]] = d  // 跳过一个</span><br><span class="line"></span><br><span class="line">function foo ( &#123; bar1, bar2 &#125; = &#123;&#125; ) &#123;</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解构可以有默认值，但只会在需要的时候求值。</p>
<p><a href="http://www.2ality.com/2015/01/es6-destructuring.html" target="_blank" rel="noopener">2ality</a> 有更详细清晰的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let &#123;prop: y=someFunc()&#125; = someValue;</span><br><span class="line"></span><br><span class="line">let x, y;</span><br><span class="line">[x=3, y=x] = [];     // x=3; y=3</span><br><span class="line">[x=3, y=x] = [7];    // x=7; y=7</span><br><span class="line">[x=3, y=x] = [7, 2]; // x=7; y=2</span><br></pre></td></tr></table></figure>
<p><a name="symbols"></a></p>
<p>##Symbols（不知道如何翻译，是第七种原始类型）<a href="#catalogue">↑</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo = Symbol()</span><br><span class="line">var foo = Symbol( &apos;bar&apos; )</span><br></pre></td></tr></table></figure>
<p><code>Symbol( &#39;description&#39; )</code> 生成局部 Symbol，即使 <code>description</code> 相同生成的 Symbol 也不一样</p>
<p><code>Symbol.for( &#39;description&#39; )</code> 生成全局 Symbol，<code>description</code> 相同则 Symbol 相同</p>
<p>###获取对象的 Symbol 数组</p>
<p><code>Object.getOwnPropertySymbols( object )</code></p>
<p>###强制转换 Symbol 为 String</p>
<blockquote>
<p>原书本节未完成</p>
</blockquote>
<p>###有名的预定义 Symbol</p>
<blockquote>
<p>原书本节大部分未完成</p>
</blockquote>
<p><a name="generators"></a></p>
<p>##生成器（Generators）<a href="#catalogue">↑</a></p>
<p>生成迭代器的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function *createIterator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  *createIterator ( items ) &#123;</span><br><span class="line">    for ( let i=0; i &lt; items.length; i++ ) &#123;</span><br><span class="line">      yield items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let iterator = o.createIterator( [1, 2, 3] );</span><br></pre></td></tr></table></figure>
<p><a name="iterators"></a></p>
<p>##迭代器（Iterators）<a href="#catalogue">↑</a></p>
<p>###for-of 语法</p>
<p>数组、字符串、映射（Map）、集合（Set）和元素数组（NodeList）都可迭代（iterable），可使用 for-of 语法</p>
<p>###得到内置迭代器</p>
<p>Symbol.iterator 指向得到迭代器的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let values = [1, 2, 3];</span><br><span class="line">let iterator = values[Symbol.iterator]();</span><br><span class="line">iterator.next();  // 1</span><br></pre></td></tr></table></figure>
<p>###自定义迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let collection = &#123;</span><br><span class="line">  items: [],</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    yield *this.items.values();  // `yield *` 语法，委托了数组 `items` 的内置迭代器</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###对象、数组、映射、集合都具有的默认迭代器</p>
<p><code>ertries()</code>，返回键值对迭代器</p>
<p><code>keys()</code>，返回键迭代器</p>
<p><code>values()</code>，返回值迭代器</p>
<p>###字符串迭代器</p>
<p>通过 <code>[]</code> 的访问是 code unit 方式</p>
<p>通过迭代器则是字符方式（几乎是，某些 unicode 支持不足）</p>
<p>###元素数组（NodeList）迭代器</p>
<p>返回的是数组中的单个元素</p>
<p>###向迭代器传参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function *foo () &#123;</span><br><span class="line">  let bar = yield 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let it = foo()</span><br><span class="line">console.log( it.next() )  // Object &#123;value: 1, done: false&#125;，执行语句 `yield 1` 然后暂停</span><br><span class="line">console.log( it.next( 2 ) )  // Object &#123;value: undefined, done: true&#125;，将 2 作为 `yield 1` 的返回值，</span><br><span class="line">                             // 迭代器内部继续执行语句 `let bar = 2`，</span><br><span class="line">                             // 之后执行完毕，无返回值，`value` 为 `undefined`，`done` 为 `true`</span><br><span class="line">console.log( it.next() )  // Object &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>###生成器使用 return 提前返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function *createIterator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  return 42;</span><br><span class="line">  yield 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iterator = createIterator();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 42, done: true &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></pre></td></tr></table></figure>
<p>###委托生成器</p>
<p>使用 <code>yield *</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function *createNumberIterator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *createRepeatingIterator(count) &#123;</span><br><span class="line">  for (let i=0; i &lt; count; i++) &#123;</span><br><span class="line">    yield &quot;repeat&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *createCombinedIterator() &#123;</span><br><span class="line">  let result = yield *createNumberIterator();</span><br><span class="line">  yield *createRepeatingIterator(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var iterator = createCombinedIterator();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 2, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: &quot;repeat&quot;, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: &quot;repeat&quot;, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: &quot;repeat&quot;, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></pre></td></tr></table></figure>
<p>可以 <code>yield *&quot;string&quot;</code>，会调用字符串的默认迭代器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function *foo () &#123;</span><br><span class="line">  yield * &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">let it = foo()</span><br><span class="line">console.log( it.next() )  // Object &#123;value: &quot;h&quot;, done: false&#125;</span><br><span class="line">console.log( it.next() )  // Object &#123;value: &quot;e&quot;, done: false&#125;</span><br></pre></td></tr></table></figure>
<p>###异步任务调度</p>
<p>以下是书中的例子，写得并不好，变量 <code>task</code> 的管理容易出问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">var task;</span><br><span class="line"></span><br><span class="line">function readConfigFile() &#123;</span><br><span class="line">    fs.readFile(&quot;config.json&quot;, function(err, contents) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            task.throw(err);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            task.next(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *init() &#123;</span><br><span class="line">    var contents = yield readConfigFile();</span><br><span class="line">    doSomethingWith(contents);</span><br><span class="line">    console.log(&quot;Done&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task = init();</span><br><span class="line">task.next();</span><br></pre></td></tr></table></figure>
<p><a name="class"></a></p>
<p>##类<a href="#catalogue">↑</a></p>
<p>###类声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line">  // 相当于构造函数</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  // 相当于 foo.prototype.bar</span><br><span class="line">  bar () &#123;</span><br><span class="line">    console.log( this.name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类的属性最好都在构造函数里面创建。</p>
<p>类声明本质上就是以前的函数声明，除了以下有所不同：</p>
<ol>
<li>类声明不会像函数声明那样被提升</li>
<li>类内部的代码全部以 <code>strict mode</code> 运行</li>
<li>所有方法都是不可列举的，相当于使用了 <code>Object.defineProperty()</code></li>
<li>不使用 <code>new</code> 会抛异常</li>
<li>以类名命名方法来覆盖类名会抛异常（类名对于类内部来说是以 <code>const</code> 定义的，对于外部则不是）</li>
</ol>
<p>###类表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let foo = class &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let foo = class foo2 &#123;&#125;  // foo === foo2</span><br></pre></td></tr></table></figure>
<p>匿名类作为参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFoo ( c ) &#123;</span><br><span class="line">  return new c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createFoo( class &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>立即调用类表达式（有点像立即调用函数表达式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let foo = new class &#123;</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;( &apos;foo&apos; )</span><br></pre></td></tr></table></figure>
<p>###存取器属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get className () &#123;</span><br><span class="line">    return &apos;class &apos; + this.name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set className ( value ) &#123;</span><br><span class="line">    this.name = &apos;class&apos; + value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###静态成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 相当于 foo.prototype.bar</span><br><span class="line">  bar () &#123;</span><br><span class="line">    console.log( this.name )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 相当于 foo.staticBar</span><br><span class="line">  static staticBar () &#123;</span><br><span class="line">    console.log( this.name )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // get / set 也可以用</span><br><span class="line">  static get barName () &#123;</span><br><span class="line">    return &apos;bar&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态成员同样不可列举</p>
</blockquote>
<p>###派生类</p>
<p>比起 ECMAScript5，ECMAScript6 的派生方便了很多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">  constructor ( length, width ) &#123;</span><br><span class="line">    this.length = length;</span><br><span class="line">    this.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    return this.length * this.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  constructor ( length ) &#123;</span><br><span class="line">    super( length, length );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在派生类的构造函数中，调用 <code>super</code> 是必须的。如果连构造函数都没有，则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  // 无构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  constructor ( ...args ) &#123;</span><br><span class="line">    super( ...args )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>只能在派生类中用 <code>super()</code></li>
<li>使用 <code>this</code> 前必先调用 <code>super()</code> 来<strong>初始化</strong> <code>this</code></li>
<li>只有在构造函数返回一个对象的时候才可以不用 <code>super()</code></li>
</ol>
</blockquote>
<p>###类方法</p>
<p>覆盖、隐藏父类方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  constructor ( length ) &#123;</span><br><span class="line">    super( length, length );</span><br><span class="line">  &#125;</span><br><span class="line">  getArea () &#123;</span><br><span class="line">    return this.length * this.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然可以使用 <code>super</code> 调用父类方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">    constructor ( length ) &#123;</span><br><span class="line">        super( length, length );</span><br><span class="line">    &#125;</span><br><span class="line">    getArea () &#123;</span><br><span class="line">        return super.getArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类方法没有 <code>[[Construct]]</code> 这个内部方法，所以不能被 <code>new</code>。（[什么是<code>[[Construct]]</code>](<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2)）" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2)）</a></p>
<p>###静态成员</p>
<p>相当于 ES5 中定义在构造函数上的方法（注意不是定义在构造函数的原型上），派生类显然也能调用</p>
<p>###extends 关键字后面可以使用表达式</p>
<p>除了 <code>null</code> 和生成器函数外</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 使用函数</span><br><span class="line">function base () &#123;&#125;</span><br><span class="line">class foo extends base &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 使用表达式</span><br><span class="line">function base () &#123;&#125;</span><br><span class="line">function getBase () &#123;</span><br><span class="line">  return base</span><br><span class="line">&#125;</span><br><span class="line">class foo extends getBase() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 混合模式（多继承？!）</span><br><span class="line">let AMinin = &#123;</span><br><span class="line">  aF = function () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let BMinin = &#123;</span><br><span class="line">  bF = function () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">function mixin ( ...mixins ) &#123;</span><br><span class="line">  var base = function () &#123;&#125;</span><br><span class="line">  Object.assign( base.prototype, ...mixins )</span><br><span class="line">  return base</span><br><span class="line">&#125;</span><br><span class="line">class foo extends mixin( AMinin, BMinin ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 内置类型</span><br><span class="line">class foo extends Array &#123;&#125;</span><br><span class="line">class foo extends String &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>###new.target</p>
<p>能够得知类的调用状态，应用例如：阻止抽象类被实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    if (new.target === Shape) &#123;</span><br><span class="line">      throw new Error(&quot;This class cannot be instantiated directly.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="promises"></a></p>
<p>##Promises<a href="#catalogue">↑</a></p>
<p>Promise 是老朋友了，所以没有什么好记录的，就记一下语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise( function ( resolve, reject ) &#123;</span><br><span class="line">    resolve( 42 );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let p2 = Promise.resolve( 42 );</span><br><span class="line"></span><br><span class="line">let p3 = Promise.reject( 43 );</span><br><span class="line"></span><br><span class="line">let p4 = Promise.all( [p1, p2, p3] );  // 等待所有 Promise 返回</span><br><span class="line"></span><br><span class="line">let p5 = Promise.race( [p1, p2, p3] );  // 最快的一个 Promise 返回就返回</span><br><span class="line"></span><br><span class="line">p4.then( function ( value ) &#123;</span><br><span class="line">    console.log( value );</span><br><span class="line">&#125;).catch( function ( value ) &#123;</span><br><span class="line">    console.log( value );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a name="modules"></a></p>
<p>##模块（Modules）<a href="#catalogue">↑</a></p>
<blockquote>
<p>注：本章的代码似乎有一些问题，基本参考 MDN 为准</p>
</blockquote>
<ol>
<li>模块中的代码自动以严格模式运行</li>
<li>模块中的顶层变量只是模块中顶层，并非全局顶层</li>
<li>顶层中的 <code>this</code> 的值为 <code>undefined</code></li>
<li>代码中不允许 HTML 风格的注释</li>
<li>模块必须有导出的东西</li>
</ol>
<p>###基本导入导出</p>
<p>直接使用原书代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 导出数据</span><br><span class="line">export var color = &quot;red&quot;;</span><br><span class="line">export let name = &quot;Nicholas&quot;;</span><br><span class="line">export const magicNumber = 7;</span><br><span class="line"></span><br><span class="line">// 导出函数</span><br><span class="line">export function sum(num1, num2) &#123;</span><br><span class="line">    return num1 + num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export class Rectangle &#123;</span><br><span class="line">    constructor(length, width) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出引用</span><br><span class="line">function multiply(num1, num2) &#123;</span><br><span class="line">    return num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line">export multiply;</span><br><span class="line"></span><br><span class="line">// 默认导出</span><br><span class="line">export default function () &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// export as</span><br><span class="line">export &#123; multiply as foo &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>除非使用 <code>default</code> 语法，否则函数和类都不能使用匿名</li>
<li><code>export</code> 只能用在顶层中</li>
</ol>
<p><code>as</code> 和 <code>default</code> 语法的情况，给出一个来自 <a href="http://www.2ality.com/2015/07/es6-module-exports.html" target="_blank" rel="noopener">2ality</a> 的表格</p>
<table>
<thead>
<tr>
<th>Statement</th>
<th>Local name</th>
<th>Export name</th>
</tr>
</thead>
<tbody>
<tr>
<td>export {v as x};</td>
<td>‘v’</td>
<td>‘x’</td>
</tr>
<tr>
<td>export default function f() {}</td>
<td>‘f’</td>
<td>‘default’</td>
</tr>
<tr>
<td>export default function () {}</td>
<td>‘<em>default</em>‘</td>
<td>‘default’</td>
</tr>
<tr>
<td>export default 123;</td>
<td>‘<em>default</em>‘</td>
<td>‘default’</td>
</tr>
</tbody>
</table>
<p>可以看出，所谓的默认导出其实就是用了 <code>default</code> 作为名字罢了。</p>
<p>还能够将其他模块重新导出</p>
<table>
<thead>
<tr>
<th>Statement</th>
<th>Module</th>
<th>Import name</th>
<th>Export name</th>
</tr>
</thead>
<tbody>
<tr>
<td>export {v} from ‘mod’;</td>
<td>‘mod’</td>
<td>‘v’</td>
<td>‘v’</td>
</tr>
<tr>
<td>export {v as x} from ‘mod’;</td>
<td>‘mod’</td>
<td>‘v’</td>
<td>‘x’</td>
</tr>
<tr>
<td>export * from ‘mod’;</td>
<td>‘mod’</td>
<td>‘*’</td>
<td>null</td>
</tr>
</tbody>
</table>
<p>导入有很多方法，基本使用到的其实只有几种，以下来自 MDN：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import name from &quot;module-name&quot;;</span><br><span class="line">import * as name from &quot;module-name&quot;;</span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, * as alias from &quot;module-name&quot;;</span><br><span class="line">import defaultMember from &quot;module-name&quot;;</span><br><span class="line">import &quot;module-name&quot;;</span><br></pre></td></tr></table></figure>
<p>最后那种导入是相当于将代码执行了一次。通常可以用来做 <code>polyfills</code> 和 <code>shims</code>。</p>
<p><a name="miscellaneous"></a></p>
<p>##杂七杂八<a href="#catalogue">↑</a></p>
<p><code>Number.isInteger</code>，判断整数</p>
<p><code>Number.isSafeInteger</code>，判断是否是有效整数</p>
<p>Math 中加入很多函数，例如双曲正弦、双曲余弦之类的</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2015/09/24/mocha-chai-travis-ci-codecov-workflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/09/24/mocha-chai-travis-ci-codecov-workflow/" class="post-title-link" itemprop="url">mocha + chai + Travis CI + Codecov 使用流程</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2015-09-24 23:29:00 / Modified: 23:31:01" itemprop="dateCreated datePublished" datetime="2015-09-24T23:29:00+08:00">2015-09-24</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2015/09/24/mocha-chai-travis-ci-codecov-workflow/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/09/24/mocha-chai-travis-ci-codecov-workflow/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###<a href="https://mochajs.org/" target="_blank" rel="noopener">mocha</a><br>a feature-rich JavaScript test framework running on Node.js and the browser</p>
<p>###<a href="http://chaijs.com/" target="_blank" rel="noopener">chai</a><br>a BDD / TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework</p>
<p>###<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a><br>Free continuous integration platform for GitHub projects</p>
<p>###<a href="https://codecov.io/" target="_blank" rel="noopener">Codecov</a><br>Continuous Code Coverage</p>
<p>##编写测试</p>
<p>简单来说，就是使用 mocha 作为测试框架，chai 作为断言库，将项目交给 Travis CI 做自动测试，交给 Codecov 做覆盖率测试。</p>
<p>以我自己的项目 <a href="https://github.com/exoticknight/simpleTemplate.js" target="_blank" rel="noopener">simpleTemplate.js</a> 为例。</p>
<p>先给项目装上 mocha 和 chai。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mocha chai --save-dev</span><br></pre></td></tr></table></figure>
<p>在 <code>package.json</code> 文件中添加测试脚本命令行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;mocha&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目根目录新建文件 <code>test.js</code>。</p>
<p>引入 chai 以及三个要测试的库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var expect = require( &apos;chai&apos; ).expect;</span><br><span class="line"></span><br><span class="line">var bare = require( &apos;./simpleTemplate.bare.js&apos; ),</span><br><span class="line">    normal = require( &apos;./simpleTemplate.normal.js&apos; ),</span><br><span class="line">    advanced = require( &apos;./simpleTemplate.advanced.js&apos; );</span><br></pre></td></tr></table></figure>
<p>定义必需的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var testData = &#123;</span><br><span class="line">    &apos;text1&apos;: &apos;mocha tastes good, chai tastes good too.&apos;,</span><br><span class="line">    &apos;html&apos;: &apos;&lt;hr&gt;&apos;,</span><br><span class="line">    &apos;list&apos;: [1, 2, 3],</span><br><span class="line">    &apos;objectList&apos;: [</span><br><span class="line">        &#123; &apos;name&apos;: &apos;a&apos; &#125;,</span><br><span class="line">        &#123; &apos;name&apos;: &apos;b&apos; &#125;,</span><br><span class="line">        &#123; &apos;name&apos;: &apos;c&apos; &#125;</span><br><span class="line">    ],</span><br><span class="line">    &apos;obj&apos;: &#123; &apos;name&apos;: &apos;obj&apos; &#125;,</span><br><span class="line">    &apos;boolFalse&apos;: false,</span><br><span class="line">    &apos;boolTrue&apos;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mocha 用起来其实也不复杂，常用的就是使用 <code>describe</code> 定义一个项目，使用 <code>it</code> 来执行一项测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe( &apos;bare&apos;, function () &#123;</span><br><span class="line">    describe( &apos;string template&apos;, function () &#123;</span><br><span class="line">        it( &apos;should output correct string&apos;, function () &#123;</span><br><span class="line">            var template = bare( &apos;&lt;p&gt;&#123;=text1&#125;&lt;/p&gt;&apos; );</span><br><span class="line"></span><br><span class="line">            expect( template.fill( testData ).render() ).to.equal( &apos;&lt;p&gt;mocha tastes good, chai tastes good too.&lt;/p&gt;&apos; );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里就是定义了一个 <code>bare</code> 项，里面再定义一个 <code>string template</code> 项，然后在 <code>it</code> 的回调函数中写断言，第一个参数可以写上断言描述。如果断言失败，测试就会失败。</p>
<p>OK，执行 <code>npm test</code>，可以看到结果输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bare</span><br><span class="line">  string template</span><br><span class="line">    √ should output correct string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 passing (9ms)</span><br></pre></td></tr></table></figure>
<p><code>expect(...).to.equal(...)</code> 就是用到了 chai 了。</p>
<p>剩下的测试编写就不再详述了，基本都一样。</p>
<p>##自动测试</p>
<p>去 Travis-CI 官网使用 github 帐号登录，开启对应项目的访问权限。</p>
<p>然后在 <code>package.json</code> 同目录（根目录）下，新建文件 <code>.travis.yml</code>，写入如下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - &quot;0.12&quot;</span><br></pre></td></tr></table></figure>
<p><code>git push</code> 一次，再访问 Travis-CI，会发现已经给你显示出测试结果了。</p>
<p>那么好了，测试通过，何不贴个奖章 show off 一下呢？</p>
<p>在项目旁边有一个黑色加绿色的按钮，点一下，弹框中选择 markdown 格式，将代码贴进 <code>readme</code>，再 <code>git push</code>，去 github 的项目页一看，是不是高大上起来了呢？</p>
<p>##代码覆盖率</p>
<p>代码覆盖率其实也没必要到 100%，只要不是太低的值就可以了。</p>
<p>去 Codecov 官网使用 github 帐号登录，开启对应项目的访问权限。</p>
<p>然后在 <code>package.json</code> 同目录（根目录）下的 <code>.travis.yml</code> 加入如下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - CODECOV_TOKEN: your-uuid</span><br><span class="line">script:</span><br><span class="line">  - istanbul cover node_modules/mocha/bin/_mocha</span><br><span class="line">  - cat ./coverage/coverage.json | node_modules/codecov.io/bin/codecov.io.js</span><br></pre></td></tr></table></figure>
<p>your-uuid 替换成开启项目时生成的 <code>Repository Upload Token</code>。</p>
<p>继续 <code>git push</code> 一次，再访问 Codecov 就可以看到项目的代码覆盖率了。</p>
<p>照样里添加上 badge，点击右边齿轮的 <code>badge</code>，就可以得到 markdown 代码了。</p>
<p>##打完收工</p>
<p>以后每次 <code>push</code>，都会自动运行测试和代码率覆盖统计，去查看一下就知道代码有没有错误或者改进了。</p>
<p>参考文章：</p>
<p><a href="http://callmenick.com/post/basic-front-end-testing-with-mocha-chai" target="_blank" rel="noopener">Basic Front End Testing With Mocha &amp; Chai</a></p>
<p><a href="https://cnodejs.org/topic/5443b8342be2db9d42e8f685" target="_blank" rel="noopener">折腾 Coffee + mocha + Travis-CI 单元测试与覆盖率报告</a></p>
<p><a href="https://github.com/codecov/example-node" target="_blank" rel="noopener">Example Node with Codecov</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2015/09/05/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/09/05/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/" class="post-title-link" itemprop="url">配合 angular 和 angular-material 来开发基于 electron 的应用 · 3--文件组织结构和开发流程</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2015-09-05 17:09:13 / Modified: 17:10:15" itemprop="dateCreated datePublished" datetime="2015-09-05T17:09:13+08:00">2015-09-05</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2015/09/05/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/09/05/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##文件组织结构</p>
<p>良好的文件组织结构不仅能帮助我们更快地定位文件，更能配合开发工具形成流畅的开发流程，从而提高编程效率。</p>
<p>以下的目录和文件都放在存放应用的根目录 <code>app</code> 下。</p>
<p>###package.json</p>
<p>Electron 应用的配置文件，经常做 node 开发的人应该很熟悉了。稍微说明一下一些字段：</p>
<p><code>name</code>: 应用的名字，本项目就是 radioit 了</p>
<p><code>description</code>: 应用的描述</p>
<p><code>version</code>: 应用的版本号</p>
<p><code>author</code>: 作者名字</p>
<p><code>email</code>: 作者的邮箱</p>
<p>###main.js</p>
<p>Electron 应用的入口点，可以在 package.json 的 <code>main</code> 字段自定义</p>
<p>###node_modules/</p>
<p>node 库的目录，一般不用手动管理，而是使用 npm 来安装和卸载库。</p>
<p>###lib/</p>
<p>存放 node 模块的目录。</p>
<p>###src/</p>
<p>存放源代码的目录。</p>
<p>###src/css/</p>
<p>存放待编译的 css 代码，比如本项目用的 .styl 文件。</p>
<p>###src/modules/</p>
<p>存放浏览器端的 javascript 源代码。</p>
<p>因为使用 AngularJS，所以此目录的结构就照搬 AngularJS 项目的结构。</p>
<p>通常来说有两种：按 service / controller / directive 分目录存放，按功能模块存放。</p>
<p>本项目选择按功能模块存放。</p>
<p>###src/modules/entry.js</p>
<p>供 browserify 打包的入口点。最终浏览器端的 javascript 代码会打包成一个名为 <code>bundle.js</code> 的文件。</p>
<p>###static/css/</p>
<p>存放编译好的 CSS 文件。</p>
<p>###static/font/</p>
<p>存放字体文件。因为 Electron 可以访问本地文件，所以自定义字体也基本不需要考虑网络传输问题。</p>
<p>###static/image/</p>
<p>存放图片文件。</p>
<p>###static/js/</p>
<p>存放客户端的 javascript 库，比如 jQuery，underscore，AngularJS 等。</p>
<p>###static/js/bundle.js</p>
<p>browserify 编译 javascript 代码后输出的文件。</p>
<p>###static/view/</p>
<p>存放 HTML 模板文件或者包含 HTML 代码的文件。</p>
<p>##开发流程 – node 相关</p>
<p>有关 node 的开发，跟普通的项目并没有什么两样，需要什么库就直接使用 npm 安装，然后再代码中使用 <code>require</code> 就可以了。</p>
<p>然而虽然 Electron 为 webkit 内核提供了 <code>io.js</code> 的运行环境，但是最好还是避免在客户端（浏览器）的 javascript 代码内混杂需要 node 依赖的代码。换句话说，最好将需要 node 依赖的 javascript 代码和平常在网页中使用的 javascript 代码分开。这样做的好处是不会搞混相关的 API 和设计模式，毕竟 node 大部分时候都是用在服务端上的。</p>
<p>本项目将 node 相关的代码放在 <code>lib/</code> 目录下，负责应用的业务逻辑，其既有可能被主进程所用，也有可能被渲染进程所用。node 相关的代码不需要编译合并。编写时在目录下新建 <code>xxx.js</code> 文件，写好需要 exports 的内容，在其他文件中则使用 <code>require( &#39;./xxx.js&#39; )</code> 就可以了。</p>
<p>##开发流程 – 界面相关</p>
<p>因为界面的渲染采用 webkit 引擎，所以 javascript 的编写和网页开发没有分别。</p>
<p>在 <code>package.json</code> 的 <code>scripts</code> 字段中增加一条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build:js&quot;: &quot;browserify src/modules/entry.js -o static/js/bundle.js&quot;</span><br></pre></td></tr></table></figure>
<p>然后在编写好 javascript 代码的时候，执行 <code>npm run build:js</code> 进行编译。</p>
<p>CSS 的编译则是加入如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build:css&quot;: &quot;stylus -u nib src/css/app.styl -o static/css/app.css&quot;</span><br></pre></td></tr></table></figure>
<p>最后需要运行应用来测试，增加命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;test&quot;: &quot;electron main.js 2&gt;&amp;1 | silence-chromium&quot;,</span><br><span class="line">&quot;start&quot;: &quot;npm run build:js &amp;&amp; npm run build:css &amp;&amp; electron main.js 2&gt;&amp;1 | silence-chromium&quot;</span><br></pre></td></tr></table></figure>
<p>需要测试的时候使用 <code>npm run test</code>，需要运行则使用 <code>npm run start</code> 进行重新编译和运行。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.e10t.net/2015/07/01/a-weird-experience-while-using-pyspider/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="exoticknight">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="exoticknight's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/07/01/a-weird-experience-while-using-pyspider/" class="post-title-link" itemprop="url">记一次奇怪的爬虫经历</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2015-07-01 23:16:30" itemprop="dateCreated datePublished" datetime="2015-07-01T23:16:30+08:00">2015-07-01</time>
            

            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">Comments: </span>
                <a href="/2015/07/01/a-weird-experience-while-using-pyspider/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/01/a-weird-experience-while-using-pyspider/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##前言</p>
<p>由于某些原因，我需要去<del>爬</del>获取一些国家旅游景点的信息。</p>
<p>找到国家旅游局的网站，然后找到一个 5A 风景区目录。</p>
<p>网址：<a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=view&amp;resultType=5A" target="_blank" rel="noopener">http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=view&amp;resultType=5A</a></p>
<p>于是去 pyspider 的 <a href="http://demo.pyspider.org/" target="_blank" rel="noopener">demo</a> 页新建一个项目：<a href="http://demo.pyspider.org/debug/5stat" target="_blank" rel="noopener">5stat</a>，就去爬了。</p>
<p>##分析页面</p>
<p>网页比较特殊，看起来是用 dotnet 写的，翻页是按钮调用 js 代码实现的。跳转后还是同一个网址。</p>
<p>这里就要用到 pyspider 支持的页面载入后运行 js 脚本的功能。</p>
<p>先分析翻页按钮干了什么。</p>
<p>如下图，调用一个名为 <code>__doPostBack</code> 的函数。</p>
<p><img src="https://i.imgur.com/dMRNDZz.png" alt="__doPostBack"></p>
<p>在页面上寻找这个函数，看到函数体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var theForm = document.forms[&apos;form1&apos;];</span><br><span class="line">if (!theForm) &#123;</span><br><span class="line">    theForm = document.form1;</span><br><span class="line">&#125;</span><br><span class="line">function __doPostBack(eventTarget, eventArgument) &#123;</span><br><span class="line">    if (!theForm.onsubmit || (theForm.onsubmit() != false)) &#123;</span><br><span class="line">        theForm.__EVENTTARGET.value = eventTarget;</span><br><span class="line">        theForm.__EVENTARGUMENT.value = eventArgument;</span><br><span class="line">        theForm.submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数将 <code>theForm</code> 里面的 <code>__EVENTTARGET</code> 值设置为 <code>PageNavigator1$LnkBtnNext</code> 之后就提交了。</p>
<p>找到 <code>theForm</code> 对应的元素，看见有三个隐藏域， <code>__EVENTTARGET</code>、<code>__EVENTARGUMENT</code> 和 <code>__VIEWSTATE</code>。</p>
<p><img src="https://i.imgur.com/4Bl389k.png" alt="theForm"></p>
<p>附近还有一个隐藏域 <code>__EVENTVALIDATION</code>。看名字就觉得要提交。</p>
<p>于是试试只提交这三个值看看会不会报错。</p>
<p>在 chrome 上安装 postman 这个应用，打开。</p>
<p><img src="https://i.imgur.com/CwPvFET.png" alt="postman"></p>
<p>修改方式为 POST，填上地址和三个域的值，send。</p>
<p><img src="https://i.imgur.com/7G2dgUC.png" alt="postman result"></p>
<p>OK，返回了正确的页面，也就是可行了。</p>
<p>##爬虫脚本</p>
<p>嗯 pyspider 的爬虫脚本怎么写就不详述了，不会的看文档。</p>
<p>着重列出爬虫执行的 js 脚本的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;</span><br><span class="line">    var flag = &apos;y&apos;;</span><br><span class="line">    if ( document.querySelector(&apos;#PageNavigator1_LnkBtnNext&apos;).getAttribute(&apos;disabled&apos;) ) &#123;</span><br><span class="line">        flag = &apos;n&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return document.form1.__VIEWSTATE.value + &apos;~&apos; + document.form1.__EVENTVALIDATION.value + &apos;~&apos; + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来在回到爬虫脚本中的时候就能得到下一页跳转的参数了。</p>
<p>##奇怪的地方来了</p>
<p>因为 pyspider 的文档说明对于每个项目内的相同网址会忽略，于是按照教学提示给网址加了个 <code>#</code>。很明显这样的网址不会改变请求的参数（使用一些其他技术的情况下除外）。</p>
<blockquote>
<p>之后不再使用这个方法，因为 pyspider 判断是否同网址实质上是简单地将网址 md5 一下生成任务 id，以此来判断是否同一个爬虫任务。后来用的方法是直接重写任务 id 的生成。</p>
</blockquote>
<p>然而在爬下来的数据中却发现有除了旅游地点外的酒店信息。</p>
<p>原来同一个页面也有五星级饭店的信息。如下图，注意最后有一个 <code>#</code>。</p>
<p><img src="https://i.imgur.com/I0saHSE.png" alt="五星级饭店链接"></p>
<p>点击后跳转到一个网址：<a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94" target="_blank" rel="noopener">http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94</a> 的页面。</p>
<p><img src="https://i.imgur.com/RUe1IIX.png" alt="五星级饭店"></p>
<p>看起来跟旅游地点差不多，新建一个项目 <a href="http://demo.pyspider.org/debug/5hotel" target="_blank" rel="noopener">5hotel</a>，直接复制粘贴之前的代码，就是改了一下网址。</p>
<p>期间还将任务 id 的生成重写了一下，这样即使请求同一个网址也没问题了。</p>
<p>然而运行的结果却失败了。</p>
<p><img src="https://i.imgur.com/x8w8QsA.png" alt="failed"></p>
<p>在 content 中很明显看出页面获取不全，然而代码是直接复制的，页面也是相同结构的，为什么会出现这个问题呢？</p>
<p>然后我就被困扰了两天，接着就没在去管，盘算以后自己实现个爬虫再爬好了。</p>
<p>##转机</p>
<p>今天我再上去看，爬 5A 风景区的项目一直稳定运行。</p>
<p>五星级饭店的却还是无法抓取全部页面。</p>
<p>然后我鬼使神差地给网址加了一个 <code>#</code>。网址从：</p>
<p><a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94" target="_blank" rel="noopener">www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94</a></p>
<p>变成</p>
<p><a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx#?catalogType=hotel&amp;resultType=%u4E94" target="_blank" rel="noopener">www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx#?catalogType=hotel&amp;resultType=%u4E94</a></p>
<p>然后就能爬了！！！</p>
<p>shenmegui？？？！！！</p>
<p><img src="https://i.imgur.com/nRP3znG.png" alt="success"></p>
<p>我也搞不清楚究竟是 pyspider 的问题还是 phantomjs 的问题还是 dotnet 的问题了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">exoticknight</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/exoticknight" title="GitHub &rarr; https://github.com/exoticknight" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:draco.knight0#@gmail.com" title="E-Mail &rarr; mailto:draco.knight0#@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/ExoticknightD" title="Twitter &rarr; https://twitter.com/ExoticknightD" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://instagram.com/exoticknight" title="Instagram &rarr; https://instagram.com/exoticknight" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.linkedin.com/in/liang-weiwen-1877665a/" title="Linkin &rarr; https://www.linkedin.com/in/liang-weiwen-1877665a/" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkin"></i>Linkin</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">exoticknight</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  
  
  <script id="dsq-count-scr" src="https://exoticknight.disqus.com/count.js" async></script>







  




  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
