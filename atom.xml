<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>exoticknight&#39;s blog</title>
  
  <subtitle>年寿有时而尽，荣乐止乎其身，二者必至之常期，未若文章之无穷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.e10t.net/"/>
  <updated>2017-08-06T07:45:21.000Z</updated>
  <id>https://www.e10t.net/</id>
  
  <author>
    <name>exoticknight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mocha + Chai + istanbul in ES2015</title>
    <link href="https://www.e10t.net/2017/08/06/mocha-chai-istanbul-in-es2015/"/>
    <id>https://www.e10t.net/2017/08/06/mocha-chai-istanbul-in-es2015/</id>
    <published>2017-08-06T07:20:41.000Z</published>
    <updated>2017-08-06T07:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 JavaScript 写代码的时候，无论是使用 TDD 方法还是为了保证代码的质量和可维护性，都应该考虑加上单元测试。在博文 <a href="https://blog.e10t.net/mocha-chai-travis-ci-codecov-workflow/" target="_blank" rel="noopener">mocha + chai + Travis CI + Codecov 使用流程</a> 中有简单地介绍了如何使用流行的 JavsScript 库来对代码进行自动测试，检查代码覆盖率。</p><p>在那篇文章中，使用的是 Mocha／Chai／istanbul 和在线的 Codecov，以及和 Github 关系密切的 Travis CI，而且测试的 JavaScript 代码是 es5。现在 es2015 已经标准化了，那么教程也需要更新一下了。另外如果项目是私有项目，那么还是使用完备的离线测试环境比较好。接下来就是一个快速可行的教程。</p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>测试框架无需变更，还是 Mocha + Chai 的组合，但是 istanbul 需要稍微变动一下。</p><blockquote><p>如果你不需要 istanbul 做覆盖率测试，那么需要使用 <code>npm install --save-dev babel-register</code> 和 <code>mocha --require babel-register</code> 使 mocha 能识别 es2015 的代码</p></blockquote><p>使用新套件，直接安装 <code>npm i -S mocha chai cross-env nyc babel-plugin-istanbul babel-register babel-preset-env</code>。</p><p>mocha 和 chai 不用解释了，<code>nyc</code> 可以理解是 istanbul 的命令行工具；<code>babel-plugin-istanbul</code> 是在 babel 中插入 istanbul，<code>babel-register</code> 是 istanbul 使用的 babel 接口，这样两个库就打通了；最后 <code>babel-preset-env</code> 是 babel 的运行配置。</p><p>先来配置 <code>babel-plugin-istanbul</code>，新建 <code>.babelrc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;plugins&quot;: [ &quot;istanbul&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>presets</code> 配置告诉 babel 使用 <code>babel-preset-env</code>。当然也可以用 ‘es2015’ + ‘stage-0’ 的组合，具体可以自行斟酌。</p><p><code>env.test.plugins</code> 告诉 babel 在 <code>NODE_ENV=test</code> 的情况下使用插件 <code>babel-plugin-istanbul</code>。</p><p>接下来配置 <code>babel-register</code>，新建 <code>.nycrc</code>：</p><blockquote><p><code>.nycrc</code> 是 nyc 的配置文件，和 <code>.babelrc</code> 类似，当然配置也是可以直接写进 <code>package.json</code> 的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: [</span><br><span class="line">    &quot;babel-register&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;reporter&quot;: [</span><br><span class="line">    &quot;lcov&quot;,</span><br><span class="line">    &quot;text-summary&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;sourceMap&quot;: false,</span><br><span class="line">  &quot;instrument&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的配置直接用了官方的配置。<code>require</code> 字段告诉 nyc 使用 <code>babel-register</code>，<code>reporter</code> 字段的 ‘lcov’ 会让 nyc 生成 <code>lcov.info</code> 文件和对应的 HTML 报告，如果使用 <code>lcovonly</code> 则只生成 ‘lcov.info’。’text-summary’ 则是会在控制台输出覆盖率等信息。</p><blockquote><p>文件会默认生成在 <code>/coverage</code> 下，可以使用 <code>report-dir</code> 字段指定。</p></blockquote><p>最后，在 <code>package.json</code> 中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;cross-env NODE_ENV=test nyc mocha test/**/*.spec.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="测试编写事例"><a href="#测试编写事例" class="headerlink" title="测试编写事例"></a>测试编写事例</h2><p>比如有 <code>index.js</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class Test &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.data = &apos;a&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以写 <code>test/index.spec.js</code>，可以直接上 ES2015 的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; expect &#125; from &apos;chai&apos;</span><br><span class="line">import &#123; Test &#125; from &apos;../index&apos;</span><br><span class="line"></span><br><span class="line">describe(&apos;index test&apos;, function() &#123;</span><br><span class="line">  it(&apos;should be a string&apos;, function() &#123;</span><br><span class="line">    let test = new Test</span><br><span class="line">    expect(test.data).to.be.a(&apos;string&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>npm test</code> 运行测试，得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  index test</span><br><span class="line">    ✓ should be a string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (8ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================== Coverage summary ===============================</span><br><span class="line">Statements   : 100% ( 1/1 )</span><br><span class="line">Branches     : 100% ( 0/0 )</span><br><span class="line">Functions    : 100% ( 1/1 )</span><br><span class="line">Lines        : 100% ( 1/1 )</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure><h2 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h2><p>在测试中经常需要测试 promise 等异步操作，虽然 Mocha 库是可以使用回调来完成测试的，但是我们当然要用 async／await 啦。</p><p>比如，需要测试 <code>index.js</code> 中的 <code>requestAsync</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export class Test &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.data = &apos;a&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestAsync () &#123;</span><br><span class="line">    return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">      res(this.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么需要先 <code>npm i -S babel-polyfill babel-plugin-transform-async-to-generator</code>。</p><p>然后配置 <code>.nycrc</code>，加上 ‘babel-polyfill’ 支持 generator 运行时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;require&quot;: [</span><br><span class="line">    &quot;babel-polyfill&quot;,</span><br><span class="line">    &quot;babel-register&quot;</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 <code>.babelrc</code>，加上 ‘transform-async-to-generator’，将 async 模式转换为 generator 模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;plugins&quot;: [ &quot;istanbul&quot;, &quot;transform-async-to-generator&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着这样测试异步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; expect &#125; from &apos;chai&apos;</span><br><span class="line">import &#123; Test &#125; from &apos;../index&apos;</span><br><span class="line"></span><br><span class="line">describe(&apos;test#requestAsync&apos;, function() &#123;</span><br><span class="line">  it(&apos;should get a string&apos;, async function() &#123;</span><br><span class="line">    const test = new Test</span><br><span class="line">    const ret = await test.requestAsync()</span><br><span class="line">    expect(ret).to.be.a(&apos;string&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在测试项 <code>it</code> 的第二个函数前加 ‘async’ 标志异步，然后在返回 promise 的调用前加上 ‘await’，OK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; cross-env NODE_ENV=test nyc mocha test/**/*.spec.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  test#requestAsync</span><br><span class="line">    ✓ should get a string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (14ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================== Coverage summary ===============================</span><br><span class="line">Statements   : 100% ( 3/3 )</span><br><span class="line">Branches     : 100% ( 0/0 )</span><br><span class="line">Functions    : 100% ( 3/3 )</span><br><span class="line">Lines        : 100% ( 3/3 )</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 JavaScript 写代码的时候，无论是使用 TDD 方法还是为了保证代码的质量和可维护性，都应该考虑加上单元测试。在博文 &lt;a href=&quot;https://blog.e10t.net/mocha-chai-travis-ci-codecov-workflow/&quot; 
      
    
    </summary>
    
    
      <category term=" - javascript" scheme="https://www.e10t.net/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>说说牛客上的一道 JavaScript 题目</title>
    <link href="https://www.e10t.net/2016/12/13/talk-about-a-question-in-nowcoder/"/>
    <id>https://www.e10t.net/2016/12/13/talk-about-a-question-in-nowcoder/</id>
    <published>2016-12-13T12:48:11.000Z</published>
    <updated>2016-12-13T12:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>牛客上有这么一道 JavaScript 的<a href="https://www.nowcoder.com/questionTerminal/9c76e58c2ce94eb9b8168b43adef4f50" target="_blank" rel="noopener">题目</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//填写内容让下面代码支持a.name = “name1”; b.name = “name2”;</span><br><span class="line">function obj(name)&#123;</span><br><span class="line">    【1】</span><br><span class="line">&#125;</span><br><span class="line">obj.【2】 = &quot;name2&quot;;</span><br><span class="line">var a = obj(&quot;name1&quot;);</span><br><span class="line">var b = new obj;</span><br></pre></td></tr></table></figure><p>【1】和【2】是填写的内容，【2】的答案是 <code>prototype.name</code>，没争议。</p><p>问题是【1】，参考答案居然是 <code>if(name){ this.name = name;}return this;</code>，这么随便地玩弄 <code>this</code> 不就是明摆着污染全局变量吗？暴力赋值不可取。</p><p>下面的一些高票讨论还说了一大堆解释的废话，连他自己都说自己好罗嗦。对，你不但罗嗦，而且还没有改错。注释里都说了给 window 的属性赋值，还不自知出问题，真是误人子弟。</p><p>先来分析一下题目，a 和 b 都从 obj 来，为什么同名的属性值不一样？可以看出，是对 obj 这个函数的调用方式不一样，a 是 obj 函数的调用结果，而 b 则是 obj 作为<em>构造函数</em>调用的结果。所以这题的重点应该是如何区分<em>函数调用</em>和<em>构造函数调用</em>。</p><p>一个关键字 <code>new</code> 决定了不同。<code>new</code> 的作用是什么呢？<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN</a> 上说了，面试也会考你的，简单来说是三步，<code>new foo</code>：</p><ol><li>生成一个继承于 foo.prototype 的对象</li><li>foo 会被调用，其中的 <code>this</code> 值会被绑定为 1 中的对象</li><li>如果 foo 没有返回一个对象（注意是对象！），则返回 1 的对象</li></ol><p>从 2 就可以看出 <code>this</code> 值会被 <code>new</code> 绑定为一个确定的对象，而不是像普通函数调用中那样自己不可预料，要看上下文的进程。</p><p>于是就可以在这里做文章。先来判断 <code>this</code> 的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (this instanceof obj) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>instanceof</code> 会检查 <code>this</code> 的原型链上是否存在 <code>foo.prototype</code>。也就是说能判断是否满足第 1 条，确保了对象能从 <code>prototype</code> 中读取到 <code>name</code> 属性。（毕竟代码中并没有给 b 的赋值中传入）</p><blockquote><p><code>instanceof</code> 并不是完美的判断方法，但是在这里足够了，后面会谈到这个问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (this instanceof obj) &#123;</span><br><span class="line">    // new 调用</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非 new 调用</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非 new 调用的情况下，直接返回一个新对象就 OK 了。</p><p>而在 new 调用的情况下，可以看到 <code>function obj(name)</code> 定义的时候是有参数的，调用的时候却没参数，这就要小心了，为了安全起见，还是判断一下为妙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (this instanceof obj) &#123;</span><br><span class="line">    // new 调用</span><br><span class="line">    if (name !== undefined) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非 new 调用</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，判断会写成 <code>if (name)</code>，但是碰到 <code>null</code>、<code>0</code>、<code>false</code> 就 GG 了，所以还是谨慎点吧。</p><p>问题到这里就可以比较完美地解答了。</p><p>##bonus: instanceof 的问题<br>『<code>instanceof</code> 会检查 <code>this</code> 的原型链上是否存在 <code>foo.prototype</code>』，为什么说得这么拗口，是因为需要表达出 <code>instanceof</code> 本来就不是真的用来检测是否调用 <code>new</code> 的方法。</p><p>在题目里面，要求的是 a 需要从原型链上读取到特定的属性值，所以 <code>instanceof</code> 的作用刚好在这里能符合要求而已。</p><p>函数调用除了题目中的方法还有第三种方法，那就是 <code>foo.call</code>、<code>foo.apply</code>，而且也能为函数指定 <code>this</code> 的值（所以还有 <code>bind</code>）。因此是存在方法调戏 <code>instanceof</code> 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo.prototype.name = &apos;foo&apos;</span><br><span class="line">var midman = new foo(&apos;fake foo&apos;)</span><br><span class="line">var a = foo.call(midman)</span><br><span class="line">var b = foo.call(midman, &apos;b&apos;)</span><br><span class="line">a  // undefined, WTF?!</span><br><span class="line">b  // undefined, WTF?!</span><br></pre></td></tr></table></figure><p>这里的 <code>foo</code> 调用的方式是作为函数来调用，但是为 <code>this</code> 绑定的值是从 <code>foo</code> 上 <code>new</code> 出来的，换句话说，其原型链上存在 <code>foo.prototype</code>，于是就骗过了 <code>instanceof</code>。</p><p>于是 ES2015 来搭救你了，新增了一个 <code>new.target</code>。于是修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (new.target !== undefined) &#123;</span><br><span class="line">    // new 调用</span><br><span class="line">    if (name !== undefined) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 非 new 调用</span><br><span class="line">    return &#123;</span><br><span class="line">        name: name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;牛客上有这么一道 JavaScript 的&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/9c76e58c2ce94eb9b8168b43adef4f50&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
      <category term=" - javascript" scheme="https://www.e10t.net/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>FictionInjection-始动：Angular 依赖注入分析和源码抽取改造（上）</title>
    <link href="https://www.e10t.net/2016/05/12/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/"/>
    <id>https://www.e10t.net/2016/05/12/fictioninjection-series-analyze-angular-dependence-injection-and-extract-it-part-1/</id>
    <published>2016-05-12T05:56:53.000Z</published>
    <updated>2016-11-08T07:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>几年前有一个项目构思，由于技术水平低，当时并没有思考得很清楚，所以一直没怎么着手开始。近来前端很多优秀的库出现了，也让我对那个项目有了新的想法。在写了几个 JavaScript 的项目后我觉得可以尝试开始了。尝试并成功写出一些代码之后，就开（挖）始（坑）了这个系列的博文。</p><p>项目是写一个 JavaScript 框架，干什么的在此并不是重点，但是首先需要一个可扩展的模块系统。最简单就是直接用 jQuery 扩展的写法，直接将函数等的挂载在一个对象下，不过如此一来模块之间依赖非常多的话，管理起来会十分困难。也可以使用 AMD / CMD 的模块化的方法，不过考虑到 ES2015 已经加入了 import / export 的语法，最好就直接使用。然而使用了 ES2015 的语法之后，仍然使用 AMD 等的语法就显得很别扭，但是又想要依赖注入功能怎么办？</p><p>解决方法是模（fu）仿（zhi）著名的 AngularJS 中关于依赖注入的源代码。</p><p>Angular 有两个版本，1.x 和 2.x，但是 2.x 中，淡化了模块的概念，直接采用 component 和 ES2015 的 import / export 的机制，所以依赖注入已经不太算是亮点了。而且 Angular2 采用 TypeScript 编写，从语法编写上也不适合作为参考。最后选定 1.4.5 版本。</p><blockquote><p>Angular 项目下还有一个不怎么有人知道的 <code>di.js</code> 项目，是从 Angular 中独立出来的依赖注入库，但是从文档来看，也是需要 TypeScript 来使用。</p></blockquote><p>文章较长，给个目录</p><p><a name="catalogue"></a></p><ul><li><a href="#di">实现依赖注入</a></li><li><a href="#api">从 API 入手</a></li><li><a href="#analyze">开始分析</a></li><li><a href="#wrapup">统一包装</a></li><li><a href="#brief">小结</a></li><li><a href="#injector">注入器的奥秘</a></li><li><a href="#unexpected">读源码的意外发现</a></li></ul><p><a name="di"></a></p><p>##实现依赖注入<a href="#catalogue">↑</a><br>JavaScript 如何实现依赖注入呢？AngularJS 给出了三个解决方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 直接在参数里面声明</span><br><span class="line">module.service( function ( $http ) &#123;&#125; )</span><br><span class="line"></span><br><span class="line">// 使用显示注释</span><br><span class="line">function a () &#123;&#125;</span><br><span class="line">a.$inject = [&apos;$http&apos;]</span><br><span class="line">module.service( a )</span><br><span class="line"></span><br><span class="line">// 数组内联</span><br><span class="line">module.service( [&apos;$http&apos;, function ( http ) &#123;&#125;] )</span><br></pre></td></tr></table></figure><p>实际上三个方式都是一样的，只是使用方式不一样，最后都是使用了 JavaScript 的闭包来实现依赖的注入，原理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function method ( $http ) &#123;</span><br><span class="line">    return function ( args ) &#123;</span><br><span class="line">        // $http.get( args )</span><br><span class="line">        // .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将依赖作为参数传入 <code>menthod</code> 得到的返回值就是是一个可以调用 <code>$http</code> 服务的函数了。</p><p>像这样 <code>[&#39;$http&#39;, function ( http ) {}]</code> 最后一个元素是函数的结构可以称为一个<strong>‘可注入结构’</strong>。</p><p><a name="api"></a></p><p>##从 API 入手<a href="#catalogue">↑</a><br>Angular 库的源代码文件非常大，一般基本不会从头开始看。而 API 作为库对外的窗口，从 API 的使用顺藤摸瓜地查找代码是比较好的做法。Angular 模块的使用一般如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// declare module</span><br><span class="line">const a = angular.module( &apos;a&apos;, [] );</span><br><span class="line">const b = angular.module( &apos;b&apos;, [] );</span><br><span class="line">const c = angular.module( &apos;c&apos;, [&apos;a&apos;] );</span><br><span class="line"></span><br><span class="line">// use the module</span><br><span class="line">a</span><br><span class="line">.value( &apos;a&apos;, 123 )</span><br><span class="line">.factory( &apos;a&apos;, function() &#123; return 123; &#125; )</span><br><span class="line">.service( &apos;serviceName&apos;, ... )</span><br><span class="line">.directive( &apos;directiveName&apos;, ... )</span><br><span class="line">.filter( &apos;filterName&apos;, ... );</span><br></pre></td></tr></table></figure><p>先创建一个模块，用数组说明它的依赖模块，然后模块就可以调用 <code>value</code>、<code>service</code>、<code>directive</code> 等 API，API 的第一个参数是名字，第二个参数则是值或者函数或者数组，了解 AngularJS 的读者应该知道其实是值或者返回值的构造函数或者包含依赖和构造函数的数组。</p><p>打开 Angular.js ，查找出 <code>module(name, requires, configFn)</code> 函数的定义，位于一个更大的函数 <code>setupModuleLoader</code> 内。<code>setupModuleLoader</code> 为 <code>module</code> 函数编写了一些检测函数和变量。最重要的是 <code>modules</code> 变量，用来保存所有的模块信息。</p><p>下面来分析 <code>module</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (requires &amp;&amp; modules.hasOwnProperty(name)) &#123;</span><br><span class="line">  modules[name] = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出如果模块重复创建是会覆盖之前的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** @type &#123;angular.Module&#125; */</span><br><span class="line">var moduleInstance = &#123;</span><br></pre></td></tr></table></figure><p><code>moduleInstance</code> 就是将会返回出去的模块对象，可以看到里面有 <code>name</code> 和 <code>requires</code> 等属性和 <code>provider</code> 和 <code>factory</code> 等函数。</p><p>里面所有的方法，都是通过调用 <code>invokeLater</code> 和 <code>invokeLaterAndSetModuleName</code> 生成的新函数。新函数的上下文中带有 <code>provider</code> 和 <code>method</code> 信息。比如 <code>service</code> 函数：provider=’$provide’，method=’service’，暂时还看不出来信息有什么用，可以先跳过。新函数在调用的时候会将信息连同调用的参数一起 push 进模块的 <code>_invokeQueue</code> 属性中。</p><p>绕了一大圈，就是知道了：在调用 <code>value</code>、<code>service</code>、<code>provider</code> 这些基本的模块功能函数的时候，其实只是将构造函数和相关信息先保存了下来，根本就没有做初始化模块等工作。</p><p>但是作为一个库必定需要跟 <code>window</code> 或者 <code>document</code> 产生点关系不然无法操作 DOM，根据编写过不少库的经验来看，通常将这样的代码放在最后。于是拉到最后一看，gotcha。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jqLite(document).ready(function() &#123;</span><br><span class="line">  angularInit(document, bootstrap);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>明显意思就是在文档准备完毕的时候调用 <code>angularInit</code>，转到 <code>angularInit</code> 的定义发现调用了 <code>bootstrap(appElement, module ? [module] : [], config);</code>，再转到 <code>bootstrap</code> 的定义，在函数内部又会调用 <code>doBootstrap</code> 函数，一系列的检查之后，调用了 <code>createInjector</code> 函数就结束了，转到 <code>createInjector</code> 的定义一看，有 <code>$provide</code> <code>factory</code> 等字样，说明找对地方了。</p><p><a name="analyze"></a></p><p>##开始分析<a href="#catalogue">↑</a></p><p>重点来分析 <code>createInjector</code> 函数。</p><p>函数体大概可以分成四段。</p><p>第一段是定义了 <code>providerCache</code>、<code>instanceCache</code>、<code>providerInjector</code> 和 <code>instanceInjector</code>。最后返回 <code>instanceInjector</code> 对象。<code>providerInjector</code> 和 <code>instanceInjector</code> 各为将 <code>providerCache</code> 和 <code>instanceCache</code> 传入 <code>createInternalInjector</code> 函数的返回值。</p><p>第二段是 provider 函数的定义，用以供初始化时候的调用。</p><p>第三段是 <code>loadModules</code> 函数的定义，作用是，显然，初始化模块。</p><p>第四段是 <code>createInternalInjector</code> 函数的定义，函数返回的是真正的注入器。</p><p>从第一段的代码来看，真正的工作是在 <code>loadModules</code> 函数中，因为 <code>createInternalInjector</code> 函数只返回一个对象，没有 ‘side effect’ 的代码。</p><p><code>loadModules</code> 函数上来就是一个对模块数组的遍历，然后在遍历内取模块的属性 <code>_invokeQueue</code> 来调用 <code>runInvokeQueue</code> 函数对已经缓存下来的对象或方法的构造函数进行处理。</p><p>值得注意的是在做调用 <code>runInvokeQueue</code> 前，有一个递归的调用 <code>loadModules(moduleFn.requires)</code>，表明了在初始化本模块之前，会先初始化依赖的模块。</p><p>到目前为止，可以判明模块初始化的分两个阶段，第一个是：声明模块及其依赖模块 -&gt; 缓存模块变量的构造函数；第二个是：选取一个根模块（对应 AngularJS 中的 ‘app’ 模块） -&gt; 找出其依赖的模块，对于每一个依赖，递归地先初始化其依赖的模块，再初始化自身 -&gt; 处理模块中缓存的变量的构造函数。</p><p>如此采取先缓存所有模块再通过依赖树来初始化的做法虽然看起来繁琐，但是得到一个重要的特性就是声明模块的时候不用关注依赖的顺序，只需要表明依赖就可以了。如果声明的时候就立刻初始化，则必须小心检查所依赖的模块初始化是否已经完成了，然而如此一来就退化成了普通的模块化方法了。<strong>延迟初始化是实现依赖注入的重要过程</strong>。</p><p>模块依赖已经明了，现在来看看作为处理函数的 <code>runInvokeQueue</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function runInvokeQueue(queue) &#123;</span><br><span class="line">  var i, ii;</span><br><span class="line">  for (i = 0, ii = queue.length; i &lt; ii; i++) &#123;</span><br><span class="line">    var invokeArgs = queue[i],</span><br><span class="line">        provider = providerInjector.get(invokeArgs[0]);</span><br><span class="line"></span><br><span class="line">    provider[invokeArgs[1]].apply(provider, invokeArgs[2]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的代码只有两行，<code>provider = providerInjector.get(invokeArgs[0]);</code> 和 <code>provider[invokeArgs[1]].apply(provider, invokeArgs[2]);</code>。</p><p>往上看一下，调用 <code>providerInjector.get</code> 相当于是调用 <code>getService</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function getService(serviceName, caller) &#123;</span><br><span class="line">  if (cache.hasOwnProperty(serviceName)) &#123;</span><br><span class="line">    if (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">      throw $injectorMinErr(&apos;cdep&apos;, &apos;Circular dependency found: &#123;0&#125;&apos;,</span><br><span class="line">                serviceName + &apos; &lt;- &apos; + path.join(&apos; &lt;- &apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[serviceName];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      path.unshift(serviceName);</span><br><span class="line">      cache[serviceName] = INSTANTIATING;</span><br><span class="line">      return cache[serviceName] = factory(serviceName, caller);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      if (cache[serviceName] === INSTANTIATING) &#123;</span><br><span class="line">        delete cache[serviceName];</span><br><span class="line">      &#125;</span><br><span class="line">      throw err;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      path.shift();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码虽多，但基本就是干一件事，返回 <code>cache</code> 中的对象，如果没有，就用 <code>factory</code> 创建一个再返回。而调用的对象 <code>providerInjector</code> 的定义来看，<code>cache</code> 就等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">providerCache = &#123;</span><br><span class="line">  $provide: &#123;</span><br><span class="line">      provider: supportObject(provider),</span><br><span class="line">      factory: supportObject(factory),</span><br><span class="line">      service: supportObject(service),</span><br><span class="line">      value: supportObject(value),</span><br><span class="line">      constant: supportObject(constant),</span><br><span class="line">      decorator: decorator</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>OK，现在可以知道了那些被延迟初始化的模块元素会在这里被处理了。</p><p>从上文可以知道，<code>invokeArgs[0]</code> 的值为 <code>$provider</code>，<code>invokeArgs[1]</code> 的值为 service / factory 等，<code>invokeArgs[2]</code> 则为参数数组。</p><p>看看以下的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 如此使用</span><br><span class="line">m.service( &apos;b&apos;, [&apos;a&apos;, function ( a ) &#123; this.a = a &#125;] );</span><br><span class="line"></span><br><span class="line">// 初始化的时候实际上调用</span><br><span class="line">$provider.service( &apos;b&apos;, [&apos;a&apos;, function ( a ) &#123; this.a = a &#125;] );</span><br></pre></td></tr></table></figure><p><a name="wrapup"></a></p><p>##统一包装<a href="#catalogue">↑</a></p><p>接下来就是分析模块元素（对外表现为 API）的代码了。</p><p>函数有点多，但是还是能看得出来。<code>supportObject</code> 不用管，只是负责转换一下参数，基本的函数是 <code>provider</code>，<code>factory</code> 会调用它，然后 <code>value</code> 和 <code>service</code> 会调用 <code>factory</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function provider(name, provider_) &#123;</span><br><span class="line">  assertNotHasOwnProperty(name, &apos;service&apos;);</span><br><span class="line">  if (isFunction(provider_) || isArray(provider_)) &#123;</span><br><span class="line">    provider_ = providerInjector.instantiate(provider_);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!provider_.$get) &#123;</span><br><span class="line">    throw $injectorMinErr(&apos;pget&apos;, &quot;Provider &apos;&#123;0&#125;&apos; must define $get factory method.&quot;, name);</span><br><span class="line">  &#125;</span><br><span class="line">  return providerCache[name + providerSuffix] = provider_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个判断和第二个判断在 <code>factory</code> 调用的时候是无效的，因为 <code>factory</code> 调用 <code>provider</code> 的时候第二个参数是 Object，而且带有 <code>$get</code> 属性。实际上在本阶段做的是，就是将调用 API 传入的第二个参数（第一个参数是名字）再包装一层对象，再<strong>存储在 <code>providerCache</code> 中</strong>，对象统一拥有 <code>$get</code> 属性，或者说，接口。</p><p>其中，<code>$get</code> 属性是一个可供调用的函数，功能是即使模块元素混杂存储，也能被统一的接口成功调用。</p><p>对于 <code>value</code>，调用 API 的时候传入的是值，因此需要包装成返回这个值的函数才赋值给 <code>$get</code>。</p><p>对于 <code>constant</code>，值是不变的，所以可以看到就直接存储了。</p><p>对于 <code>decorator</code>，同样会定义 <code>$get</code> 属性。</p><p>对于 <code>service</code>，设计上应该生成一个单例并存储下来。不过在这里，仍然是继续包装起来。</p><p>源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function enforceReturnValue(name, factory) &#123;</span><br><span class="line">  return function enforcedReturnValue() &#123;</span><br><span class="line">    var result = instanceInjector.invoke(factory, this);</span><br><span class="line">    if (isUndefined(result)) &#123;</span><br><span class="line">      throw $injectorMinErr(&apos;undef&apos;, &quot;Provider &apos;&#123;0&#125;&apos; must return a value from $get factory method.&quot;, name);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function factory(name, factoryFn, enforce) &#123;</span><br><span class="line">  return provider(name, &#123;</span><br><span class="line">    $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function service(name, constructor) &#123;</span><br><span class="line">  return factory(name, [&apos;$injector&apos;, function($injector) &#123;</span><br><span class="line">    return $injector.instantiate(constructor);</span><br><span class="line">  &#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际干了如下的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function (name) &#123;</span><br><span class="line">  return provider(name, &#123;  // 跟其他 API 一样调用 provider 函数</span><br><span class="line">    $get: function () &#123;</span><br><span class="line">      return instanceInjector.invoke(</span><br><span class="line">          [&apos;$injector&apos;, function($injector) &#123;</span><br><span class="line">              return $injector.instantiate(constructor);  // 注意 constructor 是用户自定义的‘可注入结构’</span><br><span class="line">          &#125;]  // 这又是一个‘可注入结构’，注入的是 &apos;$injector&apos;，实际上就等于 instanceInjector</span><br><span class="line">          , this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)( &apos;serviceName&apos; )</span><br></pre></td></tr></table></figure><p>最后依然将包装好的函数存入 <code>$provider</code>。</p><p>只是为什么还是存储在 <code>$provider</code>，而不是直接调用函数进行初始化？比如 <code>service</code>，为什么还要再包装上一层‘可注入结构’？</p><p><a name="brief"></a></p><p>##小结<a href="#catalogue">↑</a></p><p>前文提到，使用延迟初始化实现了模块的依赖注入，使依赖的模块不需要提前定义。</p><p>实际上模块内的元素（factory / service 等）也是可以使用依赖注入的。使用过 AngularJS 的肯定知道定义某一个 controller 的时候可以注入某个 service，然而 controller 和 service 的定义顺序应该不能对代码运行造成影响。</p><p>因此，在此时，模块元素的“构造函数”（注意是用户自定义的那个函数而并非供<br> new 调用的那个函数）还并不具备运行的条件，因为还是需要等依赖的元素初始化。</p><p>于是某种意义上，模块元素就需要<strong>第二重注入</strong>。把‘可注入结构’缓存在 <code>$provider</code> 中实际上就是对应了前文叙述的‘把模块先全部缓存’，包装上一个函数再统一放在 <code>$get</code> 属性下明显是方便供下一阶段的调用。</p><p>万事俱备，只欠注入了。</p><blockquote><p>分析到现阶段，大家应该对平常使用频繁的 <code>service</code>、<code>factory</code> 等函数有了更深的认识了。</p></blockquote><p><a name="injector"></a></p><p>##注入器的奥秘<a href="#catalogue">↑</a><br>现在把精力放在 <code>createInternalInjector</code> 函数。</p><p>此函数在<a href="#analyze">开始分析</a>一节中已经提到了，作用只是返回一个对象。这个对象就是真正的注入器。</p><p>此函数被调用了两次，分别是得到 <code>providerInjector</code> 和 <code>instanceInjector</code>。</p><p>注入器中重要的函数有三个，分别是 <code>getService</code>、<code>invoke</code> 和 <code>instantiate</code>。</p><p>在<a href="#analyze">开始分析</a>中已经大致介绍了，<code>getService</code> 函数干一件事，返回 <code>cache</code> 中的对象，如果没有，就用 <code>factory</code> 创建一个再返回。</p><p>对于 <code>providerInjector</code>，<code>factory</code> 函数是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function(serviceName, caller) &#123;</span><br><span class="line">  if (angular.isString(caller)) &#123;</span><br><span class="line">    path.push(caller);</span><br><span class="line">  &#125;</span><br><span class="line">  throw $injectorMinErr(&apos;unpr&apos;, &quot;Unknown provider: &#123;0&#125;&quot;, path.join(&apos; &lt;- &apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，因为在调用 provider 的时候，<code>providerCache</code> 中的函数应该已经在上一个初始化模块阶段中被定义好，如果没找到，那么肯定是调用了未定义的 provider。</p><p>对于 <code>instanceInjector</code>，<code>factory</code> 函数是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function(serviceName, caller) &#123;</span><br><span class="line">  var provider = providerInjector.get(serviceName + providerSuffix, caller);</span><br><span class="line">  return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instanceCache</code> 本身就是空的，因此在找不到的时候，就去 <code>providerInjector</code> 里找 provider，然后得到其调用的结果，就是真正需要的实例（instance）了。<code>$get</code> 在这里就凸显出统一调用的用处了。</p><p><code>invoke</code> 函数则是处理<strong>‘可注入结构’</strong>和调用函数。从源码中也可以看到组装参数和调用函数，其中也会调用 <code>getService</code> 去得到实参的值来实现注入。从这里的 <code>getService</code> 出发，又有可能调用 <code>factory</code> 继而继续调用 <code>invoke</code> 来得到所依赖的实例，直到没有任何依赖需要实例化，从而完美的实现了自洽。</p><p><code>instantiate</code> 函数是用来处理 ‘service’ 的，是用来模拟 <code>new</code> 的，从代码来看也是如此：复制一个函数的 prototype，绑定为函数的 <code>this</code>，然后调用函数。因此调用 <code>service</code> API 的时候，可以完全使用构造函数的写法，同时也能得到注入特性。</p><p><a name="unexpected"></a></p><p>##读源码的意外发现<a href="#catalogue">↑</a><br>读源码一般都会有一定的收获，或是技巧上的，或是思想上的。</p><p>当读完了 Angular 的依赖注入的代码后，才发现 Angular 虽然表明支持模块化，但是实际上所谓的模块化只是徒有其名，模块的定义只是方便框架自己做延迟初始化的工作，没有模块之实。模块只是依赖树上的节点，最终生成出来的命名空间跟模块没有一丁点的关系，所有模块里的东西，不论是 ‘value’、’service’ 和 ‘provider’ 等，都是平铺在 <code>instanceCache</code> 里面的。这样的做法明显的一个结果就是命名冲突，两个不同模块里面的同名对象，后实例化的会覆盖掉先实例化的。这一点非常的不好，因为完全不符合模块化的预期结果。</p><p>在下一篇编（fu）写（zhi）注入功能的时候，我会修改这部分使其能满足模块化的实际预期。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几年前有一个项目构思，由于技术水平低，当时并没有思考得很清楚，所以一直没怎么着手开始。近来前端很多优秀的库出现了，也让我对那个项目有了新的想法。在写了几个 JavaScript 的项目后我觉得可以尝试开始了。尝试并成功写出一些代码之后，就开（挖）始（坑）了这个系列的博文。&lt;
      
    
    </summary>
    
    
      <category term=" - javascript - FictionInjection" scheme="https://www.e10t.net/tags/javascript-FictionInjection/"/>
    
  </entry>
  
  <entry>
    <title>看《Sherlock: The Abominable Bride》</title>
    <link href="https://www.e10t.net/2016/01/05/watch-sherlock-the-abominable-bride/"/>
    <id>https://www.e10t.net/2016/01/05/watch-sherlock-the-abominable-bride/</id>
    <published>2016-01-05T11:48:23.000Z</published>
    <updated>2016-01-05T11:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>看完新出的夏洛克，想必大家都会很茫然。刚好今晚也看了，就说说我看了电影和影评后的总结吧。</p><p>PS:有剧透才能更好地看电影。</p><p>PS:如果你是想看好莱坞大片，还像和我同一片场的人那样带着爆米花和泡椒凤爪来看的，可以退票了。</p><p>简单来说，整部电影的剧情几乎都是在嗑了药的夏洛克进入多层梦境中发生的。他要解决上一季结尾中莫里亚蒂的“回归”的问题，于是在脑内——或者说是思维迷宫内——解决一百年前的另外一个“死而复活的新娘”的问题。而解决这个问题的方法，就是将自己带入到那个维多利亚时代中，思考自己会如何行动，剧情如何发展。这也就是为什么差不多通篇都是维多利亚时代风格的由来。案情重组，简而言之。不过，有一个问题，就是实际上根据设定，电影中福尔摩斯并不是十九世纪的人物，如此一来就对原来的案情进行了干涉，出现矛盾，这个后面再谈。</p><p>令来看福华CP的，卖腐的，相爱相杀的女性，啊不，观众大失所望，恐怕是悬疑色彩的浓重，剧情的多段跳跃和突然切换，以及似乎毫无卖腐的情节。然而我等从第一季就只对其具备推理性质和现代化改编产生强烈爱好的人却是大欢喜：这才是正剧的风格，第三季给某些群体派太多显而易见的糖了。</p><p>然而电影中的推理很好吗？电影没有派糖吗？非也。</p><p>先说推理。电影中的诡计归结成一句话就是：死了的新娘为何能复活并杀死其丈夫？答案是一开始就没死，是在姐妹们的帮助下演戏，之后再当街杀丈夫并给大众一种复活的假象再高明地自杀，不留下破绽，并且还继续利用这种牺牲换来了死而复生继而复活的恐怖现象来帮助姐妹完成对姐妹的丈夫的复仇。卧槽竟然吞枪自杀只是演戏？乍一看似乎有点敷衍，但是和朋友讨论后认为，如果考虑到十九世纪科技水平的低下和侦查手段的匮乏，加上法医的暗中帮助，实际上完全是可能发生的。所以说推理虽然并不出彩或者惊世骇俗，然而还是有意思的。只是编剧没有给解答过程一个酷炫的表现，所以观众就有不爽、硬了不射的憋屈。那为什么不表现得很光很亮很油还很duang呢？同样后面再谈。</p><p>再说派糖，电影中最明显的就是瀑布旁莫里亚蒂说的“你们不如私奔吧”的吧？原著可是福尔摩斯和教授一起掉下瀑布失踪的，电影里面华生来救福尔摩斯了啊。麦考夫在飞机里面对夏洛克嗑药的担心和毫不掩饰的be there for you你们无视了吗？午夜夏洛克和华生的深入交谈你们没触动吗？只能说糖派得有点晦涩了，伪粉抖一抖就掉了，真粉还是会粘着。</p><p>另外纵观整个案件，诡计的实施涉及到已经患绝症的新娘，女仆，为了证明自己和男性一样能胜任工作而不得不女扮男装的女法医（电影此处对man的翻译应该有问题）以及一众的女性秘密组织，换句话说，这其实标志着女性的反抗。电影中已有多处暗示：玛丽说她希望跟华生一样能做事，并且参加女性选举权的争取；麦考夫说有一个眼皮底下的enemy，undetected, and unstoppable，还说we will lose，because they are right we are wrong；玛丽从十九世纪的被晾在一边到二十世纪终于能和丈夫一起参与事情；华生家庭的情况；通通都是编剧支持女性争取权利的暗示。这也是跟随了近年电影频繁地使用女性作为主角，将女性塑造出不同形象的大流（我是从冰雪奇缘开始察觉近来电影有这样的趋势的）。这才是给女性派的最好的糖不是吗？</p><p>最后来说说电影对夏洛克这个人物的思考，顺便也把前面两个“后面再谈”解决了。原著中福尔摩斯基本上被塑造成理性思考和推理的机器，然而比较tricky的一点是根据设定，小说是道尔笔下的华生写的，小说中福尔摩斯的形象是道尔笔下的华生给大众塑造的，真实(?)的夏洛克到底是怎样的人无从得知。电影中也有反复地强调华生将夏洛克的案件写成文章发表。在午夜华生反复质问夏洛克关于感情和过去的问题，夏洛克没有说出来。这是编剧对夏洛克这个人物感情的探讨，没什么清晰的结论。之后没能保护受害人，夏洛克把自己关在房间里又磕药。然后莫里亚蒂就出现了在房间又吞枪了一次，没死，夏洛克觉得想不通怎么死不了的时候飞机着陆了把他震醒了。醒过来的二十一世纪是现实。一番交流后他又睡了，在梦里十九世纪醒来，开始了找玛丽和到在教堂里面解谜。最后指认凶手的时候他突然想到，凶手为什么要找他来破案呢？因为历史上新娘案就没被侦破，他作为侦探加入进案件了就产生了干涉，造成了奇怪的悖论。接着莫里亚蒂又出来了，场景就又切换到二十一世纪了，但是是更深一层梦里的二十一世纪，因为最后死尸活过来了，在现实里是不可能的。紧接着场景转到了著名的瀑布，这个估计就是夏洛克心里近乎最深层的地方了。可以看到，每当梦里有不寻常的事情发生，莫里亚蒂就会出来，试图让夏洛克偏离方向，只是第一次被飞机降落打断了。于是也就解释了为何解谜过程不酷炫，第一解谜发生在夏洛克脑内，显然不需要“炫”给自己看；第二，解谜会引出悖论从而引出教授，太酷炫会让观众大脑当机无法思考莫里亚蒂出现的原因。看到这你是不是忘记了这一段说的是夏洛克人物的探讨了？前面说了一大段剧情其实就是论证了在这个系列中，编剧认为莫里亚蒂就是夏洛克的心结和过去，或者说他脑中的魔鬼，会让夏洛克的思考出现问题。这是编剧对夏洛克过去的探讨。在原著中两人双双跌下瀑布，电影中是华生出来救场，并且表现得完全不像非梦境的华生。这“夏洛克被心魔莫里亚蒂殴打，华生赶来将教授一脚踹下”的场景表明夏洛克不再纠结莫里亚蒂“复活”了，而明白是他“回来”了。</p><p>于是正如新娘最终还是死了，莫里亚蒂大约的确已经死了。正如复仇是秘密组织干的，无责任猜测一下下一季的剧情大概就是教授的同伙来复仇了。</p><p>最后来看看编剧在电影里融合了什么呢？电视剧中的人物的重新运用，合格的推理，女性主义，对夏洛克的人物心理探讨，还有两季之间的承前启后。或许把这么多的东西融于一炉是有点用力过猛了，我刚看完的时候也是有点懵了，但是走回家的路上却越想越有意思。</p><p>我给这电影三个评价：</p><ul><li>女性主义的胜利</li><li>原著党的胜利</li><li>伪粉的处刑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完新出的夏洛克，想必大家都会很茫然。刚好今晚也看了，就说说我看了电影和影评后的总结吧。&lt;/p&gt;
&lt;p&gt;PS:有剧透才能更好地看电影。&lt;/p&gt;
&lt;p&gt;PS:如果你是想看好莱坞大片，还像和我同一片场的人那样带着爆米花和泡椒凤爪来看的，可以退票了。&lt;/p&gt;
&lt;p&gt;简单来说，整部
      
    
    </summary>
    
    
      <category term=" - 电影" scheme="https://www.e10t.net/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>クリスマス？なにそれ？美味しいの？</title>
    <link href="https://www.e10t.net/2015/12/25/single-bell-2015/"/>
    <id>https://www.e10t.net/2015/12/25/single-bell-2015/</id>
    <published>2015-12-25T09:02:32.000Z</published>
    <updated>2015-12-25T09:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个妹子给我推荐了这个刷算法题换装的游戏。</p><p>然而随着一道又一道的题目的通过，悲伤感越来越重却是怎么回事。</p><p>在平安夜和圣诞节一个人对着电脑敲代码来给虚拟妹子解锁装扮也是够自虐的。<br><img src="https://ooo.0o0.ooo/2015/12/25/567d017589cbe.png" alt="tu"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个妹子给我推荐了这个刷算法题换装的游戏。&lt;/p&gt;
&lt;p&gt;然而随着一道又一道的题目的通过，悲伤感越来越重却是怎么回事。&lt;/p&gt;
&lt;p&gt;在平安夜和圣诞节一个人对着电脑敲代码来给虚拟妹子解锁装扮也是够自虐的。&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用ES6编写一个生命游戏</title>
    <link href="https://www.e10t.net/2015/11/27/write-a-game-of-life-using-es6/"/>
    <id>https://www.e10t.net/2015/11/27/write-a-game-of-life-using-es6/</id>
    <published>2015-11-26T16:38:57.000Z</published>
    <updated>2015-11-27T04:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/exoticknight/gol.js" target="_blank" rel="noopener">GitHub 地址</a></p></blockquote><p><img src="https://i.imgur.com/fLKUaVL.gif" alt="gif"></p><p>##缘起</p><p>前段时间看了《Understanding ECMAScript 6》，因为有 JavaScript 的基础，很快就上手了，还写了<a href="http://blog.e10t.net/understanding-ecmascript6-note/" target="_blank" rel="noopener">笔记</a>。然而编程只看书是不够的，还需要让身体熟悉起来。刚好最近在看「全部成为F」这部新番，看到 ED 采用了「生命游戏」的表现形式，于是便有了用 ES6 来写一个的主意。</p><p>##「生命游戏」</p><p>「生命游戏」的英文原文是「Game of Life」，是细胞自动机的一种形式，每个细胞的未来状态只取决于以其为中心周围八格细胞的当前状态。更详细的信息请看<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank" rel="noopener">wiki条目</a>，给出一个有意思的动画图。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="gif动画图"></p><p>而状态判断只有四条：</p><ol><li>当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少）</li><li>当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。</li><li>当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</li><li>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）</li></ol><p>###算法思考</p><p>假设有一个棋盘，每一个格子代表一个细胞。在每一次生成下一代细胞，先遍历每一个细胞，查询它周围八格细胞的状态，设置本细胞下一代的状态。</p><p>显然这样的算法基本毫无意义，因为显然棋盘是不定大小的，细胞也不是每一代都一定会变化的，遍历整个棋盘也是浪费时间的。</p><p>实际上，发生变化或者有可能发生变化的细胞，基本是聚集在活细胞周围的。如果一个死细胞附近没有活细胞，那么这个细胞就不会发生变化。所以，可以换个思路，每一个曾经活过或者在活细胞周围的细胞都维持一个它的邻居细胞的数目记录。每当一个细胞活过来了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录增加 1；相反每当一个细胞死了，就通知周围八格的细胞，让它们的活邻居细胞的数目记录减少 1。显然在更新完之后，周围八格的细胞不论生死都清楚自己周围的活细胞数，也就是能够得到自己的未来状态了。同时，在通知周围八个邻居的时候，也可以统计出对于本细胞来说的活邻居数，于是本细胞的未来状态也能够得到了。</p><p>于是算法能描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1)在某一次生成本次状态中，有将改变状态的细胞集合 S</span><br><span class="line">2)遍历集合 S，对于细胞 i：</span><br><span class="line">    改变细胞 i 的状态</span><br><span class="line">    细胞 i 的活邻居数置零</span><br><span class="line">    遍历 8 个邻居细胞，对于邻居细胞 j：</span><br><span class="line">        如果细胞 i 改变后的状态 == 存活，细胞 j 的活邻居数增加 1</span><br><span class="line">        如果细胞 i 改变后的状态 == 死亡，细胞 j 的活邻居数减少 1</span><br><span class="line">        计算细胞 j 的未来状态并记录在将改变状态的细胞集合 S&apos; 中</span><br><span class="line">        如果细胞 j 是活细胞：</span><br><span class="line">            细胞 i 的活邻居数增加 1</span><br><span class="line">    计算细胞 i 的未来状态并记录在将改变状态的细胞集合 S&apos; 中</span><br><span class="line">3)S = S&apos;，重复 1)、2)</span><br></pre></td></tr></table></figure><p>##ES6 写起来</p><p>ES6 中有 class 的概念，虽然实现方式其实就是 function 和原型，但是在写的时候就不用像以前用「模拟」的手段来编写啦。</p><p>###基本对象</p><p>基本来说，分三个主要对象：提供算法的 class Life，提供单元格绘制的 class Grid，提供 DOM 动画控制的 class Game。Game 从算法中得到需要重绘的单元格，通过 Grid 来绘制单元格。</p><p>###class Life</p><p>已经有算法描述了，写起来并不复杂。新建一个 <code>life.js</code> 文件，导出 <code>Life</code> 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default class Life &#123;</span><br><span class="line">  constructor ( row, col ) &#123;</span><br><span class="line">    this.row = row;</span><br><span class="line">    this.column = col;</span><br><span class="line"></span><br><span class="line">    this.generation = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * this.world = &#123;</span><br><span class="line">     *   &apos;0,0&apos;:  // &apos;x,y&apos;</span><br><span class="line">     *   [</span><br><span class="line">     *     1,  // alive 1, dead 0</span><br><span class="line">     *     0,  // count of neighbour</span><br><span class="line">     *   ]</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line">    this.world = &#123;&#125;;</span><br><span class="line">    /*</span><br><span class="line">     * &apos;0,0&apos;:  // &apos;x,y&apos;</span><br><span class="line">     * 1  // to be alive 1, to be dead -1, 0 not change</span><br><span class="line">     */</span><br><span class="line">    this.changedState = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数只需要得到世界（棋盘）的长宽就行了，<code>this.world</code> 记录世界中受关注细胞的状态，<code>this.changedState</code> 记录将要改变状态的细胞。</p><p>算法本体代码，相当于描述 2) 中循环中的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">_processLife ( x, y, state ) &#123;</span><br><span class="line">  let currentCellHash = x + &apos;,&apos; + y;</span><br><span class="line">  if ( this.world[currentCellHash] ) &#123;</span><br><span class="line">    // 根据 state 改变状态</span><br><span class="line">    this.world[currentCellHash][0] = state ? 1 : 0;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果世界中不存在记录，则肯定是新的活细胞</span><br><span class="line">    this.world[currentCellHash] = [1, 0];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新邻居细胞并统计活邻居数</span><br><span class="line">  let aliveNeighBours = 0;</span><br><span class="line">  let neighbours = [</span><br><span class="line">    // 左边的邻居</span><br><span class="line">    [x - 1, y - 1],</span><br><span class="line">    [x - 1, y],</span><br><span class="line">    [x - 1, y + 1],</span><br><span class="line">    // 上下邻居</span><br><span class="line">    [x, y - 1],</span><br><span class="line">    [x, y + 1],</span><br><span class="line">    // 右边的邻居</span><br><span class="line">    [x + 1, y - 1],</span><br><span class="line">    [x + 1, y],</span><br><span class="line">    [x + 1, y + 1],</span><br><span class="line">  ];</span><br><span class="line">  let counter = state ? +1 : -1;</span><br><span class="line"></span><br><span class="line">  // 循环 8 个邻居</span><br><span class="line">  for ( let i = 0; i &lt; 8; i++ ) &#123;</span><br><span class="line">    let [nx, ny] = neighbours[i];</span><br><span class="line"></span><br><span class="line">    // 一些世界中的约束</span><br><span class="line">    if ( 0 &lt;= nx &amp;&amp; nx &lt; this.column &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; this.row ) &#123;</span><br><span class="line">      let hash = nx + &apos;,&apos; + ny;</span><br><span class="line">      let oldState = this.world[hash];</span><br><span class="line"></span><br><span class="line">      // oldState[0] alive or dead, oldState[1] count of neighbour</span><br><span class="line">      if ( oldState ) &#123;  // 邻居已经存在于世界中了</span><br><span class="line">        oldState[1] += counter;  // 更新邻居的邻居数</span><br><span class="line"></span><br><span class="line">        // 顺便统计活邻居数</span><br><span class="line">        if ( oldState[0] ) &#123;</span><br><span class="line">          aliveNeighBours++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;  // 边缘开拓新的细胞，肯定是死细胞</span><br><span class="line">        oldState = this.world[hash] = [0, 1];</span><br><span class="line">      &#125;</span><br><span class="line">      // 计算邻居细胞的未来状态</span><br><span class="line">      switch ( oldState[1] ) &#123;</span><br><span class="line">        case 8:</span><br><span class="line">        case 7:</span><br><span class="line">        case 6:</span><br><span class="line">        case 5:</span><br><span class="line">        case 4:</span><br><span class="line">        case 1:</span><br><span class="line">        case 0:</span><br><span class="line">          this.changedState[hash] = -1;  // if alive, then to be dead</span><br><span class="line">          break;</span><br><span class="line">        case 3:</span><br><span class="line">          this.changedState[hash] = 1;  // if dead, then to be alive</span><br><span class="line">          break;</span><br><span class="line">        case 2:</span><br><span class="line">          this.changedState[hash] = 0;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 计算当前细胞的未来状态</span><br><span class="line">  this.world[currentCellHash][1] = aliveNeighBours;</span><br><span class="line">  switch ( aliveNeighBours ) &#123;</span><br><span class="line">    case 8:</span><br><span class="line">    case 7:</span><br><span class="line">    case 6:</span><br><span class="line">    case 5:</span><br><span class="line">    case 4:</span><br><span class="line">    case 1:</span><br><span class="line">    case 0:</span><br><span class="line">      this.changedState[currentCellHash] = -1;  // if alive, then to be dead</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      this.changedState[currentCellHash] = 1;  // if dead, then to be alive</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      this.changedState[currentCellHash] = 0;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 的循环其实就是得到下一代的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nextGeneration () &#123;</span><br><span class="line">  let state = Object.assign( &#123;&#125;, this.changedState );  // 复制将要改变的状态集以便清空</span><br><span class="line">  let changedCells = &#123; 0: [], 1:[] &#125;;</span><br><span class="line"></span><br><span class="line">  // reset next state</span><br><span class="line">  this.changedState = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // 2) 的循环</span><br><span class="line">  for ( let key in state ) &#123;</span><br><span class="line">    let [x, y] = key.split( &apos;,&apos; ).map( x =&gt; parseInt( x ) );</span><br><span class="line"></span><br><span class="line">    if ( state[key] === 1 &amp;&amp; ( !this.world[key] || this.world[key][0] === 0 ) ) &#123;</span><br><span class="line">      this.aliveAt( x, y );  // 会调用 _processLife( x, y, true )</span><br><span class="line">      changedCells[1].push( [x, y] );  // 记录重绘的细胞</span><br><span class="line">    &#125; if ( state[key] === -1 &amp;&amp; this.world[key][0] === 1 ) &#123;</span><br><span class="line">      this.killAt( x, y );  // 会调用 _processLife( x, y, false )</span><br><span class="line">      changedCells[0].push( [x, y] );  // 记录重绘的细胞</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return changedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他函数可以在 GiiHub 查看。</p><p>###class Grid</p><p>确定使用 <code>HTML5</code> 中的 <code>Canvas</code> 元素来绘制整个世界（棋盘），<code>Canvas</code> 元素的操作使用另一个类 <code>C</code>，后面再写。</p><p>新建 <code>grid.js</code> 文件，导出 <code>Grid</code> 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default class Grid &#123;</span><br><span class="line">  constructor ( canvas, row, col, displayScheme, colorScheme ) &#123;</span><br><span class="line">    this.view = canvas;</span><br><span class="line">    this.canvas = new C( canvas );</span><br><span class="line"></span><br><span class="line">    this.displayScheme = displayScheme;</span><br><span class="line">    this.colorScheme = colorScheme;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数要传入 canvas DOM 元素，棋盘的长宽，显示的选项和颜色选项。</p><p>绘制单元格的主要函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drawCells( redrawCells ) &#123;</span><br><span class="line">  // draw alive cells</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.aliveColor );</span><br><span class="line">  for ( let x, y, i = 0, len = redrawCells[1].length; i &lt; len; i++ ) &#123;</span><br><span class="line">    [x, y] = redrawCells[1][i];</span><br><span class="line">    this.drawCellAt( x, y );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // draw dead cells</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.deadColor );</span><br><span class="line">  for ( let x, y, i = 0, len = redrawCells[0].length; i &lt; len; i++ ) &#123;</span><br><span class="line">    [x, y] = redrawCells[0][i];</span><br><span class="line">    this.drawCellAt( x, y );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawCellAt ( x, y ) &#123;</span><br><span class="line">  this.canvas.drawRect(</span><br><span class="line">    x * ( this.displayScheme.borderWidth + this.displayScheme.cellWidth ),</span><br><span class="line">    y * ( this.displayScheme.borderWidth + this.displayScheme.cellWidth ),</span><br><span class="line">    this.displayScheme.cellWidth,</span><br><span class="line">    this.displayScheme.cellWidth );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>drawCells</code> 函数是用来批量画细胞的函数，同样颜色的细胞放在一起画，就不需要频繁改变画笔的颜色。</p><p><code>drawCellAt</code> 函数就是找到单元格的左上角距离 <code>Canvas</code> 元素左上角的距离，距离左边是第 x 个细胞宽度加细胞边框宽度，距离上边也是同样道理。</p><p>其中调用的 <code>setPenColor</code> 和 <code>drawRect</code> 还没有，于是就新增一个 <code>c.js</code> 文件，导出 <code>C</code> 类。其实就是 <code>Canvas</code> 元素的操作的封装而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default class C &#123;</span><br><span class="line">  constructor ( ele ) &#123;</span><br><span class="line">    this.cxt = ele.getContext( &apos;2d&apos; );</span><br><span class="line">    this.fillStyle = &apos;#000000&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPenColor ( hex ) &#123;</span><br><span class="line">    this.cxt.fillStyle = this.fillStyle = &apos;#&apos; + hex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  drawRect ( ox, oy, width, height ) &#123;</span><br><span class="line">    this.cxt.fillRect( ox, oy, width, height );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear () &#123;</span><br><span class="line">    this.cxt.clearRect( 0, 0, this.cxt.canvas.width, this.cxt.canvas.height );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###class Game</p><p>不复杂，直接看代码吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import Life from &apos;./life.js&apos;;</span><br><span class="line">import Grid from &apos;./grid.js&apos;;</span><br><span class="line"></span><br><span class="line">export default class Game &#123;</span><br><span class="line">  constructor ( canvas, row, col, displayScheme, colorScheme, gps ) &#123;</span><br><span class="line">    this.grid = new Grid( canvas, row, col, displayScheme, colorScheme );</span><br><span class="line">    this.life = new Life( row, col );</span><br><span class="line"></span><br><span class="line">    this.speed = 1000 / gps;</span><br><span class="line"></span><br><span class="line">    this.enable = false;</span><br><span class="line">    this.running = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init ( x ) &#123;</span><br><span class="line">    this.stop();</span><br><span class="line">    this.life.init( x );</span><br><span class="line">    this.grid.init();</span><br><span class="line">    this.enable = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop () &#123;</span><br><span class="line">    this.running = false;</span><br><span class="line">    this.enable = false;</span><br><span class="line">    this.life.reset();</span><br><span class="line">    this.grid.claer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pause () &#123;</span><br><span class="line">    if ( this.enable ) &#123;</span><br><span class="line">      this.running = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resume () &#123;</span><br><span class="line">    if ( this.enable ) &#123;</span><br><span class="line">      this.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  step () &#123;</span><br><span class="line">    if ( this.enable ) &#123;</span><br><span class="line">      // run algorithm</span><br><span class="line">      let redrawCells = this.life.nextGeneration();</span><br><span class="line">      // redraw cells</span><br><span class="line">      this.grid.drawCells( redrawCells );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    if ( this.enable &amp;&amp; !this.running ) &#123;</span><br><span class="line">      this.running = true;</span><br><span class="line"></span><br><span class="line">      let _run = () =&gt; &#123;</span><br><span class="line">        if ( this.running ) &#123;</span><br><span class="line">          this.step();</span><br><span class="line">          setTimeout( _run, this.speed );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      setTimeout( _run, 0 );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一些简单的动画控制方法，跟普通 JavaScript 写起来没什么不同。需要注意的是 <code>enable</code> 状态和 <code>running</code> 状态是不一样的，前者是指整个游戏的响应，后者是指动画的响应。</p><p><code>step</code> 方法是迭代一步，<code>run</code> 方法就是用 <code>setTimeout</code> 来循环调用 <code>step</code> 了。在 <code>run</code> 方法中使用了箭头函数来隐含设定了 <code>this</code> 的值，ES6 的优势就体现出来了。</p><p>###gol.js</p><p>整个程序的主体是 Game 的实例，然而还是需要有人去创造一个实例出来，也就是说需要一个工厂函数。于是，新建 <code>gol.js</code> 文件，导出 <code>GOL</code> 类。里面写一个静态方法，用作创建 Game 实例的工厂方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Game from &apos;./game.js&apos;;</span><br><span class="line"></span><br><span class="line">export default class GOL &#123;</span><br><span class="line">  static createGame ( canvas, row, col, options ) &#123;</span><br><span class="line">    let param = Object.assign( &#123;</span><br><span class="line">      displayScheme: &#123;</span><br><span class="line">        borderWidth: 1,</span><br><span class="line">        cellWidth: 10</span><br><span class="line">      &#125;,</span><br><span class="line">      colorScheme: &#123;</span><br><span class="line">        aliveColor: &apos;000000&apos;,</span><br><span class="line">        deadColor: &apos;FFFFFF&apos;,</span><br><span class="line">        worldColor: &apos;FFFFFF&apos;,</span><br><span class="line">        borderColor: &apos;FFFFFF&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      gps: 15</span><br><span class="line">    &#125;, options );</span><br><span class="line"></span><br><span class="line">    return new Game( canvas, row, col, param.displayScheme, param.colorScheme, param.gps );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在 <code>createGame</code> 方法上就不要用 ES6 的语法了，因为方法是要在页面上调用的，目前还没有哪个浏览器完全支持 ES6。但是在方法里面用是没问题的，因为编译器会帮我们转换好。于是可以看到方法里面直接用 <code>Object.assign( des, src )</code> 的函数来合并参数，类似 jQuery 的 <code>extends</code> 函数。</p><p>###boot.js</p><p>到此还没完，回忆一下在写普通 JavaScript 库的时候，我们通常会直接包裹上一层适应各种环境的模块注册代码，本人最喜欢就是直接使用 <a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a> 了。</p><p>新建 <code>boot.js</code> 文件，执行非 ES6 形式的导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import GOL from &apos;./gol.js&apos;;</span><br><span class="line"></span><br><span class="line">(function ( root, name, definition ) &#123;</span><br><span class="line">  if ( typeof define === &apos;function&apos; &amp;&amp; define.amd ) &#123;</span><br><span class="line">    define( [], function () &#123;</span><br><span class="line">        return ( root[name] = definition( root ) );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else if ( typeof module === &apos;object&apos; &amp;&amp; module.exports ) &#123;</span><br><span class="line">    module.exports = definition( root );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root[name] = definition( root );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)( window, &apos;GOL&apos;, function ( root ) &#123;</span><br><span class="line">  return GOL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>##代码打包</p><p>OK，到此代码基本写好了，然而到在浏览器上执行还是有一段距离，主要是基本没有浏览器默认支持 ES6，我们还是需要将 ES6 的代码编译一下以便能放到浏览器上运行。比较有名的编译器就是 <a href="https://github.com/babel/babel" target="_blank" rel="noopener">Babel</a> 和 Google 的 <a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a> 了。在编译的同时，还需要将所有文件打包成 bundle。</p><p>在进行了各种尝试之后（包括主流的 npm / browserify / jspm 等），最后发现使用 <code>webpack</code> 和 <code>Babel</code> 的结合是比较理想的。</p><p>###配置</p><p>先来把需要的东西都装上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev webpack babel babel-core babel-loader babel-preset-es2015</span><br></pre></td></tr></table></figure><blockquote><p>个人其实非常讨厌安装到本地，明明都是可以全局安装的插件和工具。<br>而且每次开一个新的项目就要安装几十 MB 的重复东西实在无聊，npm 本身的树状依赖也是容易造成目录过深的情况。（据说新版 npm 有改善，但是不稳定）<br>个人的解决方法是固定一个开发目录，代码随便迁移。</p></blockquote><p>###webpack.config.js</p><p><code>webpack</code> 我就不详细解释了。直接上 <code>webpack.config.js</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/boot.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: &apos;./dist/bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                loader: &apos;babel&apos;,</span><br><span class="line">                query: &#123;</span><br><span class="line">                    cacheDirectory: true,</span><br><span class="line">                    presets: [&apos;es2015&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前来说，这样写就能让 <code>Babel</code> 编译 ES6 的代码的同时，也运用 <code>webpack</code> 自己的打包功能<strong>根据 ES6 的模块语法</strong>将文件都打包成一个 bundle。</p><p>打包出来的代码有点大，压缩一下，再写一个 <code>webpack.config.min.js</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.min.js</span><br><span class="line">var webpack = require(&quot;webpack&quot;);</span><br><span class="line">module.exports = exports = Object.create(require(&quot;./webpack.config.js&quot;));</span><br><span class="line">exports.plugins = [new webpack.optimize.UglifyJsPlugin()];</span><br><span class="line">exports.output = Object.create(exports.output);</span><br><span class="line">exports.output.filename = exports.output.filename.replace(/\.js$/, &quot;.min.js&quot;);</span><br></pre></td></tr></table></figure><p>就能用 <code>webpack</code> 自带的压缩插件压缩代码了。</p><p>##添加功能</p><p>算法、绘图和动画控制都写好了，但是还不够，缺少了交互，还应该允许方便的自定义世界中的活细胞。比较好的交互方式就是允许通过在世界（棋盘）点击来放置活细胞或者死细胞。</p><p>于是考虑监听 <code>Canvas</code> 元素的 <code>mousedown</code>、<code>mousemove</code> 和 <code>mouseup</code> 事件，做出类似画图那样的效果（每个细胞可以看成是一个像素点）。</p><p>###grid.js</p><p>先改造负责绘制的模块。</p><p>在 <code>Grid</code> 类中新增 <code>drawAliveCellAt</code>、<code>drawDeadCellAt</code> 函数，负责独立绘制细胞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drawAliveCellAt( x, y ) &#123;</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.aliveColor );</span><br><span class="line">  this.drawCellAt( x, y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawDeadCellAt( x, y ) &#123;</span><br><span class="line">  this.canvas.setPenColor( this.colorScheme.deadColor );</span><br><span class="line">  this.drawCellAt( x, y );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 <code>on</code>、<code>off</code> 函数，负责绑定监听方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">on ( event, handler ) &#123;</span><br><span class="line">  this.view.addEventListener( event, handler, false );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">off ( event, handler ) &#123;</span><br><span class="line">  this.view.removeEventListener( event, handler );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 <code>getXFromPixel</code>、<code>getYFromPixel</code> 函数，负责将像素点转换为单元格位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getXFromPixel ( pixel ) &#123;</span><br><span class="line">  let d = this.displayScheme.borderWidth + this.displayScheme.cellWidth;</span><br><span class="line">  let x = ~~( ( pixel - this.canvas.left ) / d );</span><br><span class="line">  return x % d &lt;= this.displayScheme.cellWidth ? x : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getYFromPixel ( pixel ) &#123;</span><br><span class="line">  let d = this.displayScheme.borderWidth + this.displayScheme.cellWidth;</span><br><span class="line">  let y = ~~( ( pixel - this.canvas.top ) / d );</span><br><span class="line">  return y % d &lt;= this.displayScheme.cellWidth ? y : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>~~</code> 是快速取整数。<code>this.canvas.left</code> 和 <code>this.canvas.top</code> 来自于类 <code>C</code> 的实例，因为鼠标点击事件取得的坐标点并非一定是相对于 <code>Canvas</code> 元素的左上角，还要减去 <code>Canvas</code> 元素的边框等。在 <code>c.js</code> 中将构造函数修改一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor ( ele ) &#123;</span><br><span class="line">  this.cxt = ele.getContext( &apos;2d&apos; );</span><br><span class="line">  this.fillStyle = &apos;#000000&apos;;</span><br><span class="line">  this.left = ele.getBoundingClientRect().left;</span><br><span class="line">  this.top = ele.getBoundingClientRect().top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###game.js</p><p>类 <code>Game</code> 的修改有点复杂。先在类的构造函数中增加一个属性，负责记录鼠标状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this._mouseState = &#123;</span><br><span class="line">  press: false,</span><br><span class="line">  lastX: -1,</span><br><span class="line">  lastY: -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再增加三个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_onMouseDown ( e ) &#123;</span><br><span class="line">  this._mouseState.press = true;</span><br><span class="line">  this._toggleCell( e.clientX, e.clientY );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_onMouseMove ( e ) &#123;</span><br><span class="line">  if ( this._mouseState.press ) &#123;</span><br><span class="line">    this._toggleCell( e.clientX, e.clientY );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_onMouseUp ( e ) &#123;</span><br><span class="line">  this._mouseState.press = false;</span><br><span class="line">  this._mouseState.lastX = this._mouseState.lastY = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鼠标按下，就在鼠标按下的位置改变细胞的状态，并记录鼠标状态为按下。接着如果鼠标弹起，那么就重置鼠标状态；如果鼠标移动并且状态是按下，那么就一直改变路过的细胞的状态。</p><p><code>_toggleCell</code> 方法这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_toggleCell ( px, py ) &#123;</span><br><span class="line">  let x = this.grid.getXFromPixel( px );</span><br><span class="line">  let y = this.grid.getYFromPixel( py );</span><br><span class="line"></span><br><span class="line">  if ( x !== -1 &amp;&amp; y !== -1  &amp;&amp; ( this._mouseState.lastX !== x || this._mouseState.lastY !== y ) ) &#123;</span><br><span class="line">    this._mouseState.lastX = x;</span><br><span class="line">    this._mouseState.lastY = y;</span><br><span class="line">    if ( this.life.isAlive( x, y ) ) &#123;</span><br><span class="line">      this.life.killAt( x, y );</span><br><span class="line">      this.grid.drawDeadCellAt( x, y );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.life.aliveAt( x, y );</span><br><span class="line">      this.grid.drawAliveCellAt( x, y );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概意思就是先将鼠标的位置转化为单元格位置，再反置此单元格细胞的状态。记录下 <code>lastX</code> 和 <code>lastY</code> 是为了不会循环反置，一定要有坐标变化才反置。</p><p>接下来就是将那三个函数绑定在事件上。新增 <code>_setupLinsteners</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_setupLinsteners () &#123;</span><br><span class="line">  this.grid.on( &apos;mousedown&apos;, e =&gt; this._onMouseDown( e );</span><br><span class="line">  this.grid.on( &apos;mousemove&apos;, e =&gt; this._onMouseMove( e );</span><br><span class="line">  this.grid.on( &apos;mouseup&apos;, e =&gt; this._onMouseUp( e );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然使用了箭头函数优雅地绑定了 <code>this</code> 的值，但是这样写并不好，因为没办法解绑了，容易造成内存泄漏。改一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_setupLinsteners () &#123;</span><br><span class="line">  this._boundMethod[&apos;_onMouseDown&apos;] = e =&gt; this._onMouseDown( e );</span><br><span class="line">  this._boundMethod[&apos;_onMouseMove&apos;] = e =&gt; this._onMouseMove( e );</span><br><span class="line">  this._boundMethod[&apos;_onMouseUp&apos;] = e =&gt; this._onMouseUp( e );</span><br><span class="line"></span><br><span class="line">  this.grid.on( &apos;mousedown&apos;, this._boundMethod[&apos;_onMouseDown&apos;] );</span><br><span class="line">  this.grid.on( &apos;mousemove&apos;, this._boundMethod[&apos;_onMouseMove&apos;] );</span><br><span class="line">  this.grid.on( &apos;mouseup&apos;, this._boundMethod[&apos;_onMouseUp&apos;] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_teardownLinsteners () &#123;</span><br><span class="line">  this.grid.off( &apos;mousedown&apos;, this._boundMethod[&apos;_onMouseDown&apos;] );</span><br><span class="line">  this.grid.off( &apos;mousemove&apos;, this._boundMethod[&apos;_onMouseMove&apos;] );</span><br><span class="line">  this.grid.off( &apos;mouseup&apos;, this._boundMethod[&apos;_onMouseUp&apos;] );</span><br><span class="line"></span><br><span class="line">  this._boundMethod = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将匿名函数的引用保存起来就能解绑了。</p><p>最后给个 demo 吧。或者玩玩<a href="https://exoticknight.github.io/gol.js/" target="_blank" rel="noopener">在线 demo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Game of Life&lt;/title&gt;</span><br><span class="line">  &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;canvas id=&quot;grid&quot; width=&quot;1000&quot; height=&quot;500&quot; style=&quot;border:1px solid&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;button onclick=&quot;test()&quot;&gt;init&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.step()&quot;&gt;setp&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.run()&quot;&gt;run&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.stop()&quot;&gt;stop&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.pause()&quot;&gt;pause&lt;/button&gt;</span><br><span class="line">  &lt;button onclick=&quot;g.resume()&quot;&gt;resume&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">var options = &#123;</span><br><span class="line">  displayScheme: &#123;</span><br><span class="line">    borderWidth: 1,</span><br><span class="line">    cellWidth: 4</span><br><span class="line">  &#125;,</span><br><span class="line">  colorScheme: &#123;</span><br><span class="line">    aliveColor: &apos;000000&apos;,</span><br><span class="line">    deadColor: &apos;efefef&apos;,</span><br><span class="line">    worldColor: &apos;ffffff&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var g=GOL.createGame(document.getElementById(&apos;grid&apos;), 100, 200, options);</span><br><span class="line">function test()&#123;</span><br><span class="line">  g.init([[10,10],[11,10],[10,11],[13,12],[12,13],[13,13]]);</span><br><span class="line">  g.step();</span><br><span class="line">&#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/exoticknight/gol.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
      <category term=" - javascript - ECMAScript6" scheme="https://www.e10t.net/tags/javascript-ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>《Understanding ECMAScript 6》笔记</title>
    <link href="https://www.e10t.net/2015/10/21/understanding-ecmascript6-note/"/>
    <id>https://www.e10t.net/2015/10/21/understanding-ecmascript6-note/</id>
    <published>2015-10-21T14:17:05.000Z</published>
    <updated>2015-11-06T06:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在线免费阅读：<a href="https://leanpub.com/understandinges6/read/" target="_blank" rel="noopener">https://leanpub.com/understandinges6/read/</a></p></blockquote><blockquote><p>部分代码使用原书，代码版权归原书所有</p></blockquote><p><a name="catalogue"></a></p><ol><li><a href="#block-bindings">块级绑定（Block Bindings）</a></li><li><a href="#string">字符串</a></li><li><a href="#regex">正则</a></li><li><a href="#template-strings">字符串模板（template strings）</a></li><li><a href="#tagged-templates">标签模板（tagged templates）</a></li><li><a href="#function">函数</a></li><li><a href="#object">对象</a></li><li><a href="#destructuring">解构（Destructuring）</a></li><li><a href="#symbols">Symbols</a></li><li><a href="#generators">生成器（Generators）</a></li><li><a href="#iterators">迭代器（Iterators）</a></li><li><a href="#class">类</a></li><li><a href="#promises">Promises</a></li><li><a href="#modules">模块（Modules）</a></li><li><a href="#miscellaneous">杂七杂八</a></li></ol><p><a name="block-bindings"></a></p><p>##块级绑定（Block Bindings）<a href="#catalogue">↑</a></p><p>###let</p><p>块级{}中有效</p><p>同块级不可重复声明</p><p>没有变量提升</p><blockquote><p>块级会形成暂时性死区（TDZ，Temporal Dead Zone）</p></blockquote><p>###const</p><p>基本和 <code>let</code> 相同，值不可修改</p><blockquote><p><code>let</code> 和 <code>const</code> 最好不要在全局下使用</p></blockquote><p><a name="string"></a></p><p>##字符串<a href="#catalogue">↑</a></p><p>###unicode 支持更好</p><p>###新增部分函数，支持双字节</p><p><code>codePointAt</code>，双字节版的 <code>charCodeAt</code>，得到字符 unicode</p><p><code>fromCodePoint</code>，双字节版的 <code>fromCharCode</code>，从 unicode 得出字符</p><p><code>includes</code>，包含某字符串</p><p><code>startsWith</code>，以某字符串开始</p><p><code>endsWith</code>，以某字符串结束</p><p><code>repeat</code>，重复字符串</p><p><code>normalize</code>，unicode 正规化，举个例子：两个 unicode 字符合成一个</p><p><a name="regex"></a></p><p>##正则<a href="#catalogue">↑</a></p><p>###新增标志 <code>u</code></p><p>正则识别 unicode 字符</p><p>###新增标志 <code>y</code></p><p>sticky，部分浏览器早就实现了</p><p><a name="template-strings"></a></p><p>##字符串模板（template strings）<a href="#catalogue">↑</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line">let s = `$&#123;a&#125; $&#123;a + b&#125;`  // &apos;1 3&apos;</span><br></pre></td></tr></table></figure><p><a name="tagged-templates"></a></p><p>##标签模板（tagged templates）<a href="#catalogue">↑</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">function tag ( strings, ...values ) &#123;</span><br><span class="line">  console.log( strings )</span><br><span class="line">  console.log( values )</span><br><span class="line">  return values[0]</span><br><span class="line">&#125;</span><br><span class="line">let s = tag`a $&#123;a&#125;`  // &apos;a 1&apos;</span><br><span class="line">// [&quot;a &quot;, &quot;&quot;, raw: Array[2]]</span><br><span class="line">// [1]</span><br></pre></td></tr></table></figure><p><a name="function"></a></p><p>##函数<a href="#catalogue">↑</a></p><p>###默认参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo ( bar = 1 ) &#123;</span><br><span class="line">  console.log( bar )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###剩余参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo ( bar, ...rest ) &#123;  // ✓</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo ( bar, ...rest, last ) &#123;  // ×</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###函数属性 name</p><p>各种例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">console.log( doSomething.name );          // &quot;doSomething&quot;</span><br><span class="line"></span><br><span class="line">var doAnotherThing = function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line">console.log( doAnotherThing.name );       // &quot;doAnotherThing&quot;</span><br><span class="line"></span><br><span class="line">var doSomethingAgain = function doSomethingElse () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line">console.log( doSomethingAgain.name );      // &quot;doSomethingElse&quot;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    get firstName () &#123;</span><br><span class="line">        return &quot;Nicholas&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        console.log( this.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log( person.sayName.name );   // &quot;sayName&quot;</span><br><span class="line">console.log( person.firstName.name ); // &quot;get firstName&quot;</span><br><span class="line"></span><br><span class="line">console.log( doSomething.bind().name );   // &quot;bound doSomething&quot;</span><br><span class="line"></span><br><span class="line">console.log( ( new Function() ).name );     // &quot;anonymous&quot;</span><br></pre></td></tr></table></figure><p>###new.target</p><p>避免了很多使用 <code>new</code> 的坑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Foo () &#123;</span><br><span class="line">  if ( typeof new.target !== &quot;undefined&quot; ) &#123;</span><br><span class="line">    console.log( &apos;good&apos; );  // using new</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error( &apos;You must use new with Person.&apos; )  // not using new</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = new Foo();  // good</span><br><span class="line">foo = Foo.call( foo );  // error!</span><br></pre></td></tr></table></figure><p>###块级函数</p><p>块级中可定义函数</p><p>###箭头函数</p><p><code>this</code>, <code>super</code>, <code>arguments</code> 和 <code>new.target</code> 的值都在定义函数时绑定而非运行时绑定</p><p>不可 <code>new</code></p><p>不可改变 <code>this</code> 的值</p><p>没有 <code>arguments</code></p><blockquote><p>跟普通函数一样拥有 name 属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo = value =&gt; value;  // input value, output value</span><br><span class="line">var foo = () =&gt; &#123;&#125;;</span><br><span class="line">var foo = ( x, y ) =&gt; x + y;</span><br><span class="line">var foo = id =&gt; (&#123; x: &apos;x&apos; &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// this 的绑定</span><br><span class="line">var foo = &#123;</span><br><span class="line">  init: function () &#123;</span><br><span class="line">    document.addEventListener( &apos;click&apos;, (function ( e ) &#123;</span><br><span class="line">      console.log( e.type );</span><br><span class="line">    &#125;).bind( this ), false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ------------------------</span><br><span class="line"></span><br><span class="line">var foo = &#123;</span><br><span class="line">  init: function () &#123;</span><br><span class="line">    document.addEventListener( &apos;click&apos;, e =&gt; &#123;console.log( e.type )&#125;, false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###立即调用函数表达式（Immediately-Invoked Function Expressions (IIFEs)）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let foo = function ( s ) &#123;</span><br><span class="line">  console.log( s );</span><br><span class="line">&#125;( &apos;text&apos; )  // text</span><br><span class="line"></span><br><span class="line">// -------------------------</span><br><span class="line"></span><br><span class="line">let foo = ( s =&gt; &#123;</span><br><span class="line">  console.log( s );</span><br><span class="line">&#125;)( &apos;text&apos; )  // text</span><br></pre></td></tr></table></figure><p>###新增尾递归优化</p><p><a name="object"></a></p><p>##对象<a href="#catalogue">↑</a></p><p>###对象字面属性值简写（Property Initializer Shorthand）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo ( text ) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name  // name: name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###对象方法简写（Method Initializer Shorthand）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  bar () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###计算属性名语法</p><p>对象的属性可以使用中括号 <code>[]</code> 表示需要「被计算」，结果转换为字符串作为属性名使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = function () &#123;&#125;</span><br><span class="line">let foo = &#123;</span><br><span class="line">  a: &apos;text a&apos;,</span><br><span class="line">  [a]: &apos;function a&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log( foo[&apos;a&apos;] )  // text a</span><br><span class="line">console.log( foo[a] )  // function a</span><br></pre></td></tr></table></figure><p>###Object.is()</p><p>和经典的 <code>===</code> 几乎一样，区别在于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log( +0 === -0);             // true</span><br><span class="line">console.log( Object.is( +0, -0 ) );     // false</span><br><span class="line"></span><br><span class="line">console.log( NaN === NaN );           // false</span><br><span class="line">console.log( Object.is( NaN, NaN ) );   // true</span><br></pre></td></tr></table></figure><p>###Object.assign()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.assign( target, ...source )</span><br></pre></td></tr></table></figure><p>读取源对象可列举的、自身的属性，将其赋值到目标对象上，覆盖旧属性，并非通常意义的复制。</p><p>###复制存取器属性</p><blockquote><p>此小节查询 MDN 后补充上</p></blockquote><p>使用 <code>Object.getOwnPropertyDescriptor(source, key)</code> 读取，使用 <code>Object.defineProperties</code> 定义。</p><p>###属性允许重复定义</p><p>属性以最后一个定义的值为准</p><p>###修改原型</p><p><code>Object.getPrototypeOf</code>，得到原型</p><p><code>Object.setPrototypeOf</code>，设置原型</p><p>###super</p><p>用以访问对象的 prototype</p><p><a name="destructuring"></a></p><p>##解构（Destructuring）<a href="#catalogue">↑</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var &#123;a, b: &#123; c, d &#125;&#125; = c</span><br><span class="line">( &#123;a, b: &#123; c, d &#125;&#125; = c )</span><br><span class="line"></span><br><span class="line">var [a, [b, c]] = d</span><br><span class="line">var [a, , [b, c]] = d  // 跳过一个</span><br><span class="line"></span><br><span class="line">function foo ( &#123; bar1, bar2 &#125; = &#123;&#125; ) &#123;</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解构可以有默认值，但只会在需要的时候求值。</p><p><a href="http://www.2ality.com/2015/01/es6-destructuring.html" target="_blank" rel="noopener">2ality</a> 有更详细清晰的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let &#123;prop: y=someFunc()&#125; = someValue;</span><br><span class="line"></span><br><span class="line">let x, y;</span><br><span class="line">[x=3, y=x] = [];     // x=3; y=3</span><br><span class="line">[x=3, y=x] = [7];    // x=7; y=7</span><br><span class="line">[x=3, y=x] = [7, 2]; // x=7; y=2</span><br></pre></td></tr></table></figure><p><a name="symbols"></a></p><p>##Symbols（不知道如何翻译，是第七种原始类型）<a href="#catalogue">↑</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var foo = Symbol()</span><br><span class="line">var foo = Symbol( &apos;bar&apos; )</span><br></pre></td></tr></table></figure><p><code>Symbol( &#39;description&#39; )</code> 生成局部 Symbol，即使 <code>description</code> 相同生成的 Symbol 也不一样</p><p><code>Symbol.for( &#39;description&#39; )</code> 生成全局 Symbol，<code>description</code> 相同则 Symbol 相同</p><p>###获取对象的 Symbol 数组</p><p><code>Object.getOwnPropertySymbols( object )</code></p><p>###强制转换 Symbol 为 String</p><blockquote><p>原书本节未完成</p></blockquote><p>###有名的预定义 Symbol</p><blockquote><p>原书本节大部分未完成</p></blockquote><p><a name="generators"></a></p><p>##生成器（Generators）<a href="#catalogue">↑</a></p><p>生成迭代器的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function *createIterator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  *createIterator ( items ) &#123;</span><br><span class="line">    for ( let i=0; i &lt; items.length; i++ ) &#123;</span><br><span class="line">      yield items[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let iterator = o.createIterator( [1, 2, 3] );</span><br></pre></td></tr></table></figure><p><a name="iterators"></a></p><p>##迭代器（Iterators）<a href="#catalogue">↑</a></p><p>###for-of 语法</p><p>数组、字符串、映射（Map）、集合（Set）和元素数组（NodeList）都可迭代（iterable），可使用 for-of 语法</p><p>###得到内置迭代器</p><p>Symbol.iterator 指向得到迭代器的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let values = [1, 2, 3];</span><br><span class="line">let iterator = values[Symbol.iterator]();</span><br><span class="line">iterator.next();  // 1</span><br></pre></td></tr></table></figure><p>###自定义迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let collection = &#123;</span><br><span class="line">  items: [],</span><br><span class="line">  *[Symbol.iterator]() &#123;</span><br><span class="line">    yield *this.items.values();  // `yield *` 语法，委托了数组 `items` 的内置迭代器</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###对象、数组、映射、集合都具有的默认迭代器</p><p><code>ertries()</code>，返回键值对迭代器</p><p><code>keys()</code>，返回键迭代器</p><p><code>values()</code>，返回值迭代器</p><p>###字符串迭代器</p><p>通过 <code>[]</code> 的访问是 code unit 方式</p><p>通过迭代器则是字符方式（几乎是，某些 unicode 支持不足）</p><p>###元素数组（NodeList）迭代器</p><p>返回的是数组中的单个元素</p><p>###向迭代器传参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function *foo () &#123;</span><br><span class="line">  let bar = yield 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let it = foo()</span><br><span class="line">console.log( it.next() )  // Object &#123;value: 1, done: false&#125;，执行语句 `yield 1` 然后暂停</span><br><span class="line">console.log( it.next( 2 ) )  // Object &#123;value: undefined, done: true&#125;，将 2 作为 `yield 1` 的返回值，</span><br><span class="line">                             // 迭代器内部继续执行语句 `let bar = 2`，</span><br><span class="line">                             // 之后执行完毕，无返回值，`value` 为 `undefined`，`done` 为 `true`</span><br><span class="line">console.log( it.next() )  // Object &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>###生成器使用 return 提前返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function *createIterator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  return 42;</span><br><span class="line">  yield 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iterator = createIterator();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 42, done: true &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></pre></td></tr></table></figure><p>###委托生成器</p><p>使用 <code>yield *</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function *createNumberIterator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *createRepeatingIterator(count) &#123;</span><br><span class="line">  for (let i=0; i &lt; count; i++) &#123;</span><br><span class="line">    yield &quot;repeat&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *createCombinedIterator() &#123;</span><br><span class="line">  let result = yield *createNumberIterator();</span><br><span class="line">  yield *createRepeatingIterator(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var iterator = createCombinedIterator();</span><br><span class="line"></span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: 2, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: &quot;repeat&quot;, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: &quot;repeat&quot;, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: &quot;repeat&quot;, done: false &#125;&quot;</span><br><span class="line">console.log(iterator.next());           // &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></pre></td></tr></table></figure><p>可以 <code>yield *&quot;string&quot;</code>，会调用字符串的默认迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function *foo () &#123;</span><br><span class="line">  yield * &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">let it = foo()</span><br><span class="line">console.log( it.next() )  // Object &#123;value: &quot;h&quot;, done: false&#125;</span><br><span class="line">console.log( it.next() )  // Object &#123;value: &quot;e&quot;, done: false&#125;</span><br></pre></td></tr></table></figure><p>###异步任务调度</p><p>以下是书中的例子，写得并不好，变量 <code>task</code> 的管理容易出问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">var task;</span><br><span class="line"></span><br><span class="line">function readConfigFile() &#123;</span><br><span class="line">    fs.readFile(&quot;config.json&quot;, function(err, contents) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            task.throw(err);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            task.next(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function *init() &#123;</span><br><span class="line">    var contents = yield readConfigFile();</span><br><span class="line">    doSomethingWith(contents);</span><br><span class="line">    console.log(&quot;Done&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task = init();</span><br><span class="line">task.next();</span><br></pre></td></tr></table></figure><p><a name="class"></a></p><p>##类<a href="#catalogue">↑</a></p><p>###类声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line">  // 相当于构造函数</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  // 相当于 foo.prototype.bar</span><br><span class="line">  bar () &#123;</span><br><span class="line">    console.log( this.name );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的属性最好都在构造函数里面创建。</p><p>类声明本质上就是以前的函数声明，除了以下有所不同：</p><ol><li>类声明不会像函数声明那样被提升</li><li>类内部的代码全部以 <code>strict mode</code> 运行</li><li>所有方法都是不可列举的，相当于使用了 <code>Object.defineProperty()</code></li><li>不使用 <code>new</code> 会抛异常</li><li>以类名命名方法来覆盖类名会抛异常（类名对于类内部来说是以 <code>const</code> 定义的，对于外部则不是）</li></ol><p>###类表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let foo = class &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let foo = class foo2 &#123;&#125;  // foo === foo2</span><br></pre></td></tr></table></figure><p>匿名类作为参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFoo ( c ) &#123;</span><br><span class="line">  return new c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createFoo( class &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>立即调用类表达式（有点像立即调用函数表达式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let foo = new class &#123;</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;( &apos;foo&apos; )</span><br></pre></td></tr></table></figure><p>###存取器属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get className () &#123;</span><br><span class="line">    return &apos;class &apos; + this.name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set className ( value ) &#123;</span><br><span class="line">    this.name = &apos;class&apos; + value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###静态成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class foo &#123;</span><br><span class="line">  constructor ( name ) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 相当于 foo.prototype.bar</span><br><span class="line">  bar () &#123;</span><br><span class="line">    console.log( this.name )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 相当于 foo.staticBar</span><br><span class="line">  static staticBar () &#123;</span><br><span class="line">    console.log( this.name )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // get / set 也可以用</span><br><span class="line">  static get barName () &#123;</span><br><span class="line">    return &apos;bar&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态成员同样不可列举</p></blockquote><p>###派生类</p><p>比起 ECMAScript5，ECMAScript6 的派生方便了很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">  constructor ( length, width ) &#123;</span><br><span class="line">    this.length = length;</span><br><span class="line">    this.width = width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getArea () &#123;</span><br><span class="line">    return this.length * this.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  constructor ( length ) &#123;</span><br><span class="line">    super( length, length );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在派生类的构造函数中，调用 <code>super</code> 是必须的。如果连构造函数都没有，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  // 无构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 相当于</span><br><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  constructor ( ...args ) &#123;</span><br><span class="line">    super( ...args )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>只能在派生类中用 <code>super()</code></li><li>使用 <code>this</code> 前必先调用 <code>super()</code> 来<strong>初始化</strong> <code>this</code></li><li>只有在构造函数返回一个对象的时候才可以不用 <code>super()</code></li></ol></blockquote><p>###类方法</p><p>覆盖、隐藏父类方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  constructor ( length ) &#123;</span><br><span class="line">    super( length, length );</span><br><span class="line">  &#125;</span><br><span class="line">  getArea () &#123;</span><br><span class="line">    return this.length * this.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然可以使用 <code>super</code> 调用父类方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">    constructor ( length ) &#123;</span><br><span class="line">        super( length, length );</span><br><span class="line">    &#125;</span><br><span class="line">    getArea () &#123;</span><br><span class="line">        return super.getArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类方法没有 <code>[[Construct]]</code> 这个内部方法，所以不能被 <code>new</code>。（[什么是<code>[[Construct]]</code>](<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2)）" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2)）</a></p><p>###静态成员</p><p>相当于 ES5 中定义在构造函数上的方法（注意不是定义在构造函数的原型上），派生类显然也能调用</p><p>###extends 关键字后面可以使用表达式</p><p>除了 <code>null</code> 和生成器函数外</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 使用函数</span><br><span class="line">function base () &#123;&#125;</span><br><span class="line">class foo extends base &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 使用表达式</span><br><span class="line">function base () &#123;&#125;</span><br><span class="line">function getBase () &#123;</span><br><span class="line">  return base</span><br><span class="line">&#125;</span><br><span class="line">class foo extends getBase() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 混合模式（多继承？!）</span><br><span class="line">let AMinin = &#123;</span><br><span class="line">  aF = function () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let BMinin = &#123;</span><br><span class="line">  bF = function () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">function mixin ( ...mixins ) &#123;</span><br><span class="line">  var base = function () &#123;&#125;</span><br><span class="line">  Object.assign( base.prototype, ...mixins )</span><br><span class="line">  return base</span><br><span class="line">&#125;</span><br><span class="line">class foo extends mixin( AMinin, BMinin ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 内置类型</span><br><span class="line">class foo extends Array &#123;&#125;</span><br><span class="line">class foo extends String &#123;&#125;</span><br></pre></td></tr></table></figure><p>###new.target</p><p>能够得知类的调用状态，应用例如：阻止抽象类被实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    if (new.target === Shape) &#123;</span><br><span class="line">      throw new Error(&quot;This class cannot be instantiated directly.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="promises"></a></p><p>##Promises<a href="#catalogue">↑</a></p><p>Promise 是老朋友了，所以没有什么好记录的，就记一下语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise( function ( resolve, reject ) &#123;</span><br><span class="line">    resolve( 42 );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let p2 = Promise.resolve( 42 );</span><br><span class="line"></span><br><span class="line">let p3 = Promise.reject( 43 );</span><br><span class="line"></span><br><span class="line">let p4 = Promise.all( [p1, p2, p3] );  // 等待所有 Promise 返回</span><br><span class="line"></span><br><span class="line">let p5 = Promise.race( [p1, p2, p3] );  // 最快的一个 Promise 返回就返回</span><br><span class="line"></span><br><span class="line">p4.then( function ( value ) &#123;</span><br><span class="line">    console.log( value );</span><br><span class="line">&#125;).catch( function ( value ) &#123;</span><br><span class="line">    console.log( value );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="modules"></a></p><p>##模块（Modules）<a href="#catalogue">↑</a></p><blockquote><p>注：本章的代码似乎有一些问题，基本参考 MDN 为准</p></blockquote><ol><li>模块中的代码自动以严格模式运行</li><li>模块中的顶层变量只是模块中顶层，并非全局顶层</li><li>顶层中的 <code>this</code> 的值为 <code>undefined</code></li><li>代码中不允许 HTML 风格的注释</li><li>模块必须有导出的东西</li></ol><p>###基本导入导出</p><p>直接使用原书代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 导出数据</span><br><span class="line">export var color = &quot;red&quot;;</span><br><span class="line">export let name = &quot;Nicholas&quot;;</span><br><span class="line">export const magicNumber = 7;</span><br><span class="line"></span><br><span class="line">// 导出函数</span><br><span class="line">export function sum(num1, num2) &#123;</span><br><span class="line">    return num1 + num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export class Rectangle &#123;</span><br><span class="line">    constructor(length, width) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出引用</span><br><span class="line">function multiply(num1, num2) &#123;</span><br><span class="line">    return num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line">export multiply;</span><br><span class="line"></span><br><span class="line">// 默认导出</span><br><span class="line">export default function () &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// export as</span><br><span class="line">export &#123; multiply as foo &#125;</span><br></pre></td></tr></table></figure><ol><li>除非使用 <code>default</code> 语法，否则函数和类都不能使用匿名</li><li><code>export</code> 只能用在顶层中</li></ol><p><code>as</code> 和 <code>default</code> 语法的情况，给出一个来自 <a href="http://www.2ality.com/2015/07/es6-module-exports.html" target="_blank" rel="noopener">2ality</a> 的表格</p><table><thead><tr><th>Statement</th><th>Local name</th><th>Export name</th></tr></thead><tbody><tr><td>export {v as x};</td><td>‘v’</td><td>‘x’</td></tr><tr><td>export default function f() {}</td><td>‘f’</td><td>‘default’</td></tr><tr><td>export default function () {}</td><td>‘<em>default</em>‘</td><td>‘default’</td></tr><tr><td>export default 123;</td><td>‘<em>default</em>‘</td><td>‘default’</td></tr></tbody></table><p>可以看出，所谓的默认导出其实就是用了 <code>default</code> 作为名字罢了。</p><p>还能够将其他模块重新导出</p><table><thead><tr><th>Statement</th><th>Module</th><th>Import name</th><th>Export name</th></tr></thead><tbody><tr><td>export {v} from ‘mod’;</td><td>‘mod’</td><td>‘v’</td><td>‘v’</td></tr><tr><td>export {v as x} from ‘mod’;</td><td>‘mod’</td><td>‘v’</td><td>‘x’</td></tr><tr><td>export * from ‘mod’;</td><td>‘mod’</td><td>‘*’</td><td>null</td></tr></tbody></table><p>导入有很多方法，基本使用到的其实只有几种，以下来自 MDN：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import name from &quot;module-name&quot;;</span><br><span class="line">import * as name from &quot;module-name&quot;;</span><br><span class="line">import &#123; member &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 &#125; from &quot;module-name&quot;;</span><br><span class="line">import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;</span><br><span class="line">import defaultMember, * as alias from &quot;module-name&quot;;</span><br><span class="line">import defaultMember from &quot;module-name&quot;;</span><br><span class="line">import &quot;module-name&quot;;</span><br></pre></td></tr></table></figure><p>最后那种导入是相当于将代码执行了一次。通常可以用来做 <code>polyfills</code> 和 <code>shims</code>。</p><p><a name="miscellaneous"></a></p><p>##杂七杂八<a href="#catalogue">↑</a></p><p><code>Number.isInteger</code>，判断整数</p><p><code>Number.isSafeInteger</code>，判断是否是有效整数</p><p>Math 中加入很多函数，例如双曲正弦、双曲余弦之类的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在线免费阅读：&lt;a href=&quot;https://leanpub.com/understandinges6/read/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leanpub.com/understanding
      
    
    </summary>
    
    
      <category term=" - javascript - ECMAScript6 - note" scheme="https://www.e10t.net/tags/javascript-ECMAScript6-note/"/>
    
  </entry>
  
  <entry>
    <title>mocha + chai + Travis CI + Codecov 使用流程</title>
    <link href="https://www.e10t.net/2015/09/24/mocha-chai-travis-ci-codecov-workflow/"/>
    <id>https://www.e10t.net/2015/09/24/mocha-chai-travis-ci-codecov-workflow/</id>
    <published>2015-09-24T15:29:00.000Z</published>
    <updated>2015-09-24T15:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>###<a href="https://mochajs.org/" target="_blank" rel="noopener">mocha</a><br>a feature-rich JavaScript test framework running on Node.js and the browser</p><p>###<a href="http://chaijs.com/" target="_blank" rel="noopener">chai</a><br>a BDD / TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework</p><p>###<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a><br>Free continuous integration platform for GitHub projects</p><p>###<a href="https://codecov.io/" target="_blank" rel="noopener">Codecov</a><br>Continuous Code Coverage</p><p>##编写测试</p><p>简单来说，就是使用 mocha 作为测试框架，chai 作为断言库，将项目交给 Travis CI 做自动测试，交给 Codecov 做覆盖率测试。</p><p>以我自己的项目 <a href="https://github.com/exoticknight/simpleTemplate.js" target="_blank" rel="noopener">simpleTemplate.js</a> 为例。</p><p>先给项目装上 mocha 和 chai。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mocha chai --save-dev</span><br></pre></td></tr></table></figure><p>在 <code>package.json</code> 文件中添加测试脚本命令行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;mocha&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目根目录新建文件 <code>test.js</code>。</p><p>引入 chai 以及三个要测试的库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var expect = require( &apos;chai&apos; ).expect;</span><br><span class="line"></span><br><span class="line">var bare = require( &apos;./simpleTemplate.bare.js&apos; ),</span><br><span class="line">    normal = require( &apos;./simpleTemplate.normal.js&apos; ),</span><br><span class="line">    advanced = require( &apos;./simpleTemplate.advanced.js&apos; );</span><br></pre></td></tr></table></figure><p>定义必需的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var testData = &#123;</span><br><span class="line">    &apos;text1&apos;: &apos;mocha tastes good, chai tastes good too.&apos;,</span><br><span class="line">    &apos;html&apos;: &apos;&lt;hr&gt;&apos;,</span><br><span class="line">    &apos;list&apos;: [1, 2, 3],</span><br><span class="line">    &apos;objectList&apos;: [</span><br><span class="line">        &#123; &apos;name&apos;: &apos;a&apos; &#125;,</span><br><span class="line">        &#123; &apos;name&apos;: &apos;b&apos; &#125;,</span><br><span class="line">        &#123; &apos;name&apos;: &apos;c&apos; &#125;</span><br><span class="line">    ],</span><br><span class="line">    &apos;obj&apos;: &#123; &apos;name&apos;: &apos;obj&apos; &#125;,</span><br><span class="line">    &apos;boolFalse&apos;: false,</span><br><span class="line">    &apos;boolTrue&apos;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mocha 用起来其实也不复杂，常用的就是使用 <code>describe</code> 定义一个项目，使用 <code>it</code> 来执行一项测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe( &apos;bare&apos;, function () &#123;</span><br><span class="line">    describe( &apos;string template&apos;, function () &#123;</span><br><span class="line">        it( &apos;should output correct string&apos;, function () &#123;</span><br><span class="line">            var template = bare( &apos;&lt;p&gt;&#123;=text1&#125;&lt;/p&gt;&apos; );</span><br><span class="line"></span><br><span class="line">            expect( template.fill( testData ).render() ).to.equal( &apos;&lt;p&gt;mocha tastes good, chai tastes good too.&lt;/p&gt;&apos; );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里就是定义了一个 <code>bare</code> 项，里面再定义一个 <code>string template</code> 项，然后在 <code>it</code> 的回调函数中写断言，第一个参数可以写上断言描述。如果断言失败，测试就会失败。</p><p>OK，执行 <code>npm test</code>，可以看到结果输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bare</span><br><span class="line">  string template</span><br><span class="line">    √ should output correct string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 passing (9ms)</span><br></pre></td></tr></table></figure><p><code>expect(...).to.equal(...)</code> 就是用到了 chai 了。</p><p>剩下的测试编写就不再详述了，基本都一样。</p><p>##自动测试</p><p>去 Travis-CI 官网使用 github 帐号登录，开启对应项目的访问权限。</p><p>然后在 <code>package.json</code> 同目录（根目录）下，新建文件 <code>.travis.yml</code>，写入如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - &quot;0.12&quot;</span><br></pre></td></tr></table></figure><p><code>git push</code> 一次，再访问 Travis-CI，会发现已经给你显示出测试结果了。</p><p>那么好了，测试通过，何不贴个奖章 show off 一下呢？</p><p>在项目旁边有一个黑色加绿色的按钮，点一下，弹框中选择 markdown 格式，将代码贴进 <code>readme</code>，再 <code>git push</code>，去 github 的项目页一看，是不是高大上起来了呢？</p><p>##代码覆盖率</p><p>代码覆盖率其实也没必要到 100%，只要不是太低的值就可以了。</p><p>去 Codecov 官网使用 github 帐号登录，开启对应项目的访问权限。</p><p>然后在 <code>package.json</code> 同目录（根目录）下的 <code>.travis.yml</code> 加入如下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - CODECOV_TOKEN: your-uuid</span><br><span class="line">script:</span><br><span class="line">  - istanbul cover node_modules/mocha/bin/_mocha</span><br><span class="line">  - cat ./coverage/coverage.json | node_modules/codecov.io/bin/codecov.io.js</span><br></pre></td></tr></table></figure><p>your-uuid 替换成开启项目时生成的 <code>Repository Upload Token</code>。</p><p>继续 <code>git push</code> 一次，再访问 Codecov 就可以看到项目的代码覆盖率了。</p><p>照样里添加上 badge，点击右边齿轮的 <code>badge</code>，就可以得到 markdown 代码了。</p><p>##打完收工</p><p>以后每次 <code>push</code>，都会自动运行测试和代码率覆盖统计，去查看一下就知道代码有没有错误或者改进了。</p><p>参考文章：</p><p><a href="http://callmenick.com/post/basic-front-end-testing-with-mocha-chai" target="_blank" rel="noopener">Basic Front End Testing With Mocha &amp; Chai</a></p><p><a href="https://cnodejs.org/topic/5443b8342be2db9d42e8f685" target="_blank" rel="noopener">折腾 Coffee + mocha + Travis-CI 单元测试与覆盖率报告</a></p><p><a href="https://github.com/codecov/example-node" target="_blank" rel="noopener">Example Node with Codecov</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###&lt;a href=&quot;https://mochajs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mocha&lt;/a&gt;&lt;br&gt;a feature-rich JavaScript test framework running on Node.js
      
    
    </summary>
    
    
      <category term=" - javascript" scheme="https://www.e10t.net/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 3--文件组织结构和开发流程</title>
    <link href="https://www.e10t.net/2015/09/05/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/"/>
    <id>https://www.e10t.net/2015/09/05/build-application-with-angular-and-ng-material-based-on-electron-3-file-structure-and-workflow/</id>
    <published>2015-09-05T09:09:13.000Z</published>
    <updated>2015-09-05T09:10:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>##文件组织结构</p><p>良好的文件组织结构不仅能帮助我们更快地定位文件，更能配合开发工具形成流畅的开发流程，从而提高编程效率。</p><p>以下的目录和文件都放在存放应用的根目录 <code>app</code> 下。</p><p>###package.json</p><p>Electron 应用的配置文件，经常做 node 开发的人应该很熟悉了。稍微说明一下一些字段：</p><p><code>name</code>: 应用的名字，本项目就是 radioit 了</p><p><code>description</code>: 应用的描述</p><p><code>version</code>: 应用的版本号</p><p><code>author</code>: 作者名字</p><p><code>email</code>: 作者的邮箱</p><p>###main.js</p><p>Electron 应用的入口点，可以在 package.json 的 <code>main</code> 字段自定义</p><p>###node_modules/</p><p>node 库的目录，一般不用手动管理，而是使用 npm 来安装和卸载库。</p><p>###lib/</p><p>存放 node 模块的目录。</p><p>###src/</p><p>存放源代码的目录。</p><p>###src/css/</p><p>存放待编译的 css 代码，比如本项目用的 .styl 文件。</p><p>###src/modules/</p><p>存放浏览器端的 javascript 源代码。</p><p>因为使用 AngularJS，所以此目录的结构就照搬 AngularJS 项目的结构。</p><p>通常来说有两种：按 service / controller / directive 分目录存放，按功能模块存放。</p><p>本项目选择按功能模块存放。</p><p>###src/modules/entry.js</p><p>供 browserify 打包的入口点。最终浏览器端的 javascript 代码会打包成一个名为 <code>bundle.js</code> 的文件。</p><p>###static/css/</p><p>存放编译好的 CSS 文件。</p><p>###static/font/</p><p>存放字体文件。因为 Electron 可以访问本地文件，所以自定义字体也基本不需要考虑网络传输问题。</p><p>###static/image/</p><p>存放图片文件。</p><p>###static/js/</p><p>存放客户端的 javascript 库，比如 jQuery，underscore，AngularJS 等。</p><p>###static/js/bundle.js</p><p>browserify 编译 javascript 代码后输出的文件。</p><p>###static/view/</p><p>存放 HTML 模板文件或者包含 HTML 代码的文件。</p><p>##开发流程 – node 相关</p><p>有关 node 的开发，跟普通的项目并没有什么两样，需要什么库就直接使用 npm 安装，然后再代码中使用 <code>require</code> 就可以了。</p><p>然而虽然 Electron 为 webkit 内核提供了 <code>io.js</code> 的运行环境，但是最好还是避免在客户端（浏览器）的 javascript 代码内混杂需要 node 依赖的代码。换句话说，最好将需要 node 依赖的 javascript 代码和平常在网页中使用的 javascript 代码分开。这样做的好处是不会搞混相关的 API 和设计模式，毕竟 node 大部分时候都是用在服务端上的。</p><p>本项目将 node 相关的代码放在 <code>lib/</code> 目录下，负责应用的业务逻辑，其既有可能被主进程所用，也有可能被渲染进程所用。node 相关的代码不需要编译合并。编写时在目录下新建 <code>xxx.js</code> 文件，写好需要 exports 的内容，在其他文件中则使用 <code>require( &#39;./xxx.js&#39; )</code> 就可以了。</p><p>##开发流程 – 界面相关</p><p>因为界面的渲染采用 webkit 引擎，所以 javascript 的编写和网页开发没有分别。</p><p>在 <code>package.json</code> 的 <code>scripts</code> 字段中增加一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build:js&quot;: &quot;browserify src/modules/entry.js -o static/js/bundle.js&quot;</span><br></pre></td></tr></table></figure><p>然后在编写好 javascript 代码的时候，执行 <code>npm run build:js</code> 进行编译。</p><p>CSS 的编译则是加入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build:css&quot;: &quot;stylus -u nib src/css/app.styl -o static/css/app.css&quot;</span><br></pre></td></tr></table></figure><p>最后需要运行应用来测试，增加命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;test&quot;: &quot;electron main.js 2&gt;&amp;1 | silence-chromium&quot;,</span><br><span class="line">&quot;start&quot;: &quot;npm run build:js &amp;&amp; npm run build:css &amp;&amp; electron main.js 2&gt;&amp;1 | silence-chromium&quot;</span><br></pre></td></tr></table></figure><p>需要测试的时候使用 <code>npm run test</code>，需要运行则使用 <code>npm run start</code> 进行重新编译和运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##文件组织结构&lt;/p&gt;
&lt;p&gt;良好的文件组织结构不仅能帮助我们更快地定位文件，更能配合开发工具形成流畅的开发流程，从而提高编程效率。&lt;/p&gt;
&lt;p&gt;以下的目录和文件都放在存放应用的根目录 &lt;code&gt;app&lt;/code&gt; 下。&lt;/p&gt;
&lt;p&gt;###package.json
      
    
    </summary>
    
    
      <category term=" - javascript - angularjs - angular-material - electron" scheme="https://www.e10t.net/tags/javascript-angularjs-angular-material-electron/"/>
    
  </entry>
  
  <entry>
    <title>记一次奇怪的爬虫经历</title>
    <link href="https://www.e10t.net/2015/07/01/a-weird-experience-while-using-pyspider/"/>
    <id>https://www.e10t.net/2015/07/01/a-weird-experience-while-using-pyspider/</id>
    <published>2015-07-01T15:16:30.000Z</published>
    <updated>2015-07-01T15:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>##前言</p><p>由于某些原因，我需要去<del>爬</del>获取一些国家旅游景点的信息。</p><p>找到国家旅游局的网站，然后找到一个 5A 风景区目录。</p><p>网址：<a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=view&amp;resultType=5A" target="_blank" rel="noopener">http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=view&amp;resultType=5A</a></p><p>于是去 pyspider 的 <a href="http://demo.pyspider.org/" target="_blank" rel="noopener">demo</a> 页新建一个项目：<a href="http://demo.pyspider.org/debug/5stat" target="_blank" rel="noopener">5stat</a>，就去爬了。</p><p>##分析页面</p><p>网页比较特殊，看起来是用 dotnet 写的，翻页是按钮调用 js 代码实现的。跳转后还是同一个网址。</p><p>这里就要用到 pyspider 支持的页面载入后运行 js 脚本的功能。</p><p>先分析翻页按钮干了什么。</p><p>如下图，调用一个名为 <code>__doPostBack</code> 的函数。</p><p><img src="https://i.imgur.com/dMRNDZz.png" alt="__doPostBack"></p><p>在页面上寻找这个函数，看到函数体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var theForm = document.forms[&apos;form1&apos;];</span><br><span class="line">if (!theForm) &#123;</span><br><span class="line">    theForm = document.form1;</span><br><span class="line">&#125;</span><br><span class="line">function __doPostBack(eventTarget, eventArgument) &#123;</span><br><span class="line">    if (!theForm.onsubmit || (theForm.onsubmit() != false)) &#123;</span><br><span class="line">        theForm.__EVENTTARGET.value = eventTarget;</span><br><span class="line">        theForm.__EVENTARGUMENT.value = eventArgument;</span><br><span class="line">        theForm.submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数将 <code>theForm</code> 里面的 <code>__EVENTTARGET</code> 值设置为 <code>PageNavigator1$LnkBtnNext</code> 之后就提交了。</p><p>找到 <code>theForm</code> 对应的元素，看见有三个隐藏域， <code>__EVENTTARGET</code>、<code>__EVENTARGUMENT</code> 和 <code>__VIEWSTATE</code>。</p><p><img src="https://i.imgur.com/4Bl389k.png" alt="theForm"></p><p>附近还有一个隐藏域 <code>__EVENTVALIDATION</code>。看名字就觉得要提交。</p><p>于是试试只提交这三个值看看会不会报错。</p><p>在 chrome 上安装 postman 这个应用，打开。</p><p><img src="https://i.imgur.com/CwPvFET.png" alt="postman"></p><p>修改方式为 POST，填上地址和三个域的值，send。</p><p><img src="https://i.imgur.com/7G2dgUC.png" alt="postman result"></p><p>OK，返回了正确的页面，也就是可行了。</p><p>##爬虫脚本</p><p>嗯 pyspider 的爬虫脚本怎么写就不详述了，不会的看文档。</p><p>着重列出爬虫执行的 js 脚本的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;</span><br><span class="line">    var flag = &apos;y&apos;;</span><br><span class="line">    if ( document.querySelector(&apos;#PageNavigator1_LnkBtnNext&apos;).getAttribute(&apos;disabled&apos;) ) &#123;</span><br><span class="line">        flag = &apos;n&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return document.form1.__VIEWSTATE.value + &apos;~&apos; + document.form1.__EVENTVALIDATION.value + &apos;~&apos; + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来在回到爬虫脚本中的时候就能得到下一页跳转的参数了。</p><p>##奇怪的地方来了</p><p>因为 pyspider 的文档说明对于每个项目内的相同网址会忽略，于是按照教学提示给网址加了个 <code>#</code>。很明显这样的网址不会改变请求的参数（使用一些其他技术的情况下除外）。</p><blockquote><p>之后不再使用这个方法，因为 pyspider 判断是否同网址实质上是简单地将网址 md5 一下生成任务 id，以此来判断是否同一个爬虫任务。后来用的方法是直接重写任务 id 的生成。</p></blockquote><p>然而在爬下来的数据中却发现有除了旅游地点外的酒店信息。</p><p>原来同一个页面也有五星级饭店的信息。如下图，注意最后有一个 <code>#</code>。</p><p><img src="https://i.imgur.com/I0saHSE.png" alt="五星级饭店链接"></p><p>点击后跳转到一个网址：<a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94" target="_blank" rel="noopener">http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94</a> 的页面。</p><p><img src="https://i.imgur.com/RUe1IIX.png" alt="五星级饭店"></p><p>看起来跟旅游地点差不多，新建一个项目 <a href="http://demo.pyspider.org/debug/5hotel" target="_blank" rel="noopener">5hotel</a>，直接复制粘贴之前的代码，就是改了一下网址。</p><p>期间还将任务 id 的生成重写了一下，这样即使请求同一个网址也没问题了。</p><p>然而运行的结果却失败了。</p><p><img src="https://i.imgur.com/x8w8QsA.png" alt="failed"></p><p>在 content 中很明显看出页面获取不全，然而代码是直接复制的，页面也是相同结构的，为什么会出现这个问题呢？</p><p>然后我就被困扰了两天，接着就没在去管，盘算以后自己实现个爬虫再爬好了。</p><p>##转机</p><p>今天我再上去看，爬 5A 风景区的项目一直稳定运行。</p><p>五星级饭店的却还是无法抓取全部页面。</p><p>然后我鬼使神差地给网址加了一个 <code>#</code>。网址从：</p><p><a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94" target="_blank" rel="noopener">www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx?catalogType=hotel&amp;resultType=%u4E94</a></p><p>变成</p><p><a href="http://www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx#?catalogType=hotel&amp;resultType=%u4E94" target="_blank" rel="noopener">www.cnta.gov.cn:8000/Forms/TravelCatalog/TravelCatalogList.aspx#?catalogType=hotel&amp;resultType=%u4E94</a></p><p>然后就能爬了！！！</p><p>shenmegui？？？！！！</p><p><img src="https://i.imgur.com/nRP3znG.png" alt="success"></p><p>我也搞不清楚究竟是 pyspider 的问题还是 phantomjs 的问题还是 dotnet 的问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##前言&lt;/p&gt;
&lt;p&gt;由于某些原因，我需要去&lt;del&gt;爬&lt;/del&gt;获取一些国家旅游景点的信息。&lt;/p&gt;
&lt;p&gt;找到国家旅游局的网站，然后找到一个 5A 风景区目录。&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;http://www.cnta.gov.cn:8000/Forms
      
    
    </summary>
    
    
      <category term=" - python - pyspider" scheme="https://www.e10t.net/tags/python-pyspider/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 2--node 库的使用和抓取代码的编写</title>
    <link href="https://www.e10t.net/2015/06/29/build-application-with-angular-and-ng-material-based-on-electron-2-use-node-lib-and-code/"/>
    <id>https://www.e10t.net/2015/06/29/build-application-with-angular-and-ng-material-based-on-electron-2-use-node-lib-and-code/</id>
    <published>2015-06-29T08:11:33.000Z</published>
    <updated>2015-09-05T09:10:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>##使用 nodejs 的库</p><p>python 脚本的详细编写，请看之前的博文：<a href="http://blog.e10t.net/radioit-plan-animate-radio-script-radioitscript/" target="_blank" rel="noopener">radioit计划——动画广播辅助脚本radioitScript</a>。</p><p>需要用 node 实现脚本中的某些逻辑是获取和提取广播的信息，整合成 JSON 格式的数据。</p><p>而用一些库就能轻松做到。</p><p>###superagent</p><p><a href="https://github.com/visionmedia/superagent" target="_blank" rel="noopener">superagent</a> 是一个极其简单的 AJAX 库。</p><p>使用方法简单得令人发指。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var request = require( &apos;superagent&apos; );</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get( &apos;http://xxx.com&apos; )</span><br><span class="line">    .end( function ( err, res ) &#123;</span><br><span class="line">    // Do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还用介绍吗？不用了。</p><p>###bluebird</p><p><a href="https://github.com/petkaantonov/bluebird/" target="_blank" rel="noopener">bluebird</a> 是一个 Promise 库。</p><p>凡是类似 IO 的操作，必定需要异步。经典的解决方法是回调，然而是时候用 Promise 了！</p><p>bluebird 声称拥有无与伦比的速度。其实更实用的功能是它支持能够将一些本身是不支持 Promise 的库转化为支持 Promise 的库。</p><p>然而，要配合之前的 superagent，则需要另外一个库 <a href="https://github.com/KyleAMathews/superagent-bluebird-promise" target="_blank" rel="noopener">superagent-bluebird-promise</a>。superagent 本身不支持 Promise，从上面的代码来看就是使用回调的方法，这个库就是将 superagent 和 bluebird 融合在一起的“融合卡”。</p><p>使用的时候只需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require( &apos;bluebird&apos; );</span><br><span class="line">var request = require( &apos;superagent-bluebird-promise&apos; );</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get( &apos;http://xxxx.com&apos; )</span><br><span class="line">    .then( function ( res ) &#123;</span><br><span class="line">        // do something when resolved</span><br><span class="line">    &#125;, function ( err ) &#123;</span><br><span class="line">        // do something when rejected</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>立刻就可以使用上 <code>then</code> 了，方便吧。</p><p>###cherrio</p><p><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a> 是一个语法类似 jQuery，为服务端提供 jQuery 核心功能的库。这里用到的是它的 CSS 选择器功能。</p><p>代码同样很简单，使用过 jQuery 的人会倍感亲切。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var cheerio = require( &apos;cheerio&apos; ),</span><br><span class="line">    $ = cheerio.load( &apos;&lt;h2 class=&quot;title&quot;&gt;Hello world&lt;/h2&gt;&apos; );</span><br><span class="line"></span><br><span class="line">$( &apos;.title&apos; ).text(); // Hello world</span><br></pre></td></tr></table></figure><p>使用 cheerio 有比较推荐的做法就是添加上 <code>decodeEntities</code> 和 <code>lowerCaseAttributeNames</code> 这个两个 options 配置，能避免各种 HTML 文本的奇怪问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ = cheerio.load( HTMLtext, &#123;</span><br><span class="line">                    &apos;decodeEntities&apos;: true,</span><br><span class="line">                    &apos;lowerCaseAttributeNames&apos;: true</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>综上，四个库的混合使用例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require( &apos;bluebird&apos; );</span><br><span class="line">var request = require( &apos;superagent-bluebird-promise&apos; );</span><br><span class="line">var cheerio = require( &apos;cheerio&apos; );</span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get( &apos;http://xxxx.com&apos; )</span><br><span class="line">    .then( function ( res ) &#123;</span><br><span class="line">        var $, text;</span><br><span class="line">        $ = cheerio.load( res.text, &#123;</span><br><span class="line">                    &apos;decodeEntities&apos;: true,</span><br><span class="line">                    &apos;lowerCaseAttributeNames&apos;: true</span><br><span class="line">                &#125;);</span><br><span class="line">        text = $( &apos;p&apos; ).text();</span><br><span class="line">    &#125;, function ( err ) &#123;</span><br><span class="line">        console.log( err );</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>##编写逻辑</p><blockquote><p>npm 安装库的过程略。</p></blockquote><p>因为是信息整合，那么必定需要有一个统一的数据格式。于是先来确定数据格式。</p><p>广播站中所有广播的信息整合数据格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// data will be formated as a json object in following structure:</span><br><span class="line">// &#123;</span><br><span class="line">//     &apos;name&apos;: &apos;String, name of the channel&apos;,</span><br><span class="line">//     &apos;url&apos;: &apos;String, url of the channel&apos;,</span><br><span class="line">//     &apos;timestamp&apos;: &apos;Number, timestamp of this data&apos;,</span><br><span class="line">//     &apos;bangumi&apos;: &#123;</span><br><span class="line">//         &apos;mon&apos;: [</span><br><span class="line">//             &#123;</span><br><span class="line">//                 &apos;id&apos;: &apos;String, id of the bangumi&apos;,</span><br><span class="line">//                 &apos;homepage&apos;: &apos;URL, homepage of the bangumi&apos;,</span><br><span class="line">//                 &apos;name&apos;: &apos;String, name of the bangumi&apos;,</span><br><span class="line">//                 &apos;image&apos;: &apos;String, image url  of the bangumi, optional&apos;,</span><br><span class="line">//                 &apos;status&apos;: &apos;String, new / normal&apos;,</span><br><span class="line">//                 ...</span><br><span class="line">//             &#125;,</span><br><span class="line">//             &#123;...&#125;</span><br><span class="line">//         ],</span><br><span class="line">//         &apos;tue&apos;: [&#123;...&#125;,&#123;...&#125;],</span><br><span class="line">//         &apos;wed&apos;: [&#123;...&#125;,&#123;...&#125;],</span><br><span class="line">//         &apos;thu&apos;: [&#123;...&#125;,&#123;...&#125;],</span><br><span class="line">//         &apos;fri&apos;: [&#123;...&#125;,&#123;...&#125;],</span><br><span class="line">//         &apos;sat&apos;: [&#123;...&#125;,&#123;...&#125;],</span><br><span class="line">//         &apos;sun&apos;: [&#123;...&#125;,&#123;...&#125;],</span><br><span class="line">//         &apos;irr&apos;: [&#123;...&#125;,&#123;...&#125;],</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>单个广播的信息整合数据格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// data will be formated as a json object in following structure:</span><br><span class="line">// &#123;http://hibiki-radio.jp</span><br><span class="line">//     &apos;timestamp&apos;: &apos;Number&apos;,</span><br><span class="line">//     &apos;name&apos;: &apos;String, name of the bangumi&apos;,</span><br><span class="line">//     &apos;homepage&apos;: &apos;URL, homepage of the bangumi&apos;,</span><br><span class="line">//     &apos;description&apos;: &apos;String, description of the bangumi&apos;,</span><br><span class="line">//     &apos;title&apos;: &apos;String, title of the newest episode&apos;,</span><br><span class="line">//     &apos;comment&apos;: &apos;String, comment of the newest episode&apos;,</span><br><span class="line">//     &apos;schedule&apos;: &apos;String, schedule of the bangumi or the update date of the newest pisode&apos;,</span><br><span class="line">//     &apos;personality&apos;: &apos;String, personality of the bangumi&apos;,</span><br><span class="line">//     &apos;guest&apos;: &apos;String, guest of the newest episode&apos;,</span><br><span class="line">//     &apos;images&apos;: &apos;String Array, array of images&apos; url&apos;,</span><br><span class="line">//     &apos;audio&apos;: &apos;String, url of audio&apos;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>有了输出的数据格式，抓取信息的时候就能有的放失。</p><p>以<a href="http://hibiki-radio.jp" target="_blank" rel="noopener">響 - HiBiKi Radio Station -</a>为例。因为在之前编写脚本的时候已经得到了页面上信息的位置，所以可以直接应用在代码中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 一些固定的信息和变量</span><br><span class="line">var NAME = &apos;響 - HiBiKi Radio Station -&apos;;</span><br><span class="line">var HOST = &apos;http://hibiki-radio.jp&apos;;</span><br><span class="line"></span><br><span class="line">var URLs = &#123;</span><br><span class="line">    &apos;catalogue&apos;: &apos;http://hibiki-radio.jp/program&apos;,</span><br><span class="line">    &apos;bangumi&apos;: &apos;http://hibiki-radio.jp/description/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下开始获取广播站的广播。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 获取信息的对象</span><br><span class="line">var hibiki = &#123;</span><br><span class="line">    catalogueName: NAME,</span><br><span class="line">    host: HOST,</span><br><span class="line"></span><br><span class="line">    // 异步取得所有广播的基本信息，返回一个 promise 对象</span><br><span class="line">    getCatalogueAsync: function () &#123;</span><br><span class="line">        return request</span><br><span class="line">            .get( URLs.catalogue )</span><br><span class="line">            .then( function ( res ) &#123;</span><br><span class="line">                var $,</span><br><span class="line">                    days,</span><br><span class="line">                    bangumi,</span><br><span class="line">                    data;</span><br><span class="line"></span><br><span class="line">                days = &apos;mon tue wed thu fri sat sun irr&apos;.split( &apos; &apos; );</span><br><span class="line"></span><br><span class="line">                $ = cheerio.load( res.text, &#123;</span><br><span class="line">                    &apos;decodeEntities&apos;: true,</span><br><span class="line">                    &apos;lowerCaseAttributeNames&apos;: true</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // Extract html and structure data</span><br><span class="line">                // 准备数据结构</span><br><span class="line">                data = &#123;&#125;;</span><br><span class="line">                data.bangumi = &#123;&#125;;</span><br><span class="line">                days.forEach( function ( el ) &#123;</span><br><span class="line">                    data.bangumi[el] = [];</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                // Structure daily bangumis</span><br><span class="line">                // 一个 .hbkProgramTable 包含一天的广播</span><br><span class="line">                $( &apos;.hbkProgramTable&apos; ).each( function ( i, el ) &#123;</span><br><span class="line">                    var _;</span><br><span class="line"></span><br><span class="line">                    // 一个 .hbkProgramTitleNew 或 .hbkProgramTitle 为一个广播</span><br><span class="line">                    data.bangumi[days[i]] = $( this ).find( &apos;.hbkProgramTitleNew, .hbkProgramTitle&apos; ).map( function ( _, el ) &#123;</span><br><span class="line">                        _ = $( this );</span><br><span class="line"></span><br><span class="line">                        // 一个广播的基本信息</span><br><span class="line">                        return &#123;</span><br><span class="line">                            &apos;id&apos;: _.parent().attr( &apos;href&apos; ).slice( 35 ),</span><br><span class="line">                            &apos;homepage&apos;: _.parent().attr( &apos;href&apos; ),</span><br><span class="line">                            &apos;name&apos;: _.text(),</span><br><span class="line">                            &apos;image&apos;: _.prev().children().eq( 0 ).attr( &apos;src&apos; ),</span><br><span class="line">                            &apos;status&apos;: _.attr( &apos;class&apos; ) === &apos;hbkProgramTitleNew&apos; ? &apos;new&apos; : &apos;normal&apos;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;).get();</span><br><span class="line"></span><br><span class="line">                    _ = null;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // add extra data</span><br><span class="line">                data.name = NAME;</span><br><span class="line">                data.url = HOST;</span><br><span class="line">                data.timestamp = Date.now();</span><br><span class="line"></span><br><span class="line">                return data;</span><br><span class="line"></span><br><span class="line">            &#125;, function ( err ) &#123;</span><br><span class="line">                console.log( &apos;hibiki:get catalogue error: &apos; + err );</span><br><span class="line">                throw new Error( err );</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下开始获取某个广播的详细信息，函数定义在上面的对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">getBangumiAsync: function ( id ) &#123;</span><br><span class="line">    return request</span><br><span class="line">        .get( url.resolve( URLs.bangumi, id ) )</span><br><span class="line">        .then( function ( res ) &#123;</span><br><span class="line">            var $,</span><br><span class="line">                data;</span><br><span class="line"></span><br><span class="line">            $ = cheerio.load( res.text, &#123;</span><br><span class="line">                &apos;decodeEntities&apos;: true,</span><br><span class="line">                &apos;lowerCaseAttributeNames&apos;: true</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            // Extract html and structure data</span><br><span class="line">            // 某个广播详细页的信息提取，信息的位置在 python 脚本中已经确定好了</span><br><span class="line">            data = &#123;</span><br><span class="line">                &apos;timestamp&apos;: Date.now(),</span><br><span class="line">                &apos;name&apos;: $( &apos;title&apos; ).text().slice( 27, -5 ),</span><br><span class="line">                &apos;homepage&apos;: url.resolve( URLs.bangumi, id ),</span><br><span class="line">                &apos;description&apos;: $( &apos;table.hbkTextTable td:nth-of-type(1) div:nth-of-type(1)&apos; ).eq( 0 ).text().trim(),</span><br><span class="line">                &apos;title&apos;: $( &apos;table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(1) div&apos; ).eq( 0 ).text().trim(),</span><br><span class="line">                &apos;comment&apos;: $( &apos;table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(2) td&apos; ).eq( 0 ).text().trim(),</span><br><span class="line">                &apos;schedule&apos;: (function () &#123;</span><br><span class="line">                    var _, text;</span><br><span class="line">                    _ = $( &apos;table.hbkTextTable &gt; tr &gt; td:nth-of-type(2) &gt; div&apos; );</span><br><span class="line">                    if ( !( text = _.eq( -5 ).text().trim() ) ) &#123;</span><br><span class="line">                        text = _.eq( -3 ).text();</span><br><span class="line">                    &#125;</span><br><span class="line">                    return text;</span><br><span class="line">                &#125;)(),</span><br><span class="line">                &apos;update&apos;: $( &apos;.hbkDescriptonContents&apos; ).eq( -1 ).prev().prev().find( &apos;span&apos; ).eq( 0 ).text(),</span><br><span class="line">                &apos;personality&apos;: $( &apos;table.hbkTextTable td:nth-of-type(1) &gt; table table td:nth-of-type(2n) a&apos; ).map( function () &#123;return $( this ).text();&#125; ).get().join( &apos; &apos; ),</span><br><span class="line">                &apos;guest&apos;: &apos;&apos;,</span><br><span class="line">                &apos;images&apos;: $( &apos;table.hbkTextTable td:nth-of-type(1) div:nth-of-type(3) table:nth-of-type(2) td img&apos; ).map( function () &#123;return $( this ).attr( &apos;src&apos; );&#125;).get(),</span><br><span class="line">                &apos;audio&apos;: $( &apos;div.hbkDescriptonContents embed&apos; ).eq( -1 ).attr( &apos;src&apos; )</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            return data;</span><br><span class="line"></span><br><span class="line">        &#125;, function ( err ) &#123;</span><br><span class="line">            console.log( &apos;hibiki:get bangumi error: &apos; + err );</span><br><span class="line">            throw new Error( err );</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>代码看似很多，其实就是多了信息提取的部分，其他代码完全就是上一节中四个库的混合使用。</p><p>要注意的有一点，就是 promise 链中的 <code>then( fulfilledHandler, rejectedHandler )</code>。其中 <code>fulfilledHandler</code> 在最后需要使用 <code>return data;</code> 将数据传出去，而 <code>rejectedHandler</code> 也需要使用 <code>throw new Error( err );</code> 重新抛出错误，不然 promise 链中下一个函数将不会得到处理好的数据或者异常（因为已经处理掉了）。</p><p>最后别忘了将对象导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = hibiki;</span><br></pre></td></tr></table></figure><p>同理，另外两个广播站的代码基本都一样，不同的只是信息提取的部分。</p><p>###整合</p><p>对于取数据的调用者而言，是无需理会数据从哪来的，只需要知道使用什么 API 就够了。</p><p>再者，既然有“整合”之名，就要行“整合”之实。因此要将这三个或者日后出现的更多个广播站提取代码整合起来，只提供一个调用入口。</p><p>新建目录 <code>provider</code>，将三个广播站的脚本都放进去。</p><p>再新建一个 <code>provider.js</code> 文件，写入以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">var catalogue = &#123;</span><br><span class="line">    &apos;hibiki&apos;: require( &apos;./provider/hibiki.js&apos; ),</span><br><span class="line">    &apos;onsen&apos;: require( &apos;./provider/onsen.js&apos; ),</span><br><span class="line">    &apos;animate&apos;: require( &apos;./provider/animate.js&apos; )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var provider = &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Get the list of catalogue</span><br><span class="line">     * @return &#123;Array&#125; list of catalogue</span><br><span class="line">     */</span><br><span class="line">    getCatalogueList: function () &#123;</span><br><span class="line">        var arr = [],</span><br><span class="line">            item;</span><br><span class="line"></span><br><span class="line">        for ( item in catalogue ) &#123;</span><br><span class="line">            arr.push(&#123;</span><br><span class="line">                id: item,</span><br><span class="line">                name: catalogue[item].catalogueName,</span><br><span class="line">                host: catalogue[item].host</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return arr;</span><br><span class="line">    &#125;,</span><br><span class="line">    getCatalogueAsync: function ( id ) &#123;</span><br><span class="line">        var c;</span><br><span class="line"></span><br><span class="line">        if ( !( c = catalogue[id] ) ) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return c.getCatalogueAsync();</span><br><span class="line">    &#125;,</span><br><span class="line">    getBangumiAsync: function ( catalogueID, bangumiID ) &#123;</span><br><span class="line">        var c;</span><br><span class="line"></span><br><span class="line">        if ( !( c = catalogue[catalogueID] ) ) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return c.getBangumiAsync( bangumiID );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = provider;</span><br></pre></td></tr></table></figure><p>整体思路是提供一个可调用的列表，然后根据参数调用相应脚本的功能，就是一个 <code>dispatcher</code> 的功能。</p><p>如此，就实现了应用的一大部分主要功能了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##使用 nodejs 的库&lt;/p&gt;
&lt;p&gt;python 脚本的详细编写，请看之前的博文：&lt;a href=&quot;http://blog.e10t.net/radioit-plan-animate-radio-script-radioitscript/&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term=" - javascript - angularjs - angular-material - electron" scheme="https://www.e10t.net/tags/javascript-angularjs-angular-material-electron/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 1--分析与配置</title>
    <link href="https://www.e10t.net/2015/06/13/build-application-with-angular-and-ng-material-based-on-electron-1-analyze-and-configuration/"/>
    <id>https://www.e10t.net/2015/06/13/build-application-with-angular-and-ng-material-based-on-electron-1-analyze-and-configuration/</id>
    <published>2015-06-13T11:32:07.000Z</published>
    <updated>2015-09-05T09:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/kvb5CTf.png" alt="thumbnail"></p><blockquote><p><a href="https://github.com/radioit/radioit-desktop" target="_blank" rel="noopener">应用github地址</a>。github 代码和文章代码并不同步，用作预览和 PR。</p></blockquote><p>##目标分析</p><p>一句话概述：开发的应用是一个抓取网页有用信息并重新统一排布的应用，是<a href="http://blog.e10t.net/radioit-plan-animate-radio-script-radioitscript/" target="_blank" rel="noopener">之前文章</a>提到的 radioit 计划里脚本的 GUI 版本。</p><p>关键词：网页抓取、信息统一、信息排布、脚本的 GUI 版本</p><p>功能：</p><ol><li>浏览某一个广播站的广播</li><li>浏览某一个广播的详细信息</li><li>下载某一个广播最新的相关图片</li><li>下载某一个广播最新的相关音频</li><li>能够通过设置代理来突破某些限制</li><li>能够离线浏览（未定）</li><li>预定周期下载任务（未定）</li><li>整合视频压制工具（未定）</li></ol><p>业务流程：</p><ol><li>请求特定 url 资源</li><li>对取得的 url 资源进行信息提取</li><li>信息整合成统一格式</li><li>显示信息</li><li>某些情况下执行预定命令行（未定）</li></ol><p>技术联想：</p><ol><li>请求特定 url 资源 -&gt; node</li><li>对取得的 url 资源进行信息提取 -&gt; node 的某些库</li><li>信息整合成统一格式 -&gt; javascript, json</li><li>显示信息 -&gt; html、css、angular、angular material</li><li>某些情况下执行预定命令行（未定） -&gt; node</li></ol><p>##技术分析</p><p>技术要点：</p><ol><li>node.js(io.js)，负责网络连接，网页内容解析提取，非浏览器环境因此能够进行跨域访问</li><li>angular，MVVM框架，自动进行数据的渲染</li><li>angular material，angular 推出的 material design UI 框架，适合作为桌面应用使用</li><li>stylus，CSS 预处理器，合理直观的 CSS 编写格式</li></ol><p>脑内讨论</p><ul><li>Q：为什么使用Electron？</li><li><p>A：Electron 有意思地使用了 <code>main</code> 进程和 <code>render</code> 进程，<code>render</code> 进程产生于 <code>main</code> 进程中，因此可以简单地产生多个 <code>render</code> 进程，也就是多窗口。这是一个优势。</p></li><li><p>Q：不用 angular，用 react 是否可以？</p></li><li><p>A：可以，然而在假定选用了 react 之后，然后脑内模拟了一下编程的过程，react 似乎并不适合 html 代码经常修改的场合。而自己比较在行的是写 html 和 css，在界面设计上必定经常修改。另外在 material design 的 UI 框架上，使用配合 angular 的 angular material 显然更具操作性。当然 react 下也有 material design 的 UI 框架，但在试用之后感觉不太好用。另外就是自己翻译过一篇很长的有关 angular 的<a href="http://blog.e10t.net/translation-building-the-2048-game-in-angularjs/" target="_blank" rel="noopener">文章</a>，对 angular 比较熟悉。日后考虑改用 Polymer 重写。</p></li><li><p>Q：material design 是必须使用的吗？</p></li><li><p>A：作为桌面应用，需要有一点时刻记住的是桌面应用跟网页是不一样的。桌面应用需要稳定的窗口，要有标题栏等清晰的组件，也不需要太花哨的特效。material design 或者受 material design 影响的一些简洁 UI 风格已经在某些桌面软件上应用开来。Electron 作为使用网页作为 GUI 表现，使用 material design 是个稳妥之举。</p></li><li><p>Q：为什么不用 SASS / LESS？</p></li><li><p>A：SASS 需要 Ruby，对非 Rubyer 是非常无理的要求，逻辑表现能力强大而无用（非常用）；LESS 语法简单，支持混写，但逻辑表现力太弱。stylus则是既有强有力的特性，也足够简单。有时，工具够用就行。参考：<a href="http://webdesign.tutsplus.com/articles/why-i-choose-stylus-and-you-should-too--webdesign-18412" target="_blank" rel="noopener">Why I Choose Stylus (And You Should Too)</a></p></li><li><p>Q：node 和页面中的 angular 如何沟通？</p></li><li><p>A：<code>main</code> 进程和 <code>reander</code> 进程有特定的模块进行通信。<code>render</code>进程能通过页面中的全局变量和 angular 进行通讯。</p></li><li><p>Q：为什么要使用 node 的库来处理网页请求和内容提取？angular 自带有 $http 不是更方便？</p></li><li>A：如此一来，就能各自开发。node 只需要管如何得到数据，angular 只需要管如何显示数据。另外，如果需要更改 GUI，那么只需要去掉 angular，换上其他 UI 框架就可以，数据生成不受任何印象。只是如此开发需要更多的精力。</li></ul><p>##开发配置</p><p>###NPM 配置</p><p>node.js 的安装是必须的，不多介绍。安装完自带 npm 管理工具。</p><p>用的最多的 node 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i xxx -g</span><br><span class="line">npm i xxx --save</span><br><span class="line">npm u xxx --save</span><br><span class="line">npm update</span><br></pre></td></tr></table></figure></p><p>第一条是全局安装 node 模块。比如一些常用工具，每一个项目都可以用到的工具等。这些模块可以写在 <code>package.json</code> 中的 <code>devDependencies</code> 字段中。</p><p>第二条是本地安装 node 模块并保存信息到 <code>package.json</code> 中。适合项目特定使用的模块。这些模块可以写在 <code>package.json</code> 中的 <code>dependencies</code> 字段中。</p><p>第三条是卸载本地安装的 node 模块。node 模块太多了，尝试多个选最好的。</p><p>第四条是升级 node 模块。</p><p>以下是 <code>package.json</code> 文件的暂时内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Radioit&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;radioit desktop edition&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;exoticknight&quot;,</span><br><span class="line">  &quot;mail&quot;: &quot;draco.knight0@gmail.com&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;jshint&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;rimraf&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;electron-packager&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;electron-prebuilt&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;silence-chromium&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;mkdirp&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;nib&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;stylus&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;uglifyjs&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;browserify&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;watchify&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;parallelshell&quot;: &quot;latest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build:css&quot;: &quot;stylus -u nib src/css/app.styl -o static/css/app.css&quot;,</span><br><span class="line">    &quot;watch:css&quot;: &quot;stylus -u nib src/css/app.styl -o static/css/app.css -w&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;electron main.js 2&gt;&amp;1 | silence-chromium&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;npm run build:css &amp;&amp; electron main.js 2&gt;&amp;1 | silence-chromium&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;deepcopy&quot;: &quot;^0.5.0&quot;,</span><br><span class="line">    &quot;extend&quot;: &quot;^2.0.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时并没有太多的东西，注意要开发基于 Electron 应用，<code>electron-packager</code> 和 <code>electron-prebuilt</code> 必不可少，一个是 Electron 的打包工具，一个是 Electron 运行环境。而 <code>silence-chromium</code> 则是将 chromium 控制台信息输出到系统终端的工具。其他的工具都是博主开发过程中精选过的工具，还请读者自行 Google 之来学习。</p><p>如果你看过本博客之前的一篇文章：<a href="http://blog.e10t.net/write-i18n-js-with-help-of-npm-as-build-tool/" target="_blank" rel="noopener">i18n.js库的编写兼使用npm辅助开发</a>，就知道博主是能用 npm 就不用 gulp / grunt 的，因此在 <code>scripts</code> 字段中也写上了运行的脚本。</p><p>###angularjs 配置</p><p>angular 的版本比较稳定，因此直接用 <code>bower</code> 来获取，不推荐其他包管理工具。</p><blockquote><p><code>bower</code> 需要先使用 <code>npm install bower -g</code> 来安装，也需要配置了 git 的环境。如果你使用 github for windows，那么请使用 gitshell 来运行。</p></blockquote><p>angular 的安装在下一节中。</p><p>###angular material 配置</p><p>对于 <code>bower</code> 来说，angular material 跟 angular 是一样的东西，只是后者是前者的依赖。</p><p>运行 <code>bower install angular-material</code>， bower 会自动将依赖的的 <code>angular</code>、<code>angular-aria</code> 和 <code>angular-animate</code> 一并安装上。</p><p>安装完后所有文件会在项目目录下的 <code>bower_components</code> 中找到。</p><p>###Electron 配置</p><p>具体参考：<a href="https://github.com/atom/electron/blob/master/docs/tutorial/quick-start.md" target="_blank" rel="noopener">Quick Start</a></p><p>在 <code>package.json</code> 中有一个 <code>main</code> 字段，值是 <code>main.js</code>。这个就指定了 Electron 启动应用的入口。</p><p>准备好文件结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">├── package.json</span><br><span class="line">├── main.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><p>###初始程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var BrowserWindow = require( &apos;browser-window&apos; );  // Module to create native browser window.</span><br><span class="line">var ipc = require( &apos;ipc&apos; );</span><br><span class="line">var path = require( &apos;path&apos; );</span><br><span class="line"></span><br><span class="line">// global variable</span><br><span class="line">var APP_NAME = &apos;Radioit&apos;;</span><br><span class="line">var INDEX = &apos;file://&apos; + path.join( __dirname, &apos;index.html&apos; );</span><br><span class="line"></span><br><span class="line">// Report crashes to our server.</span><br><span class="line">require( &apos;crash-reporter&apos; ).start();</span><br><span class="line"></span><br><span class="line">// Keep a global reference of the window object, if you don&apos;t, the window will</span><br><span class="line">// be closed automatically when the javascript object is GCed.</span><br><span class="line">var mainWindow = null;</span><br><span class="line"></span><br><span class="line">// Quit when all windows are closed.</span><br><span class="line">app.on( &apos;window-all-closed&apos;, function () &#123;</span><br><span class="line">  if ( process.platform != &apos;darwin&apos; )</span><br><span class="line">    app.quit();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// This method will be called when Electron has done everything</span><br><span class="line">// initialization and ready for creating browser windows.</span><br><span class="line">app.on( &apos;ready&apos;, appReady );</span><br><span class="line"></span><br><span class="line">function appReady () &#123;</span><br><span class="line"></span><br><span class="line">    mainWindow = new BrowserWindow(&#123;</span><br><span class="line">        &apos;width&apos;: 1024,</span><br><span class="line">        &apos;height&apos;: 600,</span><br><span class="line">        &apos;resizable&apos;: false,</span><br><span class="line">        &apos;accept-first-mouse&apos;: true,</span><br><span class="line">        &apos;title&apos;: APP_NAME,</span><br><span class="line">        &apos;show&apos;: false</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mainWindow.loadUrl( INDEX );</span><br><span class="line">    mainWindow.openDevTools(); // remove this</span><br><span class="line"></span><br><span class="line">    mainWindow.webContents.on( &apos;did-finish-load&apos;, function () &#123;</span><br><span class="line">        mainWindow.show();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mainWindow.on( &apos;closed&apos;, function () &#123;</span><br><span class="line">        mainWindow = null;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码好像很多，其实基本就是照抄 quick start，没有任何压力。</p><p>博主写的 <code>main.js</code> 和 quick start 中的有所不同。在新建 <code>mainWindow</code> 的时候，加入了其他参数 <code>show: false</code> 和 <code>resizable: false</code>，分别是隐藏窗口和窗口不可拉伸。也增加了一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.webContents.on( &apos;did-finish-load&apos;, function () &#123;</span><br><span class="line">    mainWindow.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>作用是网页内容完全载入后才显示窗口，避免一些内容还没载入完就显示。</p><p>最后运行 <code>npm run test</code> 看看结果。</p><blockquote><p>有什么问题请留言。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/kvb5CTf.png&quot; alt=&quot;thumbnail&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/radioit/radioit-desktop&quot; targ
      
    
    </summary>
    
    
      <category term=" - javascript - angularjs - angular-material - electron" scheme="https://www.e10t.net/tags/javascript-angularjs-angular-material-electron/"/>
    
  </entry>
  
  <entry>
    <title>配合 angular 和 angular-material 来开发基于 electron 的应用 · 0--前言</title>
    <link href="https://www.e10t.net/2015/06/04/build-application-with-angular-and-ng-material-based-on-electron-0-preface/"/>
    <id>https://www.e10t.net/2015/06/04/build-application-with-angular-and-ng-material-based-on-electron-0-preface/</id>
    <published>2015-06-04T15:02:37.000Z</published>
    <updated>2015-10-20T00:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>##Electron</p><p>Electron 是什么？它之前的名字是 Atom Shell，是 Github 开发的结合了 io.js 和 chromium 的跨平台桌面应用框架。Github 自己出的编辑器 Atom 以及微软出的编辑器 VSCode 都是基于这个框架。</p><p>众所周知，Google chrome 就是基于 chromium 而发展出来的一款优秀的浏览器。因其出色的体验和网页解析性能，所有国内出产的<del>山寨</del>浏览器 / 双核浏览器，无不选用了 chrome 作为内核。所以在网页解析渲染方面，使用 chromium 是极其正确的选择。</p><p>那跟平常的桌面应用构建，使用 Electron 又有什么优势呢？</p><p>普通的桌面应用构建，比较成熟的语言不外乎 C/C++、Java、C#、Python 等。然而 C/C++ 易学难精，即使其 GUI 框架有 MFC、Qt、KDE 等众，也是极难快速开发；Java 的 GUI 烂得不提也罢；C# 极有可能成为以后霸主，然而还在跨平台表现上有所欠缺；Python则是个人喜好关系顺带一提，其实很少作为 GUI 主力语言被使用。（当然你可以阅读本人的另一个<a href="http://blog.e10t.net/python-with-qt-application-development-catalogue/" target="_blank" rel="noopener">有关 python 和 Qt 构建桌面应用的系列</a>）</p><p>Electron 则是使用了 Javascript 作为主力语言，并且为其加上了原生支持 html5 和 CSS3 的浏览器。从 GUI 构建来说，使用 html 和 css 的网页构建显然更加简单，成熟的工具和技术数不胜数；而作为桌面应用着重依赖的 IO、进程和网络通信模块等则由支持 ES6 的 io.js 提供，这样前端后端均采用 Javascript 语言，大大降低技术复杂性。</p><p>##与NW.js（旧名node-webkit）的异同</p><p>如果你有经常关注前端的消息，那么一定听说过一个国人开发的 GUI 框架：node-webkit。然后一看到 Electron，就会皱皱眉头：这不就是 node-webkit 嘛！</p><p>然而，Electron 和 node-webkit 并不一样，其 github 项目上有详细的对比，<a href="https://github.com/atom/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md" target="_blank" rel="noopener">链接</a>。</p><p>就个人理解来说，NW.js 偏向网页主导，是一个加上了 node.js 的浏览器；Electron 则是 javascript主导，是 io.js 加上了一个 chromium。</p><blockquote><p>准确来说，Electron 只是选择了网页作为 GUI，并非为 GUI 绑定了 javascript。在 Electron 文档的 <a href="https://github.com/atom/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md" target="_blank" rel="noopener">Quick start</a> 中很明确地指出「It doesn’t mean Electron is a JavaScript binding to GUI libraries. Instead, Electron uses web pages as its GUI, so you could also see it as a minimal Chromium browser, controlled by JavaScript.」</p></blockquote><p>在听说了 node-webkit 之后，我曾经上手把玩了一下，当时也是惊讶于其结合了浏览器内核而得到的强大表现力。因为自己在前端方面有一点技术，所以在编写界面的过程中感觉非常舒服。不过我也留意到其在软件方面的能力明显有比较大的欠缺，除了能读写文件外似乎没有什么亮点。（当然不排除在改名为 NW.js 后会加入了更多功能的可能性）</p><p>总之，NW.js 更像是将网页打包成应用，而 Electron 则是实际开发的应用。</p><p>##angular 和 angular material</p><p>如果要将网页设计应用到软件界面开发上，那么一些 MVC 框架或 UI 框架就比较适合。MVC 框架中比较有名的是 knockout 和 Backbone，而 UI 框架，则是 reactjs、angularjs 和 polymer 最为著名。国产的还有 avalon。</p><p>那么为什么选 angular 呢？因为 angular 的理念比较符合开发网页应用，更重要的是有 angular material 这样一个比较能使用的 UI 主题。相比之下，knockout 和 Backbone 功能太弱，reactjs 则是太激进（一开始我是选 reactjs 的，但是一番尝试之后还是放弃了），polymer 则未作深入了解。</p><p>不过，就像 Electron 只是选用了网页作为呈现 GUI 的方式，那么在编写基于 Electron 的应用的时候，GUI 框架的选择其实并非固定死的，如有必要或者个人喜好，转而使用 polymer 或者 reactjs 也未尝不可。</p><p>##本系列的目的</p><p>如果有看过鄙人写的<a href="http://blog.e10t.net/python-with-qt-application-development-catalogue/" target="_blank" rel="noopener">python × Qt应用开发系列</a>，那么一定知道本人的教程都偏向实践，喜欢实际解释代码和一定程度地搞清楚技术的细枝末节，而非跟着网上一搜一大把的英文教程或者官方文档演示一篇后以近乎翻译一般地写出所谓的“教程”。官方文档就摆在那，谁不会RTFM？</p><p>在本系列中，鄙人同样会以记录一个应用的开发流程的形式来呈现成功（或者说，可行）的开发方式。有时会有大量的代码，有时又会有长篇的理论讨论，有时又会有大段的思维解释，希望读者能耐心读下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##Electron&lt;/p&gt;
&lt;p&gt;Electron 是什么？它之前的名字是 Atom Shell，是 Github 开发的结合了 io.js 和 chromium 的跨平台桌面应用框架。Github 自己出的编辑器 Atom 以及微软出的编辑器 VSCode 都是基于这个
      
    
    </summary>
    
    
      <category term=" - javascript - angularjs - angular-material - electron" scheme="https://www.e10t.net/tags/javascript-angularjs-angular-material-electron/"/>
    
  </entry>
  
  <entry>
    <title>python × Qt应用开发系列目录（连载中）</title>
    <link href="https://www.e10t.net/2015/06/04/python-with-qt-application-development-catalogue/"/>
    <id>https://www.e10t.net/2015/06/04/python-with-qt-application-development-catalogue/</id>
    <published>2015-06-04T14:54:21.000Z</published>
    <updated>2015-06-04T14:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.e10t.net/python-with-qt-application-development-0-prologue/" target="_blank" rel="noopener">python × Qt应用开发 · 0 – 序</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-1-basic-view/" target="_blank" rel="noopener">python × Qt应用开发 · 1 – 基本界面</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-2-preliminary-design/" target="_blank" rel="noopener">python × Qt应用开发 · 2 – 界面初步设计</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-2-5-developing-gui/" target="_blank" rel="noopener">python × Qt应用开发 · 2.5 – 改进软件界面</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-3-basic-model-in-mvc/" target="_blank" rel="noopener">python × Qt应用开发 · 3 – MVC中model的基本实现</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-4-database-design/" target="_blank" rel="noopener">python × Qt应用开发 · 4 – 数据库设计</a></p><p><a href="http://blog.e10t.net/python-with-qt-application-development-5-database-helper/" target="_blank" rel="noopener">python × Qt应用开发 · 5 – 数据库helper类的编写</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/python-with-qt-application-development-0-prologue/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python × Qt应用开发 · 0 – 序&lt;
      
    
    </summary>
    
    
      <category term=" - python - Qt" scheme="https://www.e10t.net/tags/python-Qt/"/>
    
  </entry>
  
  <entry>
    <title>i18n.js库的编写兼使用npm辅助开发</title>
    <link href="https://www.e10t.net/2015/04/23/write-i18n-js-with-help-of-npm-as-build-tool/"/>
    <id>https://www.e10t.net/2015/04/23/write-i18n-js-with-help-of-npm-as-build-tool/</id>
    <published>2015-04-23T11:06:26.000Z</published>
    <updated>2015-04-25T06:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来由于开发某页面需要支持多语言切换，遂写一个切换页面语言的JS库。</p><p>##编写库的既定事项</p><p>写JS库也不是一两次了，当然只是小型或者微型的。不过思想和方法和大型库都是通用的。一般是直接在sublime text里打开一个JS文件，然后写下一个Self-Executing Anonymous Functions（自执行匿名函数？），接着在函数里面创造库的对象，最后将对象挂在<code>window</code>对象下。</p><p>Show you the code的话就是以下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function( window, undefined )&#123;</span><br><span class="line"></span><br><span class="line">var i18n = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">i18n.bar = function () &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">window.i18n = i18n;</span><br><span class="line"></span><br><span class="line">&#125;)( window );</span><br></pre></td></tr></table></figure><p>学得这样的写法是来源于对jQuery源代码的阅读。</p><p>通过将代码都包在一个匿名函数中，实现了一个闭包。如此一来在闭包内随便折腾，也不会污染到外部全局环境（当然是在编写可靠的代码的情况下）。</p><p>不过，随着AMD和CommonJS标准的流行开来，越来越多JS库都将自己模块化。过程也不复杂，只要遵循一定的规则就可以了。</p><p>而对于编写一个简单的JS库，将github上<a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a>项目给出的模板修改一下就OK。</p><p>修改后代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;(function( root, name, definition ) &#123;</span><br><span class="line">    if ( typeof define === &apos;function&apos; &amp;&amp; define.amd ) &#123;</span><br><span class="line">      define( [], definition );</span><br><span class="line">    &#125; else if ( typeof module === &apos;object&apos; &amp;&amp; module.exports ) &#123;</span><br><span class="line">      module.exports = definition();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root[name] = definition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)( this, &apos;i18n&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line">var i18n = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">i18n.bar = function () &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Return this library</span><br><span class="line">return i18n;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意最后不再需要手动将库挂载在<code>window</code>对象下，而是只是返回对象。挂载方式已经转交给外部函数判断。</p><p>##思考多一点，代码少一点</p><p>很久的以前，我曾经写过一个jQuery插件，功能是为表格添加分页和异步载入。然而在写之前并没有清晰地定下整个插件的功能和限制，导致最后写出来的插件身兼数职，连表格美化与自定义CSS等也做了进去。加进去的功能有可能只是随手实现的，也许并不适合此插件管辖，造成了“做得不好非要做”的尴尬。</p><p>另外，功能的繁琐与代码段的反复抽象提取导致了代码的凌乱不堪，进而导致测试出bug的时候完全搞不清楚问题所在。</p><p>最后代码膨胀到完全不能控制，自己写出来的代码连自己都不敢修改。</p><blockquote><p>在写jQuery插件的时候，十分容易变成了写“使用jQuery的代码集合”，缺少性能和架构的考虑。这跟jQuery本身十分强大和灵活的特性有很大的关系。</p></blockquote><p>写库或插件，目的应该是将通用或者复杂的逻辑实现封装起来，通过提供简洁的API来实现功能的调用。</p><p>先将手从键盘上收回，拿出纸笔，好好列出对JS库的描述。</p><ul><li>Q1：i18n.js要做什么？</li><li>A1：对页面上的文本进行语言切换。</li><li>Q2：如何定位文本？</li><li>A2：为DOM元素增加’data-i18n’属性进行标记。</li><li>Q3：如何找到标注DOM元素？</li><li>A3：从给出的DOM元素作为根进行深度优先/广度优先遍历。</li><li>Q4：译文的来源？</li><li>A4：用户遵循某一标准自定义每一套语言的字典。</li><li>Q5：如何将译文和元素对应？</li><li>A5：对每一条文本，以唯一ID标识。凡是’data-i18n’属性的值为此ID的元素，即使用此ID对应文本。</li></ul><p>思路是不是清晰了很多呢？可以看到核心逻辑就是一个有访问函数的DFS或BFS算法。</p><p>##工欲善其事，必先利其器？</p><p>近年的前端大发展，也催生了很多自动化工具。node的流行更是让很多软件管理和后端开发的思想能应用到前端开发上。</p><p>经典的前端开发不外乎就是写HTML、写CSS、写Javascript，然而在前端代码量越来越大的现在，一个自动化的构建工具则能大大提高工作效率。</p><p>如果Google一下前端构建工具，那么基本就是Grunt和Gulp。</p><p>本质上，Grunt和Gulp都是任务运行器，尝试将前端的代码生成甚至发布统合到几个甚至一个命令行中。它们本身作为npm的一个模块，并没有什么作用，真正做事的是以其为平台的大量插件。通过将各种各样的插件整合起来，Grunt和Gulp就能实现自动化的任务执行。</p><p>但是慢着，以前不是很流行什么网页三剑客的吗？甚至用DreamWrear就能做网页啊。任务运行器、插件什么的是个什么鬼？！</p><p>是这样的，现在的前端开发，虽然最终结果还是写HTML、写CSS、写Javascript，但是过程却已经变化多端，内容也逐渐丰富。</p><p>HTML的话：</p><p>切图输出其实也已经算一种自动化。然而现在还能使用jade、HAML或者各种模板引擎生成，也就是有可能不是直接手写HTML代码了。这个就需要依赖编译了。</p><p>CSS的话：</p><p>SASS、LESS和Stylus都已经存在了很久了，源代码产出CSS也是需要编译的。CSS文件也能够进行合并和版本控制，如此一来又需要额外的工具。</p><p>Javascript的话：</p><p>本身就是一个编程语言，有工具能对其语法进行排错，不能不用吧？流行又高效的模块化开发，需要工具合并吧？压缩源代码，又需要操作了吧？注释呢？文档呢？统统需要工具啊。</p><p>总结起来，HTML要编译，CSS要编译、合并、压缩和，Javascript要编译/合并、压缩甚至生成文档。最后发布还要顾及CDN或者缓存或者bug跟踪进行版本管理如果以上每一步都要自己操作，那么即使只是打命令行也是够呛。</p><p>而使用上自动化构建，则在设定好以上多种工具的使用流程之后（几乎）一劳永逸，只需要专心写好流程最开始的源代码就OK，构建工具会完全自动地生成最终结果。能少干活就少干活，那个程序员愿意做重复性工作？</p><p>这也就是为什么自动化构建工具在一日发展千里、需求一日多改的前端如此受欢迎的原因了。</p><p>###Grunt VS Gulp</p><p>是个程序员总会遇到圣战的时候，或是Emacas VS Vim，或是C# VS Java，或是Python VS Ruby，或是AngularJS VS ReactJS，或是IOS VS Android……</p><p><del>当然，PHP是最好的语言所以不用战争。</del></p><p>也有人只是选择困难症后期患者，一旦选项多于一就会头痛欲裂、浑身不自在。</p><p>那么，究竟Grunt or Gulp？</p><p>为此很多人写过分析的文章，有<a href="http://www.w3ctech.com/topic/114" title="谈谈Grunt,NPM,Gulp" target="_blank" rel="noopener">中文的</a>、<a href="http://www.hongkiat.com/blog/gulp-vs-grunt/" title="The Battle Of Build Scripts: Gulp Vs Grunt" target="_blank" rel="noopener">英文的</a>和<a href="http://jaysoo.ca/2014/01/27/gruntjs-vs-gulpjs/" title="Grunt vs Gulp - Beyond the Numbers" target="_blank" rel="noopener">另一篇英文的</a>，总的来说就是，</p><p>Grunt：插件比较多，社区成熟，风格偏配置，插件比较混乱，代码较长，过程有临时目录</p><p>Gulp：插件不够Grunt多，风格偏代码，插件功能单一专注，代码较短，流式工作无需临时目录</p><p>个人选择是Gulp，那个插件数量不够多是个伪缺点，只是不过Grunt多，其实也有上千个，还不够用？！从其他优点来看都是完胜Grunt了。</p><p>###逆袭的npm</p><p>那是不是选择Gulp来构建i18n.js呢？</p><p>并不是。</p><p>如果有仔细看给出的分析文章，可以看到还有一个构建工具：npm。</p><p>众所周知npm实际上是nodejs的包管理工具，然而在其配置文件package.json里面却也可以设置一些可运行项，然后通过<code>npm run xxx</code>来运行。从文章来看，也是能够胜任构建的任务。</p><p>那么问题来了，从网上基本千篇一律的教程来看，Grunt和Gulp的使用都是装上了自带npm的node，然后通过npm来安装的。既然npm本身就能作为构建工具，那为啥要用Grunt和Gulp？</p><p>注意到那篇中文的分析文章还提到“npm一般用在个人项目里,对于团队项目则不适用”，然而果真如此吗？</p><p>使用英文搜索一下，不难发现国外也有人提出<a href="http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt" title="Why we should stop using Grunt &amp; Gulp" target="_blank" rel="noopener">停止使用Grunt和Gulp的主张</a>，在文中列出类似或同类构建工具的问题：</p><ol><li>Bloat</li><li>Relying on plugins</li><li>Separate pain in updating</li><li>False Promises</li><li>Bad behaviours</li></ol><p>接着提出了使用npm的主张，并且<a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/" title="How to Use npm as a Build Tool" target="_blank" rel="noopener">还给出了详细方法</a>，可以看到使用npm更易懂更简洁。</p><p>我使用Grunt和Gulp的经验并不多（实际也不是什么复杂的东西），对于文中提出的第一个问题已经深有感触。明明只是简单的工作，却要写一大堆罗嗦的配置。另外Grunt/Gulp插件使用都是local安装，于是明明只是写几个KB大小的库，却要将项目的文件夹弄成几十MB大。插件作用都很专一，更新频率很低，全局安装就好，每开一个项目就独立往项目塞一样的工具简直是闲得蛋疼，尤其npm下载插件经常由于网络原因而失败。</p><blockquote><p>当然独立安装项目依赖也有其存在的意义。当将项目发布给其他人使用或者开发的时候，独立安装项目依赖可以保证环境是一样的。</p></blockquote><p>所以结论是，<strong>不要为使用Grunt/Gulp而使用Grunt/Gulp，很多情况下并不需要将事情弄复杂。</strong></p><p>###package.json</p><p>参考国外配置npm的文章，写好package.json。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;i18n.js&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;concat-cli&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;jade&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;jshint&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;rimraf&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;nodemon&quot;: &quot;latest&quot;,</span><br><span class="line">    &quot;parallelshell&quot;: &quot;latest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;clean:test&quot;: &quot;rimraf test/*&quot;,</span><br><span class="line">    &quot;clean:dist&quot;: &quot;rimraf dist/*&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;lint&quot;: &quot;jshint src/js/main.js&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;test:html&quot;: &quot;jade -P src/test.jade --out test&quot;,</span><br><span class="line">    &quot;watch:html&quot;: &quot;jade -w -P src/test.jade --out test&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;prebuild:js&quot;: &quot;npm run lint&quot;,</span><br><span class="line">    &quot;build:js&quot;: &quot;concat-cli -f src/js/wrap/prefix.js src/js/main.js src/js/wrap/suffix.js -o dist/i18n.js&quot;,</span><br><span class="line">    &quot;postbuild:js&quot;: &quot;uglifyjs dist/i18n.js -o dist/i18n.min.js -m -c&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;pretest:js&quot;: &quot;npm run lint&quot;,</span><br><span class="line">    &quot;test:js&quot;: &quot;concat-cli -f src/js/wrap/prefix.js src/js/main.js src/js/wrap/suffix.js -o test/i18n.js&quot;,</span><br><span class="line">    &quot;watch:js&quot;: &quot;nodemon --watch src/js --exec \&quot;npm run test:js\&quot;&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;pretest&quot;: &quot;npm run clean:test&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;npm run test:js &amp;&amp; test:html&quot;,</span><br><span class="line">    &quot;test:watch&quot;: &quot;parallelshell \&quot;npm run watch:js\&quot; \&quot;npm run watch:html\&quot;&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;prebuild&quot;: &quot;npm run clean:dist&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;npm run build:js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清晰明了。</p><p>测试环境清理：rimraf</p><p>HTML构建：jade</p><p>Javascript排错：jshint</p><p>Javascript合并：concat-cli（多个文件复制合并）</p><p>全部都是一句话配置，直指命令行。多个任务最终又可以汇集在<code>test</code>/<code>test:watch</code>中。</p><blockquote><p>使用concat-cli构建Javascript比较少见，更多的是使用browserify配合require语法。然而i18n.js库实在太小了，真的不需要复杂的模块化管理。</p></blockquote><p>##编写i18n.js</p><p>###拆分</p><p>先将原js文件拆分成三个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// prefix.js</span><br><span class="line">;(function( root, name, definition ) &#123;</span><br><span class="line">    if ( typeof define === &apos;function&apos; &amp;&amp; define.amd ) &#123;</span><br><span class="line">      define( [], definition );</span><br><span class="line">    &#125; else if ( typeof module === &apos;object&apos; &amp;&amp; module.exports ) &#123;</span><br><span class="line">      module.exports = definition();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      root[name] = definition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)( this, &apos;i18n&apos;, function() &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// suffix.js</span><br><span class="line"></span><br><span class="line">// Return this library</span><br><span class="line">return i18n;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">var i18n = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">i18n.bar = function () &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来可以专心在’main.js’中写代码了。</p><blockquote><p>在敲入代码之前记得使用<code>npm run watch:js</code>，不然配置毫无意义。</p></blockquote><p>###内部变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Save the global object, which is window in browser / global in Node.js.</span><br><span class="line">var root = this;</span><br><span class="line"></span><br><span class="line">// This library and internal object</span><br><span class="line">var i18n = &#123;&#125;,</span><br><span class="line">    _ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// Current version.</span><br><span class="line">i18n.version = &apos;0.0.1&apos;;</span><br><span class="line"></span><br><span class="line">// Internel store</span><br><span class="line">var TRANSLATION_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// Current language</span><br><span class="line">var CURRENT_LANGUAGE = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">// Save the previous value of the `i18n` variable, can be restored later</span><br><span class="line">// if &apos;noConflict&apos; is called.</span><br><span class="line">var previousi18n = root.i18n;</span><br></pre></td></tr></table></figure><p><code>TRANSLATION_TABLE</code>保存翻译文本，<code>CURRENT_LANGUAGE</code>保存当前使用的语言，<code>_</code>是内部使用的命名空间。另外使用<code>root</code>保存全局对象，<code>previousi18n</code>保存之前已存在的’i18n’对象。</p><p>###库函数（API）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Restore the previous value of &apos;i18n&apos; and return our own i18n object.</span><br><span class="line">i18n.noConflict = function () &#123;</span><br><span class="line">    root.i18n = previousi18n;</span><br><span class="line">    return i18n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>noConflict函数，学jQuery的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Load the translation table</span><br><span class="line">i18n.load = function ( table ) &#123;</span><br><span class="line">    TRANSLATION_TABLE = _.deepCopy( TRANSLATION_TABLE, table );</span><br><span class="line">    return i18n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>载入翻译文本，使用深复制（应对多层对象）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Return the current set language</span><br><span class="line">i18n.current = function () &#123;</span><br><span class="line">    return CURRENT_LANGUAGE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回当前使用的语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Change the language, apply to all cached nodes or document.body</span><br><span class="line">i18n.use = function ( language ) &#123;</span><br><span class="line">    var langTable = TRANSLATION_TABLE[language],</span><br><span class="line">        nodes;</span><br><span class="line"></span><br><span class="line">    if ( langTable ) &#123;</span><br><span class="line">        nodes = _.filterNodes( root.document.body );</span><br><span class="line">        _.translate( nodes, langTable );</span><br><span class="line">        CURRENT_LANGUAGE = language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return i18n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>切换语言。流程是匹配出语言配置，再从body开始抓取出需要翻译的DOM元素（_.filterNodes函数），然后翻译（_.translate函数），最后设置当前语言。</p><p>###内部函数</p><p>API函数的内容写得简单，主要是需要基于不少的内部函数。</p><p>首先是深复制。</p><blockquote><p>Javascript中的赋值都是复制，因此对于基本类型（primitive value）：Undefined、Null、Boolean、Number、String来说，直接赋值就是复制。其他的复杂类型，直接赋值同样是复制——然而，复制的是引用，并不是引用的对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// can handle array and nested objects, not perfect</span><br><span class="line">_.deepCopy = function ( des, src ) &#123;</span><br><span class="line">    var beCopiedIsArray = false,</span><br><span class="line">        target,</span><br><span class="line">        name,</span><br><span class="line">        clone,</span><br><span class="line">        beCopied;</span><br><span class="line"></span><br><span class="line">    target = des;</span><br><span class="line"></span><br><span class="line">    for ( name in src ) &#123;</span><br><span class="line">        beCopied = src[name];</span><br><span class="line"></span><br><span class="line">        if ( beCopied === src ) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ( _.isObject( beCopied ) || ( beCopiedIsArray = _.isArray( beCopied ) ) ) &#123;</span><br><span class="line"></span><br><span class="line">            if ( beCopiedIsArray ) &#123;</span><br><span class="line">                beCopiedIsArray = false;</span><br><span class="line">                clone = [];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                clone = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            target[name] = _.deepCopy( clone, beCopied );</span><br><span class="line"></span><br><span class="line">        &#125; else if ( beCopied !== undefined ) &#123;</span><br><span class="line">            target[name] = beCopied;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改写自jQuery1.7内部实现的对象深复制函数，只保留了识别数组和对象的功能。因为译文文本就是JSON格式的普通对象（plain object），无需要实现太复杂的复制。核心代码的思想就是检测在当前对象的每一个属性（省略了hasOwnProperty的检测），如果是数组（_.isArray）或者普通对象（_.isObject），则实实在在创建一个数组 / 对象以供复制。</p><p>而数组 / 对象检测则是用以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// figure out array</span><br><span class="line">_.isArray = Array.isArray || function( obj ) &#123;</span><br><span class="line">    return Object.prototype.toString.call( obj ) === &apos;[object Array]&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// figure out object</span><br><span class="line">_.isObject = function( obj ) &#123;</span><br><span class="line">    return Object.prototype.toString.call( obj ) === &apos;[object Object]&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而库的核心，一个带访问函数的DFS。DOM操作自带取子元素和兄弟元素，写起来很简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Walk the DOM, call the visit</span><br><span class="line">_.walkDOM = function ( dom, visit ) &#123;</span><br><span class="line">    var node;</span><br><span class="line">    </span><br><span class="line">    // nodeType === 1 means element</span><br><span class="line">    // nodeType === 11 means DocumentFragment</span><br><span class="line">    if ( dom &amp;&amp; 1 === dom.nodeType || 11 === dom.nodeType ) &#123;</span><br><span class="line">        visit( dom ); // 访问当前DOM元素</span><br><span class="line"></span><br><span class="line">        node = dom.firstChild; // 取当前DOM元素的第一个子元素</span><br><span class="line">        while ( node ) &#123;</span><br><span class="line">            _.walkDOM( node, visit ); // 对此子元素递归调用</span><br><span class="line">            node = node.nextSibling; // 从此子元素返回，处理下一个兄弟元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过查看元素的属性来筛选出将要翻译的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Returns array of elements that have attribute &apos;data-i18n&apos;</span><br><span class="line">_.filterNodes = function ( root ) &#123;</span><br><span class="line">    var nodes = [];</span><br><span class="line"></span><br><span class="line">    // traverse DOM tree and collect elements with &apos;data-i18n&apos; attribute</span><br><span class="line">    _.walkDOM( root, function ( ele ) &#123;</span><br><span class="line">        if ( _.hasAttr( ele, &apos;data-i18n&apos; ) ) &#123;</span><br><span class="line">            nodes.push( ele );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上一个函数中用到的’_.hasAttr’，特别实现是因为IE的取属性方式跟其他浏览器不一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Return true if ele has attribute otherwise false</span><br><span class="line">_.hasAttr = function ( ele, attr ) &#123;</span><br><span class="line">    return ele.hasAttribute ? ele.hasAttribute( attr ) : ele[attr] !== undefined;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是改变元素的文本。代码很简单，做的事情就是遍历DOM元素数组，取属性’data-i18n’的值作为key值，在译文表格中查询value值（_.getTranslatedText），最后改变元素的文本（_.setText）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Translate each node in array with given language table</span><br><span class="line">_.translate = function ( nodes, table ) &#123;</span><br><span class="line">    var key, text, i, length;</span><br><span class="line"></span><br><span class="line">    for ( i = 0, length = nodes.length; i &lt; length; i++ ) &#123;</span><br><span class="line">        key = nodes[i].getAttribute( &apos;data-i18n&apos; );</span><br><span class="line"></span><br><span class="line">        if ( key ) &#123;</span><br><span class="line">            text = _.getTranslation( key, table );</span><br><span class="line"></span><br><span class="line">            if ( typeof text === &apos;string&apos; ) &#123;</span><br><span class="line">                _.setText( nodes[i], text );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_.getTranslatedText 支持使用点记法，代码直接用以前写过的。<a href="http://blog.e10t.net/implements-list-and-flag-in-simpletemplatejs/" target="_blank" rel="noopener">参考</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// get translation via path, support dot</span><br><span class="line">_.getTranslatedText = function ( path, json ) &#123;</span><br><span class="line">    var fieldPath = path.split( &apos;.&apos; ),</span><br><span class="line">        data = json,</span><br><span class="line">        index,</span><br><span class="line">        indexLength;</span><br><span class="line"></span><br><span class="line">    for ( index = 0, indexLength = fieldPath.length; index &lt; indexLength; index++ ) &#123;</span><br><span class="line">        data = data[fieldPath[index]];</span><br><span class="line">        if ( !data ) &#123;</span><br><span class="line">            return &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_.setText 函数就是用’innerText’或’textContent’来设置元素文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// cross-browser set text</span><br><span class="line">_.setText = function ( ele, text ) &#123;</span><br><span class="line">    var nodeType = ele.nodeType,</span><br><span class="line">        textAttr;</span><br><span class="line"></span><br><span class="line">    if ( nodeType &amp;&amp; 1 === nodeType ) &#123;</span><br><span class="line">        textAttr = ( &apos;innerText&apos; in ele ) ? &apos;innerText&apos; : &apos;textContent&apos;;</span><br><span class="line">        ele[textAttr] = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>###测试</p><p>看起来大概写完了，来写一些测试。</p><blockquote><p>实际上应该先写测试，再写代码。但是一来库很小，二来我不太懂，所以……不过之后写比较大型的库的时候要好好地用mocha等的测试框架。</p></blockquote><p>用jade语法写一个HTML文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    meta(charset=&quot;UTF-8&quot;)</span><br><span class="line">    title test</span><br><span class="line">    script(src=&quot;i18n.js&quot;)</span><br><span class="line">  body</span><br><span class="line">    select#language(name=&quot;language&quot;,onchange=&quot;toggle()&quot;)</span><br><span class="line">      option(value=&quot;en&quot;) English</span><br><span class="line">      option(value=&quot;zh&quot;) 中文</span><br><span class="line">      option(value=&quot;jp&quot;) 日本語</span><br><span class="line"></span><br><span class="line">    h1(data-i18n=&quot;TITLE&quot;) Title</span><br><span class="line">    p(data-i18n=&quot;p.text&quot;) This is test text.</span><br><span class="line">    button(data-i18n=&quot;BUTTON_TEXT&quot;) change</span><br><span class="line">    button(data-i18n=&quot;BUTTON_ADD&quot;,onclick=&quot;add()&quot;) add</span><br><span class="line"></span><br><span class="line">  script.</span><br><span class="line">    i18n.load(&#123;</span><br><span class="line">      &apos;en&apos;: &#123;</span><br><span class="line">        &apos;TITLE&apos;: &apos;Title&apos;,</span><br><span class="line">        &apos;BUTTON_TEXT&apos;: &apos;change&apos;,</span><br><span class="line">        &apos;BUTTON_ADD&apos;: &apos;add&apos;,</span><br><span class="line">        &apos;p&apos;: &#123;</span><br><span class="line">          &apos;text&apos;: &apos;This is test text.&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &apos;zh&apos;: &#123;</span><br><span class="line">        &apos;TITLE&apos;: &apos;标题&apos;,</span><br><span class="line">        &apos;BUTTON_TEXT&apos;: &apos;变&apos;,</span><br><span class="line">        &apos;BUTTON_ADD&apos;: &apos;添加&apos;,</span><br><span class="line">        &apos;p&apos;: &#123;</span><br><span class="line">          &apos;text&apos;: &apos;这是测试文本。&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &apos;jp&apos;: &#123;</span><br><span class="line">        &apos;TITLE&apos;: &apos;タイトル&apos;,</span><br><span class="line">        &apos;BUTTON_TEXT&apos;: &apos;変更&apos;,</span><br><span class="line">        &apos;BUTTON_ADD&apos;: &apos;追加する&apos;,</span><br><span class="line">        &apos;p&apos;: &#123;</span><br><span class="line">          &apos;text&apos;: &apos;これはテストテキストです&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    function toggle () &#123;</span><br><span class="line">      var ele = document.getElementById( &apos;language&apos; ),</span><br><span class="line">        value = ele.value;</span><br><span class="line"></span><br><span class="line">      i18n.use( value );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>控制台运行<code>npm run test:html</code>生成HTML文件，用浏览器打开，切换一下语言，没问题。</p><p>##继续开发</p><p>应用i18n.js的多语言页面，是有可能动态添加DOM元素的（AJAX拉取数据之类的操作），所以i18n.js库也需要将添加的DOM元素翻译一下。于是再添加一个名为’translate’的API好了。</p><blockquote><p>由于需要同时修改jade文件和js文件，所以使用<code>npm run test:watch</code>，同时监视jade文件和js文件的变化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Translate nodes</span><br><span class="line">i18n.translate = function ( eles ) &#123;</span><br><span class="line">    var langTable, nodeList, i, index, nodes;</span><br><span class="line"></span><br><span class="line">    langTable = TRANSLATION_TABLE[CURRENT_LANGUAGE];</span><br><span class="line"></span><br><span class="line">    if ( langTable ) &#123;</span><br><span class="line">        nodeList = Object.prototype.toString.call( eles ) === &apos;[object NodeList]&apos; ||</span><br><span class="line">            &apos;length&apos; in eles ?</span><br><span class="line">            eles :</span><br><span class="line">            [eles];</span><br><span class="line"></span><br><span class="line">        for ( i = 0, index = nodeList.length; i &lt; index; i++ ) &#123;</span><br><span class="line">            nodes = _.filterNodes( nodeList[i] );</span><br><span class="line">            _.translate( nodes, langTable );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>做的事其实和<code>use</code>大同小异，只是目标DOM元素不一样。</p><p>修改一下测试文件，增加一点代码。</p><p>在 body 中添加两个按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button(data-i18n=&quot;BUTTON_ADD_1&quot;,onclick=&quot;add(1)&quot;) add one</span><br><span class="line">button(data-i18n=&quot;BUTTON_ADD_2&quot;,onclick=&quot;add(2)&quot;) add two</span><br></pre></td></tr></table></figure><p>在数据中增加按钮的文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;BUTTON_ADD_1&apos;: &apos;add one line&apos;,</span><br><span class="line">&apos;BUTTON_ADD_2&apos;: &apos;add two line&apos;,</span><br><span class="line">/* ... */</span><br><span class="line">&apos;BUTTON_ADD_1&apos;: &apos;添加一行&apos;,</span><br><span class="line">&apos;BUTTON_ADD_2&apos;: &apos;添加两行&apos;,</span><br><span class="line">/* ... */</span><br><span class="line">&apos;BUTTON_ADD_1&apos;: &apos;1行を追加する&apos;,</span><br><span class="line">&apos;BUTTON_ADD_2&apos;: &apos;2行を追加する&apos;,</span><br></pre></td></tr></table></figure><p>在脚本中增加一个函数，用作模拟动态添加DOM元素。可以添加一个或多个DOM元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function add ( num ) &#123;</span><br><span class="line">  var p = document.getElementsByTagName( &apos;p&apos; )</span><br><span class="line">    , newP = document.createElement( &apos;div&apos; )</span><br><span class="line">    , i</span><br><span class="line">    , node</span><br><span class="line">    , fragment;</span><br><span class="line"></span><br><span class="line">  fragment = document.createDocumentFragment();</span><br><span class="line">  newP.innerHTML = &apos;&lt;p data-i18n=&quot;p.text&quot;&gt;This is test text.&lt;/p&gt;&apos;;</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt; num; i++ ) &#123;</span><br><span class="line">    node = newP.firstChild.cloneNode( true );</span><br><span class="line">    fragment.appendChild( node );</span><br><span class="line">  &#125;</span><br><span class="line">  i18n.translate( fragment );</span><br><span class="line"></span><br><span class="line">  p = p[p.length-1];</span><br><span class="line">  p.parentNode.insertBefore( fragment, p.nextSibling );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再使用浏览器测试一下，同样没问题了。</p><p>###再拆分一下</p><p>现在<code>main.js</code>文件看起来比较复杂，可以再分别拆分成<code>var.js</code>，存放顶层变量；<code>util.js</code>，包含内部的函数；<code>api.js</code>，包含库的API。</p><p>稍微修改一下<code>package.json</code>文件，相关位置改成拆分后的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    &quot;lint&quot;: &quot;jshint src/js/var.js &amp;&amp; jshint src/js/util.js &amp;&amp; jshint src/js/api.js&quot;,</span><br><span class="line">/* ... */</span><br><span class="line">    &quot;build:js&quot;: &quot;concat-cli -f src/js/wrap/prefix.js src/js/var.js src/js/util.js src/js/api.js src/js/wrap/suffix.js -o dist/i18n.js&quot;,</span><br><span class="line">/* ... */</span><br><span class="line">    &quot;test:js&quot;: &quot;concat-cli -f src/js/wrap/prefix.js src/js/var.js src/js/util.js src/js/api.js src/js/wrap/suffix.js -o test/i18n.js&quot;,</span><br></pre></td></tr></table></figure><p>最后运行<code>npm run build</code>将js库编译出来并压缩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近来由于开发某页面需要支持多语言切换，遂写一个切换页面语言的JS库。&lt;/p&gt;
&lt;p&gt;##编写库的既定事项&lt;/p&gt;
&lt;p&gt;写JS库也不是一两次了，当然只是小型或者微型的。不过思想和方法和大型库都是通用的。一般是直接在sublime text里打开一个JS文件，然后写下一个Se
      
    
    </summary>
    
    
      <category term=" - javascript - i18n.js" scheme="https://www.e10t.net/tags/javascript-i18n-js/"/>
    
  </entry>
  
  <entry>
    <title>radioit计划——动画广播辅助脚本radioitScript</title>
    <link href="https://www.e10t.net/2015/03/23/radioit-plan-animate-radio-script-radioitscript/"/>
    <id>https://www.e10t.net/2015/03/23/radioit-plan-animate-radio-script-radioitscript/</id>
    <published>2015-03-23T12:25:53.000Z</published>
    <updated>2015-03-23T12:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://blog.e10t.net/how-to-save-internet-radio/" target="_blank" rel="noopener">这篇文章</a>的实践基础和<a href="http://blog.e10t.net/append-a-python-script-for-last-post-about-saving-internet-radio/" target="_blank" rel="noopener">这篇文章</a>的代码基础上，我重新将代码整理一下，并添加了一些功能，将原来三个脚本的共同点提炼，写成一个网络广播查看和获取的框架。继而在这个框架上，写出对应三个广播站的脚本的ver 2.0。</p><p>原来的脚本的功能就不再详述了，来说说一下新版脚本三大功能，分别是：探索广播、下载广播和查看广播。</p><p>探索广播是指能够列出某一个广播站上所有的/当天的/星期x的/最新的广播，旨在能够帮助使用者发现自己喜欢的广播和新推出的广播。</p><p>下载广播是指能提取出广播音频/图片的地址，供第三方播放器播放或保存。</p><p>查看广播是指能够列出某广播的主要信息：包括更新日期、最新一期的内容、主持人等。</p><p>基本可以说，有了新版的脚本，基本就不需要用浏览器浏览广播站的网页了。并且，因为脚本只是需要抓单个页面和将网页内容整理好再输出，所以对比起网页，能更快更高效地呈现有用的信息。</p><p>##子命令</p><p>对比旧版，新版脚本的一大改进是引入了子命令。最直观的反映就是，调用方式的不同。</p><p>旧版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python www.py -x -y zzz</span><br></pre></td></tr></table></figure></p><p>新版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python www.py xxx -y zzz</span><br></pre></td></tr></table></figure></p><p>就是类似<code>git</code>命令行的那样，<code>argparse</code>库非常给力地支持这种方法。</p><p>重点是使用<code>add_subparsers</code>函数和<code>add_parser</code>函数，详细使用看<a href="https://docs.python.org/2/library/argparse.html" target="_blank" rel="noopener">文档</a>和<a href="https://github.com/exoticknight/radioitScript/blob/master/_radioit_script_template.py" target="_blank" rel="noopener">github上的代码</a>。</p><p>多亏了能够这样嵌套命令，即使再多的功能也能变得清晰分明。</p><p>##整体框架</p><p>ver 2.0 的起点是一个脚本框架，承载参数的解释和自定义函数调用的重要功能。</p><p>脚本的一次执行基本流程是：</p><p>入口 → 解析参数 → 调用自定义函数 → 执行自定义函数</p><p>前三个都能够定下来，不同的广播站只需要各自填充自定义函数就可以了。</p><p>最简框架代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;自定义函数</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def foo():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;子命令和参数跳转</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def process(option):</span><br><span class="line">    if option.sp_name == &quot;www&quot;:</span><br><span class="line">        if option.xxx:</span><br><span class="line">            foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;入口</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    parser = argparse.ArgumentParser(version=&quot;2.0&quot;)</span><br><span class="line"></span><br><span class="line">    # 子命令</span><br><span class="line">    sp = parser.add_subparsers(title=&quot;commands&quot;, description=&quot;support commands&quot;, help=&quot;what they will do&quot;, dest=&quot;sp_name&quot;)</span><br><span class="line"></span><br><span class="line">    # 添加子命令</span><br><span class="line">    sp_www = sp.add_parser(&quot;www&quot;)</span><br><span class="line"></span><br><span class="line">    # 添加子命令参数</span><br><span class="line">    sp_www.add_argument(&quot;-x&quot;, &quot;--xxx&quot;, action=&quot;store_true&quot;, dest=&quot;xxx&quot;)</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        args = parser.parse_args(sys.argv[1:])</span><br><span class="line">    except argparse.ArgumentError, e:</span><br><span class="line">        print(&quot;bad options: &#123;0&#125;&quot;.format(e))</span><br><span class="line">    except argparse.ArgumentTypeError, e:</span><br><span class="line">        print(&quot;bad option value: &#123;0&#125;&quot;.format(e))</span><br><span class="line">    else:</span><br><span class="line">        process(args)</span><br></pre></td></tr></table></figure><p>##自定义函数骨架</p><p>框架还基于库<code>urllib</code>、<code>urllib2</code>、<code>argparse</code>和<code>bs4</code>，制定了自定义函数的骨架。</p><p>脚本做的事情，无非就是获取网页资源，接着在html结构中筛选有用信息，然后格式化成文本输出。因此，自定义函数也可以制定出骨架，不同的广播站就只需要指定筛选的规则就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 获取网页</span><br><span class="line">try:</span><br><span class="line">    soup = BeautifulSoup(urllib2.urlopen(u&quot;http://url&quot;, timeout=60)) # 1</span><br><span class="line">except Exception, e:</span><br><span class="line">    handle_error(e, &quot;Network Error.&quot;)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"># 筛选</span><br><span class="line">content = soup.select(&quot;html&quot;) # 2</span><br><span class="line"></span><br><span class="line"># 组织内容</span><br><span class="line">table = [(u&quot;ID&quot;, u&quot;Name&quot;)] + [a for a in content] # 3</span><br><span class="line"># 格式化文本</span><br><span class="line">text = prettify_table(table)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">print(text.encode(&quot;gb18030&quot;))</span><br></pre></td></tr></table></figure><p>虽说骨架是定下来了，但在特殊函数比如下载函数就需要另外编写。</p><p>##总结</p><p>虽然新版脚本框架是为了radioit计划而写的代码，但是其中<code>argparse</code>模块的使用的代码也是能被借鉴在其他需要带参数运行的python脚本中。</p><p>新版对比旧版，增加了功能，但是也增加了使用的复杂度和代码的长度。旧版还是可以保留下来，供日常快速使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;http://blog.e10t.net/how-to-save-internet-radio/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;的实践基础和&lt;a href=&quot;http://blog.e10t.net/ap
      
    
    </summary>
    
    
      <category term=" - python - radioit" scheme="https://www.e10t.net/tags/python-radioit/"/>
    
  </entry>
  
  <entry>
    <title>python × Qt应用开发 · 2.5 -- 改进软件界面</title>
    <link href="https://www.e10t.net/2015/03/02/python-with-qt-application-development-2-5-developing-gui/"/>
    <id>https://www.e10t.net/2015/03/02/python-with-qt-application-development-2-5-developing-gui/</id>
    <published>2015-03-02T06:35:16.000Z</published>
    <updated>2015-03-02T09:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.e10t.net/python-with-qt-application-development-2-preliminary-design/" target="_blank" rel="noopener">上一篇文章</a>完成基本的界面，但是应用看起来并不算特别好看。</p><p>主要是因为软件的界面使用默认的样式和普通的窗口框架。接下来从这两个方面出发，尝试改进软件界面。</p><p>##自定义样式</p><p>Qt 给控件的样式化提供了一定的自由度，包括背景色、边框和特定控件的自定义，使用类似CSS的语法。这要求编写软件的人了解基础的CSS语法。各种控件和详细例子：<a href="http://qt-project.org/doc/qt-4.8/stylesheet-examples.html" target="_blank" rel="noopener">点这里</a></p><p>要改变一个控件的样式，可以在属性编辑器中找到<code>styleSheet</code>属性，将CSS代码写进去。</p><p>这里以中间栏的输入框作为例子。</p><p>选择输入框，在属性编辑器中找到<code>styleSheet</code>，输入以下CSS代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit&#123;</span><br><span class="line">border-radius: 10px;</span><br><span class="line">padding: 5px 10px;</span><br><span class="line">margin: 0 10%;</span><br><span class="line">background-color: white;</span><br><span class="line">border: 1px solid #c9c9c9;</span><br><span class="line">color: #1b1b1e;</span><br><span class="line">&#125;</span><br><span class="line">QLineEdit:hover&#123;</span><br><span class="line">background-color: white;</span><br><span class="line">border: 1px solid #969696;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结束编辑，立刻可以看到效果。</p><p>修改前：</p><p><img src="https://i.imgur.com/HyNEzg9.png" alt="前"></p><p>修改后：</p><p><img src="https://i.imgur.com/YYoVsyW.png" alt="后"></p><p>给widget加上背景颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QWidget&#123;</span><br><span class="line">background-color:#xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/MxL75UV.png" alt="widget背景色"></p><p>消除控件的自带边框。在属性编辑器中找到<code>frameShape</code>，设置值为<code>NoFrame</code>；找到<code>frameShadow</code>，设置值为<code>Plain</code>；找到<code>lineWidth</code>，设置值为<code>0</code>。</p><p><img src="https://i.imgur.com/siT0NF2.png" alt="消除边框"></p><p>自定义按钮样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QPushButton&#123;</span><br><span class="line">background-color: transparent;</span><br><span class="line">border-style:outset;</span><br><span class="line">border-width: 0px;</span><br><span class="line">padding: 5px 0;</span><br><span class="line">color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/S69GG8T.png" alt="自定义按钮"></p><p>其他细节都是类似的修改。</p><p>##使用无框架窗口</p><p>必须要在代码中实现。</p><p>回忆本系列第一篇文章，使用QtDesigner做出来的知识view而已，controller是需要在<code>MainWindow.py</code>中实现的。这里不再累述。</p><p>找到<code>initUI(self)</code>函数，加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># no frame window</span><br><span class="line">self.setWindowFlags(QtCore.Qt.FramelessWindowHint)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/x3w4utd.png" alt="无框架窗口"></p><p>没有了系统默认的框架，好看的同时也失去了三个系统提供的便捷功能：功能按钮、窗口拉伸和窗口移动。</p><p>下面来解决。</p><p>###功能按钮<br>在最上面加上一个控件，充当窗口的标题栏和关闭按钮的容器。</p><p>在控件里面简单地拖进一个标签控件作为标题，一个按钮作为关闭按钮。控件设置为蓝色。</p><p>运行（非预览）之后发现背景色没有完全填充，如下图。</p><p><img src="https://i.imgur.com/YcvA5M8.png" alt="背景色没有完全填充"></p><p>这个要在代码里面修复。</p><p>找到<code>initUI(self)</code>函数，加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.ui.widgetHead.setAttribute(QtCore.Qt.WA_StyledBackground, True)</span><br><span class="line">self.ui.widgetLeft.setAttribute(QtCore.Qt.WA_StyledBackground, True)</span><br></pre></td></tr></table></figure><p>具体来说就是在控件上调用<code>setAttribute(QtCore.Qt.WA_StyledBackground, True)</code>。</p><p>###窗口拉伸<br>需要使用到一个名为<code>QSizeGrip</code>的类，只是这个类不能在QtDesigner中直接拖入，需要在代码中手动添加。</p><p>找到右边栏widget的layout，更名为<code>verticalLayoutRight</code>。然后在<code>initUI(self)</code>函数中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.ui.verticalLayoutRight.addWidget(QtGui.QSizeGrip(self), 0, QtCore.Qt.AlignBottom | QtCore.Qt.AlignRight)</span><br></pre></td></tr></table></figure><p>###窗口移动<br>窗口移动的功能是设置在窗口的标题栏上的，自实现的标题栏也要实现此功能。</p><p>在<code>MainWindow</code>类下，直接贴入以下函数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def mousePressEvent(self, event):</span><br><span class="line">    &quot;&quot;&quot; override mouse press event &quot;&quot;&quot;</span><br><span class="line">    self._postion = event.globalPos() - self.pos()</span><br><span class="line"></span><br><span class="line">def mouseMoveEvent(self, event):</span><br><span class="line">    &quot;&quot;&quot; override mouse move event &quot;&quot;&quot;</span><br><span class="line">    self.move(event.globalPos() - self._postion)</span><br><span class="line"></span><br><span class="line">def closeEvent(self, event):</span><br><span class="line">    &quot;&quot;&quot; override close event &quot;&quot;&quot;</span><br><span class="line">    event.accept()</span><br></pre></td></tr></table></figure><p>原理很简单，自己处理鼠标点击和拖动事件。</p><p>最终形态。</p><p><img src="https://i.imgur.com/omAswmv.png" alt="最终"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/python-with-qt-application-development-2-preliminary-design/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;完成基本的
      
    
    </summary>
    
    
      <category term=" - python - Qt" scheme="https://www.e10t.net/tags/python-Qt/"/>
    
  </entry>
  
  <entry>
    <title>旅游照——杭州[21p]</title>
    <link href="https://www.e10t.net/2015/01/31/tour-photo-hangzhou/"/>
    <id>https://www.e10t.net/2015/01/31/tour-photo-hangzhou/</id>
    <published>2015-01-31T14:57:41.000Z</published>
    <updated>2015-01-31T14:57:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.e10t.net/tour-photo-shanghai/" target="_blank" rel="noopener">第一天的上海</a></p><p><a href="http://blog.e10t.net/tour-photo-suzhou-wuzhen-night/" target="_blank" rel="noopener">第二天的苏州和乌镇晚上</a></p><p><a href="http://blog.e10t.net/tour-photo-wuzhen-hangzhou/" target="_blank" rel="noopener">第三天的乌镇和杭州</a></p><p>这次的重点不在杭州，所以西湖根本游不完。天气也很差，有雾，拍出来灰蒙蒙的。后期也不怎么会，将就着看吧。</p><p><img src="https://i.imgur.com/4XHolhu.jpg" alt="1"></p><p><img src="https://i.imgur.com/WZWG85m.jpg" alt="2"></p><p><img src="https://i.imgur.com/hDtIsFr.jpg" alt="3"></p><p><img src="https://i.imgur.com/73f8Bkz.jpg" alt="4"></p><p><img src="https://i.imgur.com/aCKAhPm.jpg" alt="5"></p><p><img src="https://i.imgur.com/VNFm7LK.jpg" alt="6"></p><p><img src="https://i.imgur.com/yYxJpAQ.jpg" alt="7"></p><p><img src="https://i.imgur.com/X16zEsD.jpg" alt="8"></p><p><img src="https://i.imgur.com/CkJjkv5.jpg" alt="9"></p><p><img src="https://i.imgur.com/xYSL1r7.jpg" alt="10"></p><p><img src="https://i.imgur.com/1Uo3MAb.jpg" alt="11"></p><p><img src="https://i.imgur.com/vWHvn6S.jpg" alt="12"></p><p><img src="https://i.imgur.com/o2faV1M.jpg" alt="13"></p><p><img src="https://i.imgur.com/tfurWS8.jpg" alt="14"></p><p><img src="https://i.imgur.com/pFNhXhu.jpg" alt="15"></p><p><img src="https://i.imgur.com/jaDM8I2.jpg" alt="16"></p><p><img src="https://i.imgur.com/FlpczgP.jpg" alt="17"></p><p><img src="https://i.imgur.com/Uv0ZvC9.jpg" alt="18"></p><p><img src="https://i.imgur.com/D1NoEQ9.jpg" alt="19"></p><p><img src="https://i.imgur.com/P5pCDnr.jpg" alt="20"></p><p><img src="https://i.imgur.com/1NESmPN.jpg" alt="21"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/tour-photo-shanghai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一天的上海&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/tour-p
      
    
    </summary>
    
    
      <category term=" - photograph - travel" scheme="https://www.e10t.net/tags/photograph-travel/"/>
    
  </entry>
  
  <entry>
    <title>旅游照——乌镇 &amp; 杭州[53p]</title>
    <link href="https://www.e10t.net/2015/01/31/tour-photo-wuzhen-hangzhou/"/>
    <id>https://www.e10t.net/2015/01/31/tour-photo-wuzhen-hangzhou/</id>
    <published>2015-01-31T13:32:09.000Z</published>
    <updated>2015-01-31T14:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.e10t.net/tour-photo-shanghai/" target="_blank" rel="noopener">第一天的上海</a></p><p><a href="http://blog.e10t.net/tour-photo-suzhou-wuzhen-night/" target="_blank" rel="noopener">第二天的苏州和乌镇晚上</a></p><p>第三天早上在乌镇。早早起来拍摄。</p><p>不太会后期，都是相机jpg直出了。</p><p><img src="https://i.imgur.com/1JUHRNi.jpg" alt="1"></p><p><img src="https://i.imgur.com/OMuzaD4.jpg" alt="2"></p><p><img src="https://i.imgur.com/ofVj8MD.jpg" alt="3"></p><p><img src="https://i.imgur.com/xRmqMUK.jpg" alt="4"></p><p>冷到有霜。</p><p><img src="https://i.imgur.com/TYnzsH9.jpg" alt="5"></p><p><img src="https://i.imgur.com/0Rr0PWT.jpg" alt="6"></p><p><img src="https://i.imgur.com/KradevJ.jpg" alt="7"></p><p><img src="https://i.imgur.com/mDX99Ju.jpg" alt="8"></p><p><img src="https://i.imgur.com/A1chnJP.jpg" alt="9"></p><p><img src="https://i.imgur.com/ytk0beu.jpg" alt="10"></p><p><img src="https://i.imgur.com/p5KoJhs.jpg" alt="11"></p><p><img src="https://i.imgur.com/Htqi3ho.jpg" alt="12"></p><p><img src="https://i.imgur.com/vFEu58e.jpg" alt="13"></p><p><img src="https://i.imgur.com/AJnLuLS.jpg" alt="14"></p><p><img src="https://i.imgur.com/jIKUNna.jpg" alt="15"></p><p><img src="https://i.imgur.com/VynvVFM.jpg" alt="16"></p><p><img src="https://i.imgur.com/ZHMzzkJ.jpg" alt="17"></p><p><img src="https://i.imgur.com/hb6M6u8.jpg" alt="18"></p><p>早晨的乌镇真是美极了。</p><p><img src="https://i.imgur.com/l3WYGn5.jpg" alt="19"></p><p><img src="https://i.imgur.com/5jVJdy4.jpg" alt="20"></p><p><img src="https://i.imgur.com/j1F7zk5.jpg" alt="21"></p><p><img src="https://i.imgur.com/DHLQ5aE.jpg" alt="22"></p><p><img src="https://i.imgur.com/HzszDYj.jpg" alt="23"></p><p><img src="https://i.imgur.com/uu5hXHl.jpg" alt="24"></p><p><img src="https://i.imgur.com/fE0yEV2.jpg" alt="25"></p><p><img src="https://i.imgur.com/FnsUHll.jpg" alt="26"></p><p><img src="https://i.imgur.com/huNDLED.jpg" alt="27"></p><p><img src="https://i.imgur.com/am1qYSS.jpg" alt="28"></p><p><img src="https://i.imgur.com/3jj2FjY.jpg" alt="29"></p><p><img src="https://i.imgur.com/klwck5I.jpg" alt="30"></p><p><img src="https://i.imgur.com/ihmauQQ.jpg" alt="31"></p><p><img src="https://i.imgur.com/qJMGQdH.jpg" alt="32"></p><p><img src="https://i.imgur.com/p1IGqxA.jpg" alt="33"></p><p><img src="https://i.imgur.com/fqLjTYP.jpg" alt="34"></p><p><img src="https://i.imgur.com/nKWDIDt.jpg" alt="35"></p><p><img src="https://i.imgur.com/7nIhJqu.jpg" alt="36"></p><p><img src="https://i.imgur.com/lUAWiW9.jpg" alt="37"></p><p><img src="https://i.imgur.com/nN1iKsB.jpg" alt="38"></p><p>住的酒店叫做昭明书社。在外面拍完照回到房间，刚好看到窗边的一缕阳光照到盒子上面。</p><p><img src="https://i.imgur.com/rfdyGMM.jpg" alt="39"></p><p>团里的两个女孩子，广大的。</p><p><img src="https://i.imgur.com/5ADw5nm.jpg" alt="40"></p><p>到了河坊街。</p><p><img src="https://i.imgur.com/DEupzJ8.jpg" alt="41"></p><p><img src="https://i.imgur.com/1suidSV.jpg" alt="42"></p><p><img src="https://i.imgur.com/EphRYrk.jpg" alt="43"></p><p><img src="https://i.imgur.com/9WRaJ6m.jpg" alt="44"></p><p>晚上去了宋城。其实只是个古代主题的现代游乐园而已。</p><p><img src="https://i.imgur.com/iTdaahM.jpg" alt="45"></p><p><img src="https://i.imgur.com/oTszkZw.jpg" alt="46"></p><p><img src="https://i.imgur.com/s5dhOQN.jpg" alt="47"></p><p><img src="https://i.imgur.com/qJQ1vK7.jpg" alt="48"></p><p><img src="https://i.imgur.com/61jQeP2.jpg" alt="49"></p><p><img src="https://i.imgur.com/MfqY6PW.jpg" alt="50"></p><p><img src="https://i.imgur.com/s6VT0eI.jpg" alt="51"></p><p><img src="https://i.imgur.com/Y9rJ8XG.jpg" alt="52"></p><p><img src="https://i.imgur.com/IybjEsC.jpg" alt="53"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/tour-photo-shanghai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一天的上海&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/tour-p
      
    
    </summary>
    
    
      <category term=" - photograph - travel" scheme="https://www.e10t.net/tags/photograph-travel/"/>
    
  </entry>
  
  <entry>
    <title>旅游照——苏州 &amp; 乌镇晚上[44p]</title>
    <link href="https://www.e10t.net/2015/01/31/tour-photo-suzhou-wuzhen-night/"/>
    <id>https://www.e10t.net/2015/01/31/tour-photo-suzhou-wuzhen-night/</id>
    <published>2015-01-31T10:36:27.000Z</published>
    <updated>2015-01-31T10:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.e10t.net/tour-photo-shanghai/" target="_blank" rel="noopener">第一天的上海</a></p><p>第二天去苏州。</p><p>苏州的园林真的很好看，进去之后怎么看都有意思。亭台楼阁，池鱼树石，皆有情趣。</p><p>晚上在乌镇住，室外温度到了零下，拍了一晚手都弯不了。</p><p>七里山塘古街。</p><p>其实两岸和水都挺脏的，因为两岸仍然有人住。</p><p><img src="https://i.imgur.com/pi26QrH.jpg" alt="1"></p><p><img src="https://i.imgur.com/q4I6v4P.jpg" alt="2"></p><p><img src="https://i.imgur.com/YpLWPhA.jpg" alt="3"></p><p><img src="https://i.imgur.com/BN5sk9Z.jpg" alt="4"></p><p>团里的两对情侣。</p><p><img src="https://i.imgur.com/Ua32x67.jpg" alt="5"></p><p><img src="https://i.imgur.com/B9wcQP4.jpg" alt="6"></p><p><img src="https://i.imgur.com/QvzErQJ.jpg" alt="7"></p><p><img src="https://i.imgur.com/WRwKHFH.jpg" alt="8"></p><p><img src="https://i.imgur.com/kjgzB8Q.jpg" alt="9"></p><p><img src="https://i.imgur.com/hmQbcvN.jpg" alt="10"></p><p><img src="https://i.imgur.com/YGDXSUJ.jpg" alt="11"></p><p>这个拿着单反的人后来要我帮他拍两张，手中的rx100顿时被比了下去。</p><p><img src="https://i.imgur.com/n2tZcng.jpg" alt="12"></p><p><img src="https://i.imgur.com/eiqAQ0n.jpg" alt="13"></p><p>然后去了某个园林。</p><p><img src="https://i.imgur.com/4Zh4yZS.jpg" alt="14"></p><p><img src="https://i.imgur.com/BNozgIo.jpg" alt="15"></p><p><img src="https://i.imgur.com/uqLVvas.jpg" alt="16"></p><p>偷拍到某只黑猫。</p><p><img src="https://i.imgur.com/lireIkF.jpg" alt="17"></p><p>古代和现代。</p><p><img src="https://i.imgur.com/m6WPo3i.jpg" alt="18"></p><p>接下来去留园。</p><p>导游在买票。</p><p><img src="https://i.imgur.com/VBE4ZDs.jpg" alt="19"></p><p>团里两个小萝莉。</p><p><img src="https://i.imgur.com/A7pdX7l.jpg" alt="20"></p><p><img src="https://i.imgur.com/p789eph.jpg" alt="21"></p><p><img src="https://i.imgur.com/iYcMbhZ.jpg" alt="22"></p><p><img src="https://i.imgur.com/Tz7iKoz.jpg" alt="23"></p><p><img src="https://i.imgur.com/H6yCBLh.jpg" alt="24"></p><p><img src="https://i.imgur.com/qwpRRbP.jpg" alt="25"></p><p><img src="https://i.imgur.com/RavH7FJ.jpg" alt="26"></p><p><img src="https://i.imgur.com/59puEZh.jpg" alt="27"></p><p><img src="https://i.imgur.com/switymk.jpg" alt="28"></p><p><img src="https://i.imgur.com/Nc3PsMX.jpg" alt="29"></p><p><img src="https://i.imgur.com/SlEFWcw.jpg" alt="30"></p><p><img src="https://i.imgur.com/zeqIFWU.jpg" alt="31"></p><p>晚上入住乌镇。</p><p><img src="https://i.imgur.com/t6tyWwx.jpg" alt="32"></p><p><img src="https://i.imgur.com/hiGpelH.jpg" alt="33"></p><p><img src="https://i.imgur.com/HiK7yxN.jpg" alt="34"></p><p><img src="https://i.imgur.com/BI3lvxX.jpg" alt="35"></p><p><img src="https://i.imgur.com/t4X6XYI.jpg" alt="36"></p><p><img src="https://i.imgur.com/sgkahUG.jpg" alt="37"></p><p><img src="https://i.imgur.com/xjATkfu.jpg" alt="38"></p><p><img src="https://i.imgur.com/gCEV0n0.jpg" alt="39"></p><p><img src="https://i.imgur.com/mj5927J.jpg" alt="40"></p><p><img src="https://i.imgur.com/INzMgMI.jpg" alt="41"></p><p><img src="https://i.imgur.com/dUBJDJw.jpg" alt="42"></p><p><img src="https://i.imgur.com/x925bYQ.jpg" alt="43"></p><p><img src="https://i.imgur.com/aD8F3Gp.jpg" alt="44"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.e10t.net/tour-photo-shanghai/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一天的上海&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二天去苏州。&lt;/p&gt;
&lt;p&gt;苏州的园林真的很好看，进去之后怎么看都有意
      
    
    </summary>
    
    
      <category term=" - photograph - travel" scheme="https://www.e10t.net/tags/photograph-travel/"/>
    
  </entry>
  
</feed>
